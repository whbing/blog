<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zxlg&#39;s notes</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://happylg.cn/"/>
  <updated>2017-08-19T09:03:37.727Z</updated>
  <id>http://happylg.cn/</id>
  
  <author>
    <name>zxlg</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>NexT主题升级</title>
    <link href="http://happylg.cn/2017/08/19/next-theme-upgrade/"/>
    <id>http://happylg.cn/2017/08/19/next-theme-upgrade/</id>
    <published>2017-08-19T08:56:25.000Z</published>
    <updated>2017-08-19T09:03:37.727Z</updated>
    
    <content type="html"><![CDATA[<p>目前升级 NexT 主题的时候并不是非常的流畅。若使用 git pull 的方式，很多时候可能会产生冲突；而下载新版本覆盖安装的方式又需要手动合并主题的 _config.yml 文件。</p>
<p>在此修改之前， NexT 建议将配置分离，一部分在 站点的配置文件中，另外一部分在主题的配置文件中。将需要自定的选项放置在 站点配置文件中，从而脱离避免更新主题时可能遇到的麻烦。这种方式是可行，但是有一些缺点：</p>
<p>配置分离成了两个部分<br>用户可能会疑惑一些选项该放置在哪里比较合适<br>为了解决这个问题， NexT 将会使用 Hexo 的 Data Files 。然而由于 Data Files 是在 Hexo 3 版本时引进的，所以要使用这个特性，需要 Hexo 的版本不低于 3。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>通过这个特性，你可以将所有的主题配置放置在站点的 source/_data/next.yml 文件中。原先放置在 站点配置文件 中的选项可以迁移到新的位置，同时，主题配置文件可以不用做任何修改。若后续版本有配置相关的改动时，你仅需在 next.yml 中做相应调整即可。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>请先确保你所使用的 Hexo 版本在 3 以上<br>在站点的 source/_data 目录下新建 next.yml 文件（_data目录可能需要新建）<br>迁移站点配置文件和主题配置文件中的配置到 next.yml 中</p>
<h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><ol>
<li><a href="https://github.com/iissnan/hexo-theme-next/issues/328" target="_blank" rel="external">NexT主题升级</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;目前升级 NexT 主题的时候并不是非常的流畅。若使用 git pull 的方式，很多时候可能会产生冲突；而下载新版本覆盖安装的方式又需要手动合并主题的 _config.yml 文件。&lt;/p&gt;
&lt;p&gt;在此修改之前， NexT 建议将配置分离，一部分在 站点的配置文件中，另外
    
    </summary>
    
      <category term="建站日志" scheme="http://happylg.cn/categories/%E5%BB%BA%E7%AB%99%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="hexo" scheme="http://happylg.cn/tags/hexo/"/>
    
      <category term="NexT" scheme="http://happylg.cn/tags/NexT/"/>
    
  </entry>
  
  <entry>
    <title>阿里巴巴在线笔试</title>
    <link href="http://happylg.cn/2017/08/17/alibaba-interview/"/>
    <id>http://happylg.cn/2017/08/17/alibaba-interview/</id>
    <published>2017-08-17T10:23:35.000Z</published>
    <updated>2017-08-19T00:59:09.575Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>利用面向对象思想完成买家信息删除功能，每一条买家信息包含</p>
<ul>
<li>姓名 (name)</li>
<li>性别 (sex)</li>
<li>电话号码 (number)</li>
<li>省份 (province)</li>
</ul>
<h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><ol>
<li>不能借助任何三方库，需使用原生代码实现</li>
<li>结合给出的基本代码结构，在下方2处code here处补充代码，完成买家信息的删除功能，注意此页面需要在手机上清晰显示。</li>
<li>js代码可任意调整，例如可使用es6语法完成<a id="more"></a>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line"></div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</div><div class="line">    &lt;!--code here--&gt;</div><div class="line">    &lt;title&gt;demo&lt;/title&gt;</div><div class="line">    &lt;style&gt;</div><div class="line">    * &#123;</div><div class="line">        padding: 0;</div><div class="line">        margin: 0;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    .head,</div><div class="line">    li div &#123;</div><div class="line">        display: inline-block;</div><div class="line">        width: 70px;</div><div class="line">        text-align: center;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    li .id,</div><div class="line">    li .sex,</div><div class="line">    .id,</div><div class="line">    .sex &#123;</div><div class="line">        width: 15px;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    li .name,</div><div class="line">    .name &#123;</div><div class="line">        width: 40px;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    li .tel,</div><div class="line">    .tel &#123;</div><div class="line">        width: 90px;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    li .del,</div><div class="line">    .del &#123;</div><div class="line">        width: 15px;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ul &#123;</div><div class="line">        list-style: none;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    .user-delete &#123;</div><div class="line">        cursor: pointer;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @media screen and (max-width: 768px) &#123;</div><div class="line">        //宽度小于768px时</div><div class="line">        .head,</div><div class="line">        li div &#123;</div><div class="line">            display: inline-block;</div><div class="line">            width: 23.3%;</div><div class="line">            text-align: center;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        li .id,</div><div class="line">        li .sex,</div><div class="line">        .id,</div><div class="line">        .sex &#123;</div><div class="line">            width: 5%;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        li .name,</div><div class="line">        .name &#123;</div><div class="line">            width: 13.3%;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        li .tel,</div><div class="line">        .tel &#123;</div><div class="line">            width: 30%;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        li .del,</div><div class="line">        .del &#123;</div><div class="line">            width: 5%;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        ul &#123;</div><div class="line">            list-style: none;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        .user-delete &#123;</div><div class="line">            cursor: pointer;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    &lt;/style&gt;</div><div class="line">&lt;/head&gt;</div><div class="line"></div><div class="line">&lt;body&gt;</div><div class="line">    &lt;div id=&quot;J_container&quot;&gt;</div><div class="line">        &lt;div class=&quot;record-head&quot;&gt;</div><div class="line">            &lt;div class=&quot;head id&quot;&gt;序号&lt;/div&gt;</div><div class="line">            &lt;div class=&quot;head name&quot;&gt;姓名&lt;/div&gt;</div><div class="line">            &lt;div class=&quot;head sex&quot;&gt;性别&lt;/div&gt;</div><div class="line">            &lt;div class=&quot;head tel&quot;&gt;电话号码&lt;/div&gt;</div><div class="line">            &lt;div class=&quot;head province&quot;&gt;省份&lt;/div&gt;</div><div class="line">            &lt;div class=&quot;head&quot;&gt;操作&lt;/div&gt;</div><div class="line">        &lt;/div&gt;</div><div class="line">        &lt;ul id=&quot;J_List&quot;&gt;</div><div class="line">            &lt;li&gt;</div><div class="line">                &lt;div class=&quot;id&quot;&gt;1&lt;/div&gt;</div><div class="line">                &lt;div class=&quot;name&quot;&gt;张三&lt;/div&gt;</div><div class="line">                &lt;div class=&quot;sex&quot;&gt;男&lt;/div&gt;</div><div class="line">                &lt;div class=&quot;tel&quot;&gt;13788888888&lt;/div&gt;</div><div class="line">                &lt;div class=&quot;province&quot;&gt;浙江&lt;/div&gt;</div><div class="line">                &lt;div class=&quot;user-delete&quot;&gt;删除&lt;/div&gt;</div><div class="line">            &lt;/li&gt;</div><div class="line">            &lt;li&gt;</div><div class="line">                &lt;div class=&quot;id&quot;&gt;2&lt;/div&gt;</div><div class="line">                &lt;div class=&quot;name&quot;&gt;李四&lt;/div&gt;</div><div class="line">                &lt;div class=&quot;sex&quot;&gt;女&lt;/div&gt;</div><div class="line">                &lt;div class=&quot;tel&quot;&gt;13788887777&lt;/div&gt;</div><div class="line">                &lt;div class=&quot;province&quot;&gt;四川&lt;/div&gt;</div><div class="line">                &lt;div class=&quot;user-delete&quot;&gt;删除&lt;/div&gt;</div><div class="line">            &lt;/li&gt;</div><div class="line">            &lt;li&gt;</div><div class="line">                &lt;div class=&quot;id&quot;&gt;3&lt;/div&gt;</div><div class="line">                &lt;div class=&quot;name&quot;&gt;王二&lt;/div&gt;</div><div class="line">                &lt;div class=&quot;sex&quot;&gt;男&lt;/div&gt;</div><div class="line">                &lt;div class=&quot;tel&quot;&gt;13788889999&lt;/div&gt;</div><div class="line">                &lt;div class=&quot;province&quot;&gt;广东&lt;/div&gt;</div><div class="line">                &lt;div class=&quot;user-delete&quot;&gt;删除&lt;/div&gt;</div><div class="line">            &lt;/li&gt;</div><div class="line">        &lt;/ul&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">    &lt;script&gt;</div><div class="line">    var ul = document.getElementById(&quot;J_List&quot;);</div><div class="line">    var del = document.getElementsByClassName(&apos;user-delete&apos;);</div><div class="line">    for (let i = 0; i &lt; del.length; i++) &#123;</div><div class="line">        del[i].onclick = function(event) &#123;</div><div class="line">            ul.removeChild(event.target.parentNode);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">    &lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line"></div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>菜鸟网络仓库有一排小货架，共有N个，货架的底部是空的，现在智能机器人在某个货架下，小明写了一个非常简单的智能机器人移动程序,逻辑如下：每过1分钟，智能机器人必须随机的从一个货架下移动到相邻的一个货架下。比如刚开始智能机器人在第4个货架下，过1分钟后，智能机器人可能会在第3个货架下或者在第5个货架下。如果刚开始时智能机器人在第1个货架下，过1分钟以后，智能机器人一定会在第2个货架下。<br>现在告诉你货架的数目N，已经智能机器人开始所在的位置P，小明很想知道，在M分钟后，智能机器人到达第T货架，一共有多少种行走方案。请帮小明算一算。<br>输入：<br>N<br>P<br>M<br>T<br>输出：一共有多少种行走方案</p>
<h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">// java</div><div class="line">import java.util.Scanner;</div><div class="line"></div><div class="line">public class Main &#123;</div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		Scanner sc = new Scanner(System.in);</div><div class="line">		while (sc.hasNext()) &#123;</div><div class="line">			int N = sc.nextInt();// 货架数量</div><div class="line">			int P = sc.nextInt();// 起始位置</div><div class="line">			int M = sc.nextInt();// 时间</div><div class="line">			int T = sc.nextInt();// 结束位置</div><div class="line">			int res = solution(N, P, M, T);</div><div class="line">			System.out.println(res);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static int solution(int n, int p, int m, int t) &#123;</div><div class="line">		int[][] dp = new int[m + 1][n + 2];// 起始末尾添加两列，防止越界</div><div class="line">		dp[0][p] = 1;</div><div class="line">		for (int i = 1; i &lt; dp.length; i++) &#123; // 时间从1开始，dp[0][p]为1，其他均为0</div><div class="line">			for (int j = 1; j &lt; dp[0].length - 1; j++) &#123;// 位置从1开始到length-2是为了防止数组越界</div><div class="line">				dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1];</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return dp[m][t];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">// js</div><div class="line"></div><div class="line">var readline = require(&apos;readline&apos;);</div><div class="line">const rl = readline.createInterface(&#123;</div><div class="line">    input: process.stdin,</div><div class="line">    output: process.stdout</div><div class="line">&#125;);</div><div class="line">var length = 4;</div><div class="line">var flag = 0;</div><div class="line">var arr = [];</div><div class="line">rl.on(&apos;line&apos;, function (input) &#123;</div><div class="line">    flag++;</div><div class="line">    input = parseInt(input);</div><div class="line">    arr.push(input);</div><div class="line">    if (flag == length) &#123;</div><div class="line">        var res = soulution(arr);</div><div class="line">        console.log(res);</div><div class="line">        flag = 0;</div><div class="line">        arr = [];</div><div class="line">    &#125;</div><div class="line">&#125;).on(&apos;close&apos;, function () &#123;</div><div class="line"></div><div class="line">&#125;);</div><div class="line"></div><div class="line">function soulution(arr) &#123;</div><div class="line">    var n = arr[0];//货架数量</div><div class="line">    var p = arr[1];//初始位置</div><div class="line">    var m = arr[2];//经过时间</div><div class="line">    var t = arr[3];//结束位置</div><div class="line">    var dp = [];</div><div class="line">    for (var i = 0; i &lt; m + 1; i++) &#123;</div><div class="line">        dp[i] = new Array;</div><div class="line">        for (var j = 0; j &lt; n + 2; j++) &#123;</div><div class="line">            dp[i][j] = 0;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    dp[0][p] = 1;</div><div class="line">    for (var i = 1; i &lt; dp.length; i++) &#123;</div><div class="line">        for (var j = 1; j &lt; dp[0].length - 1; j++) &#123; //1-n防止数组越界</div><div class="line">            dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return dp[m][t];</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前端&quot;&gt;&lt;a href=&quot;#前端&quot; class=&quot;headerlink&quot; title=&quot;前端&quot;&gt;&lt;/a&gt;前端&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;利用面向对象思想完成买家信息删除功能，每一条买家信息包含&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;姓名 (name)&lt;/li&gt;
&lt;li&gt;性别 (sex)&lt;/li&gt;
&lt;li&gt;电话号码 (number)&lt;/li&gt;
&lt;li&gt;省份 (province)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;要求&quot;&gt;&lt;a href=&quot;#要求&quot; class=&quot;headerlink&quot; title=&quot;要求&quot;&gt;&lt;/a&gt;要求&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;不能借助任何三方库，需使用原生代码实现&lt;/li&gt;
&lt;li&gt;结合给出的基本代码结构，在下方2处code here处补充代码，完成买家信息的删除功能，注意此页面需要在手机上清晰显示。&lt;/li&gt;
&lt;li&gt;js代码可任意调整，例如可使用es6语法完成
    
    </summary>
    
      <category term="Interview" scheme="http://happylg.cn/categories/Interview/"/>
    
    
      <category term="js" scheme="http://happylg.cn/tags/js/"/>
    
      <category term="html" scheme="http://happylg.cn/tags/html/"/>
    
      <category term="css" scheme="http://happylg.cn/tags/css/"/>
    
      <category term="interview" scheme="http://happylg.cn/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>《上帝掷骰子吗？——量子力学史话》读书笔记</title>
    <link href="http://happylg.cn/2017/08/14/does-god-throw-dice/"/>
    <id>http://happylg.cn/2017/08/14/does-god-throw-dice/</id>
    <published>2017-08-14T01:07:02.000Z</published>
    <updated>2017-08-19T06:37:33.832Z</updated>
    
    <content type="html"><![CDATA[<p>2017.8.5开始读，2017.8.12日读完<br>这是一本关于量子力学的历史的科普性著作</p>
<hr>
<p>2017.8.14更新</p>
<hr>
<h1 id="经典物理的黄金时代"><a href="#经典物理的黄金时代" class="headerlink" title="经典物理的黄金时代"></a>经典物理的黄金时代</h1><h2 id="光的本质"><a href="#光的本质" class="headerlink" title="光的本质"></a>光的本质</h2><p>波动说和粒子说</p>
<h2 id="波动粒子之争"><a href="#波动粒子之争" class="headerlink" title="波动粒子之争"></a>波动粒子之争</h2><h3 id="第一次波粒战争"><a href="#第一次波粒战争" class="headerlink" title="第一次波粒战争"></a>第一次波粒战争</h3><p>主要参与人物：</p>
<ol>
<li>粒子说：牛顿<ul>
<li>《光学》，色散，牛顿环(明暗条纹)，衍射</li>
<li>质疑如果光是波，为什么无法像声音那样绕开障碍物前进？</li>
</ul>
</li>
<li>波动说：胡克(光是一种纵波)，惠更斯<br>第一次交锋以牛顿为首的微粒说战胜了波动说</li>
</ol>
<h3 id="第二次波粒战争"><a href="#第二次波粒战争" class="headerlink" title="第二次波粒战争"></a>第二次波粒战争</h3><ol>
<li>波的干涉<br> 托马斯.杨: 波的双缝干涉实验(1807年)<br> 波的叠加与抵消</li>
<li>决定性事件(1819年)<br> 菲涅尔: 采用光是一种波动的观点，用严密的数学推理解释了光的衍射<br> 该理论用于圆盘衍射为一个亮斑，泊松质疑，阿拉果坚持实验检测，完美证明，后被误称为“泊松亮斑”</li>
<li>光的偏振<br> 菲涅尔提出光是一种横波，而不是纵波，成功解析了偏振现象(1821年)</li>
<li>光速<br> 傅科：“傅科摆”(1850年)<br> 测量光在真空和水中的速度，后者为前者的3/4</li>
<li>电磁理论<br> 麦克斯韦发表电磁理论的论文，预言光是电磁波的一种(1861年)<br> 赫兹实验证明了麦克斯韦电磁理论(1887年)<br> 麦氏方程在数学上完美得难以置信，科学美的典范<br>至此，波动的光辉达到顶点<a id="more"></a>
</li>
</ol>
<h1 id="乌云"><a href="#乌云" class="headerlink" title="乌云"></a>乌云</h1><p>开尔文《在热和光动力理论上空的十九世纪乌云》<br>两朵乌云分别指：经典物理在光以太和麦克斯韦-玻尔兹曼能量均分学说遇到的难题，具体而言为迈克尔逊-莫雷实验和黑体辐射研究中的困难</p>
<h2 id="第一朵乌云"><a href="#第一朵乌云" class="headerlink" title="第一朵乌云"></a>第一朵乌云</h2><p>第一朵乌云为迈克尔逊-莫雷实验：探测光以太对于地球的漂移速度<br>经典的失败实验<br>最终导致了相对论革命的爆发</p>
<h2 id="第二朵乌云"><a href="#第二朵乌云" class="headerlink" title="第二朵乌云"></a>第二朵乌云</h2><p>第二朵乌云为黑体辐射实验和理论的不一致<br>最终导致了量子革命的爆发</p>
<h2 id="黑体辐射研究"><a href="#黑体辐射研究" class="headerlink" title="黑体辐射研究"></a>黑体辐射研究</h2><p>黑体辐射研究：物体的辐射能量和温度具有怎样的函数关系？<br>从粒子角度去推导，维恩提出辐射能量分布定律公式(1894年)，即著名的维恩分布公式<br>实验证明：黑体加热到1000K以上的高温时，测到短波范围内的曲线和维恩公式符合的很好，但在长波方面，实验出现了偏差<br>从经典的电磁波的角度去推导，瑞利和金斯提出如瑞利-金斯公式，长波符合，短波出现偏差<br>两套公式均无法给出正确的黑体辐射分布</p>
<h2 id="普朗克黑体辐射研究"><a href="#普朗克黑体辐射研究" class="headerlink" title="普朗克黑体辐射研究"></a>普朗克黑体辐射研究</h2><p>普朗克利用数学上的内插法，凑出一个公式。在长波的时候，它表现得就像正比关系一样。而在短波的时候，它则退化为维恩公式的原始形式。这就是著名的普朗克黑体公式。普朗克寻找该公式的物理意义。<br>如果要使得新的方程成立，就必须做一个假定：<strong>假设能量在发射和吸收的时候不是连续不断而是分成一份一份的</strong><br>正是这个假定，推翻了自牛顿200多年来曾经被认为是坚固不可摧毁的经典世界。以前一切自然个过程被当做连续不断的，但现在能量不是连续不断的了。能量必须只有有限个可能态，必须有个最小单位。在两个最小单位之间，是能量的禁区，我们永远不会发现，能量的计量会出现小数点以后的数字。<br>1900年普朗克宣读《黑体光谱中的能量分布》，称这个基本单位为“能量子”,后改为“量子”。E=hv(E为单个量子的能量，V是频率，h为普朗克常数)，普朗克常数h、引力常数g和光速c构成我们宇宙最为重要的三个基本物理常数。<br>量子论告诉我们，“无限分割”的概念是一种数学上的理想，而不可能在现实中实现。一切都是不连续的，连续性的美好蓝图也行不过时我们的一种想象。</p>
<h1 id="量子力学"><a href="#量子力学" class="headerlink" title="量子力学"></a>量子力学</h1><h2 id="光电效应"><a href="#光电效应" class="headerlink" title="光电效应"></a>光电效应</h2><p>赫兹证明电磁波的实验引出了“光电效应”<br>光电效应和电磁理论的不协调之处：电磁理论认为，光作为一种波动，它的强度代表了它的能量，而实验证明：光的频率，而不是强度决定它能否从金属表面打出电子来；光的强度而不是频率，则决定打出电子的数目。<br>1905年，爱因斯坦从普朗克的量子假设出发。E=hv，提高频率不正是提高了单个量子的能量吗？而更高能量的量子，不正好打击出更高能量的电子吗？另一方面，提高光的强度，只是增加量子的数量罢了。组成光的能量的这种最小基本单位，称之为光量子。<br>光以量子的形式吸收能量，没有连续性，不能累积。一个光量子发出一个对应的电子。于是实验揭示出的瞬时作用也解决，量子作用本来就是瞬时作用，没有积累的说法。微粒说的一种翻版。</p>
<h2 id="康普顿效应"><a href="#康普顿效应" class="headerlink" title="康普顿效应"></a>康普顿效应</h2><p>康普顿X射线被自由电子散射实验：散射出来的X射线分成两个部分，一部分和原来的入射射线波长相同，另一部分却比原来的射线波长要长，具体的大小和散射角存在函数关系。<br>运用通常的波动理论，散射应该不会改变入射光的波长。于是其引入光量子的假设，光子像普通小球那样，不仅带有能量还具有冲量，当其与电子发生碰撞时，自己的一部分能量交换给电子，有E=hv可知，E下降导致v下降，导致波长变长。实验完全吻合。</p>
<h2 id="原子模型"><a href="#原子模型" class="headerlink" title="原子模型"></a>原子模型</h2><p>卢瑟福实验α粒子轰击极薄的金箔(1910年)<br>1911年修改汤姆逊的原子模型为“行星模型”，负电的电子围绕带正电的原子核。<br>物理学家指出其不稳定，经典的电磁理论预言，这样的体系将会无可避免的释放出辐射能量，电子必将坠毁，导致体系崩溃</p>
<h3 id="玻尔模型"><a href="#玻尔模型" class="headerlink" title="玻尔模型"></a>玻尔模型</h3><p>玻尔面临选择：放弃经典电磁理论，或者放弃卢瑟福原子模型。玻尔选择了前者。(1913年)<br>原子内部只能释放特定量的能量，说明电子只能再特定的“势能位置”之间转换。也就是说，电子必须按照某些“确定的”轨道运行，这些轨道必须符合一定的势能条件，从而使得电子在这些轨道之间跃迁时，只能释放出符合巴尔末公式的能量来。电子只能释放或者吸收特定的能量而不是连续不断的。电子从E1跃迁到E2并不表示电子经过了E1和E2之间的任意状态。<br>玻尔的这些思想，以三篇论文发表，量子物理划时代的文献，即伟大的“三部曲”。<br>玻尔模型是卢瑟福模型的延续，一系列量子化条件被引入。<br>1900年普朗克宣告了量子的诞生，1913年玻尔将一个完整的关于原子的理论体系建立起来，宣告了量子进入青年时代。</p>
<p>1918年玻尔发布“对应原理”，试图与麦氏理论调和，力图证明两种理论都正确，但是有不同的适用范围。导致了其最终的衰败。</p>
<p>玻尔假设，电子只能具有量子化的能级和轨道，但没有说明理由。而且无法解释“反常塞曼效应”，这种现象要求引进值为1/2的量子数。泡利在访问玻尔家时就曾经对玻尔夫人的问好回以暴躁的抱怨：“我当然不好！我不理解‘反常塞曼效应’”。</p>
<p>1925年泡利提出“不相容原理”。他发现没有两个电子能享有相同的状态，同一轨道包容的不同状态，其数目也是有限的，也就是说一个轨道有一定的容量。当电子填满一个轨道后其他电子无法加入到这个轨道中来。解决了电子长期占据外层电子轨道而不会失去能量落到低层轨道上的问题。解决了“反常塞曼效应”的问题</p>
<h2 id="德布罗意波"><a href="#德布罗意波" class="headerlink" title="德布罗意波"></a>德布罗意波</h2><p>在玻尔模型中自然引进一个周期的概念，以符合观测到的现实。原本这个条件是强加在电子上的量子化模式：电子轨道是不连续的。德布罗意准备解释原因。<br>E=mc^2,E=hv。hv=mc^2 电子具有一个内禀的频率，v=mc^2/h。电子以速度v0前进必定伴随一个速度为c^2/v0的波，德布罗意将其称为“相波”，后人称之为德布罗意波。电子也是一种波。这个波的速度比光速还快，但是这种波不能携带能量和信息，因此并不违反相对论。<br>德布罗意是有史以来第一个凭借博士论文就获得诺贝尔奖的人。</p>
<h2 id="海森堡矩阵力学"><a href="#海森堡矩阵力学" class="headerlink" title="海森堡矩阵力学"></a>海森堡矩阵力学</h2><p>对绝对“能级”或者“频率”表示怀疑。单独的能级无法观测，只有“能级差”可以频率表示为两个能级X，Y的函数。使用矩阵推导出量子化的原子能级和辐射频率。不需要像玻尔的旧模型那样，强行加一个不自然的量子条件。<br>1924年，玻恩，海森堡，约尔当发表“三人论文”，《论量子力学I》《论量子力学II》</p>
<h2 id="薛定谔波动力学"><a href="#薛定谔波动力学" class="headerlink" title="薛定谔波动力学"></a>薛定谔波动力学</h2><p>薛定谔情人众多，世界观迥异。<br>薛定谔从经典力学的哈密顿-雅可比方程触发，利用变分法和德布罗意公式，最后求出了一个非相对论的波动方程(1926年)。原子的神秘光谱不再为矩阵力学所专美，它同样可以从波动方程中被自然的推导出来。<br>后薛定谔、泡利、约尔当均证明矩阵力学和波动力学在数学上说是完全等价的，均是从经典的哈密顿函数而来。<br>但是薛定谔定义的Ψ波函数，说这是空间中定义的某种分布，他自己也没见过，不知道其物理意义。</p>
<hr>
<p>2017.8.15更新</p>
<hr>
<h2 id="玻恩的概率解释"><a href="#玻恩的概率解释" class="headerlink" title="玻恩的概率解释"></a>玻恩的概率解释</h2><p>玻恩说这个波函数Ψ里面装的是“骰子”。它代表的是一种随机，一种概率，而决不是薛定谔本人理解的，是电子电荷在空间中的实际分布。玻恩争辩道，Ψ或者更准确的说，Ψ^2代表了电子在某个地点出现的“概率”。电子本身不会像波那样扩展开去，但是它出现的概率则像一个波，严格按照Ψ的分布所展开。</p>
<p>单个电子打到感光屏。激发出一个小点。我们不能预言它组成类波的干涉条纹，因为一个电子只会留下一个点而已，而且出现的位置也不确定。但是只有当成群的电子穿过双缝后才会逐渐组成干涉条纹。<br>规律：电子在某些地方出现的可能性要大一些，在另一些地方则小一些。出现频率高的地方，恰恰是波动所预言的干涉条纹的亮处，出现频率低的地方则对应于暗处。虽然每一个电子的行为是随机的，但是这个随机分布的总的模式是确定的，它就是一个干涉条纹的图案。这就像我们掷骰子，虽然每一个骰子掷下去，它的结果是完全随机的，但是如果大量的骰子到地上，你会发现1-6的结果差不多是平均的。<br>物理不能预测电子的行为，它只能找到电子出现的概率而已。<br>理论上，只要我们了解每一个分子的状态，我们完全可以严格地推断出整个系统的行为，分毫不爽。<strong>可是玻恩的意思是，就算我们把电子的初始状态测量的精确无误，就算我们拥有最强大的计算机可以计算一切环境对电子的影响，即便如此，我们也不能预言电子最后的准确位置。这种不确定不是因为我们的计算能力不足，它是深藏在物理定律本身内部的一种属性。</strong>即使从理论上来说，我们也不能准确地预测大自然。<strong>这已经不是推翻某个理论的问题，这是对整个决定论系统的挑战，而决定论是那时整个科学的基础。量子论要改造整个科学。</strong></p>
<h2 id="海森堡的不确定性原理"><a href="#海森堡的不确定性原理" class="headerlink" title="海森堡的不确定性原理"></a>海森堡的不确定性原理</h2><p>1927年，海森堡由矩阵力学提出不确定性原理又称测不准原理。p×q ≠ q×p,p是动量，q是位置，这不是说先观测动量p，再观测位置q，这和先观测q再观测p，其结果是不一样的吗？除非测量动量p这个动作本身，影响到了q的数值。反之亦如此。这个方程告诉我们同时观测p和q是不可能的吗？理论不但决定了我们能够观察到的东西，它还决定哪些是我们观察不到的东西。关键在测量上，在电子层面上，由于观测时不能忽略光子对它的撞击，为了测量位置，我们剧烈改变了它的动量。我们没法同时即准确地知道一个电子的位置同时又准确的了解它的动量。最后得出：∆p×∆q&gt;h/4π,∆p、∆p分别表示测量误差。∆p非常小，∆q相应地必定变得非常大。<br>后又发现能量E和时间t也满足类似的不确定性规则：∆E×∆t&gt;h。在非常断点一刹那，也就是t非常确定的一瞬间，即使真空也会出现巨大的能量起伏，这种能量完全是靠着不确定性而凭空出现的，它的确违反了能量守恒定律，但是一刹那很短，在人们还没来得及发现以前，它又神秘消失，使得能量守恒在整体上得以维持。<br>在玻尔指导下，其声明不确定性其实同时建筑在连续性和不连续性两者之上。</p>
<h2 id="玻尔的互补原理"><a href="#玻尔的互补原理" class="headerlink" title="玻尔的互补原理"></a>玻尔的互补原理</h2><p>福尔摩斯说：“我的方法，就建立在这样一种假设上面：当你把一切不可能的结论都排除之后，那剩下的，不管多么离奇，也必然是事实。”电子不可能不是个粒子，它也不可能不是波，那剩下的唯一可能性就是：它既是个粒子也是个波。<br>我们每次观察电子，它只展现出其中的一面，这里面关键是我们“如何”观察它，而不是它“究竟”是什么。讨论哪个是“真实”毫无意义。我们唯一能说的是在某种观察方式确定的前提下，它能呈现出什么样子来。但一旦观察方式确定了，电子就要选择一种表现形式，它得作为一个波或者粒子出现，而不能再暧昧的混杂在一起。波和粒子在同一时刻是互斥的，但它们却又在一个更高的层次上统一在一起，作为电子的两面被纳入一个整体概念中，这就是玻尔的“互补原理”。<br>。</p>
<h2 id="量子论与测量"><a href="#量子论与测量" class="headerlink" title="量子论与测量"></a>量子论与测量</h2><p>只有观测手段明确之后，答案才有意义。而脱离了观测手段去讨论这个图案“本质上”到底是什么是无意义的。在量子论中观测者和外部宇宙是结合在一起的，它们之间现在已经没有明确的界限，是一个整体。<br>换言之，不存在一个客观的，绝对的世界。唯一存在的，就是我们能够观测到的世界。物理学的全部一样，不在于它能够揭示出自然“是什么”，而在于它能够明确，关于自然我们能“说什么”。没有一个脱离于观测而存在的“绝对自然”，只有我们和那些复杂的测量关系，熙熙攘攘纵横交错，构成了这个令人心醉的宇宙的全部。测量时新物理学的核心，测量行为创造了整个世界。</p>
<p>“存在，但绝对观测不到”之类的论断都是毫无意义的，因为这和“不存在”根本就是一码事，无法区分开来。</p>
<h2 id="量子论“哥本哈根解释”总结"><a href="#量子论“哥本哈根解释”总结" class="headerlink" title="量子论“哥本哈根解释”总结"></a>量子论“哥本哈根解释”总结</h2><p>玻恩的的概率解释、海森堡的不确定性和互补原理共同构成量子论“哥本哈根解释”的核心，前两者捣毁了经典世界的(严格)因果性，互补原理和不确定性原理有合力摧毁了世界的(绝对)客观性。它们至今仍然影响我们队宇宙的终极认识。<br>首先，不确定性原理限制了我们队微观事物认识的极限，而这个极限也就是具有物理意义的一切。<br>其次，因为存在着观测者对于被观测物的不可避免的扰动，现在主体和客观世界必须被理解成一个不可分割的整体。没有一个孤立地存在于客观世界的“事物”，事实上一个纯粹的客观世界是没有的，任何事物都只有结合一个特定的观测手段，才谈得上具有具体意义。对象所表现出的形态，很大程度上取决于我们的观测方法。对于同一个现象来说，这些表现形态可能是相互排斥的，但必须被同时作用域对这个对象的描述中，也就是互补原理。<br>最后，因为我们的观测给事物带来各种原则上不可预测的扰动，量子世界本质是“随机的”。传统世界严格发因果关系在量子世界是不存在的，必须以一种统计性的解释来取而代之，波函数Ψ就是一种统计，它的平方代表了粒子出现在某处的概率。当我们说“电子出现在x处”时，我们并不知道这个事件的“原因”是什么，它是一个完全随机的过程，没有因果关系。</p>
<h2 id="量子幽灵"><a href="#量子幽灵" class="headerlink" title="量子幽灵"></a>量子幽灵</h2><p>在电子通过双缝前，如果我们不去测量它的位置，那么它的波函数就按照方程发散开去，同时通过两个缝而自我相互干涉。但要是我们试图在两条缝上装个仪器以探测它究竟通过了哪条缝，在那一刹那，电子的波函数便塌缩了，电子随机地选择一个缝通过。而塌缩过的波函数自然就无法再进行干涉，于是乎，干涉条纹一去不复返。</p>
<h2 id="第三次波粒战争"><a href="#第三次波粒战争" class="headerlink" title="第三次波粒战争"></a>第三次波粒战争</h2><p>微粒说：光电效应，康普顿效应，玻色-爱因斯坦统计,矩阵力学<br>波动说：麦克斯韦理论，德布罗意波(电子也是一种波)，波动力学<br>在互补原理、玻恩的的概率解释和海森堡的不确定性提出后，第三次波粒战争以戏剧化结尾收场，两者是不可分割的一个整体，即“波粒二象性”。</p>
<h2 id="玻尔、爱因斯坦之争"><a href="#玻尔、爱因斯坦之争" class="headerlink" title="玻尔、爱因斯坦之争"></a>玻尔、爱因斯坦之争</h2><p>爱因斯坦光箱实验<br>ERP佯谬</p>
<h2 id="薛定谔的猫"><a href="#薛定谔的猫" class="headerlink" title="薛定谔的猫"></a>薛定谔的猫</h2><p>薛定谔想象了一种结构巧妙的精密装置，每当原子衰变而放出一个中子，它就激发一连串的连锁反应，最终结果是打破箱子里的一个毒气瓶，而同时箱子里还有一只猫。若原子衰变，猫就被毒死，反之，猫活着。<br>当它们都被锁在箱子里时，因为我们没有观察，所以原子处在衰变/不衰变的叠加态。因为原子的状态不确定，所以猫的状态也不确定，只有打开箱子才能最终定论。问题是，当我们没有打开箱子之前，这只猫处于什么状态？似乎唯一的可能就是，它和我们的原子一样处在叠加态，这只猫当时陷于死/活的混合。</p>
<h1 id="量子力学延伸"><a href="#量子力学延伸" class="headerlink" title="量子力学延伸"></a>量子力学延伸</h1><h2 id="意识"><a href="#意识" class="headerlink" title="意识"></a>意识</h2><p>为什么机器来测量就得叠加，而人来就得到确定结果呢？难道说，人类意识的参与才是波函数塌缩的原因？只有当电子的随机结果被“意识到”，它才真正地变为现实，从波函数中脱胎而出来到这个世界上。</p>
<h2 id="量子通信"><a href="#量子通信" class="headerlink" title="量子通信"></a>量子通信</h2><p>不可复制原理：传输量子态的同时一定会毁掉原来的那个原本。</p>
<h2 id="延迟实验"><a href="#延迟实验" class="headerlink" title="延迟实验"></a>延迟实验</h2><p>我们何时选择“光子”的模式，对于实验结果无影响。</p>
<p>这说明，宇宙的历史，可以在它已经发生后才决定究竟是怎样发生的！在薛定谔的猫实验里，如果我们设计某种延迟实验，我们就能在实验结束后决定猫是死是活！比如说，原子在一点钟要么衰变毒死猫，要么断开装置使猫存活。但如果有某个延迟装置能够让我们在2点钟来“延迟决定”原子衰变与否，我么就可以在两点钟这个“未来”去实际决定猫在一点钟的死活。</p>
<p>宇宙本身由一个有意识的观测者创造出来也不是什么不可能的事情。虽然宇宙的行为在道理上讲已经演化了一百多亿年，但某种“延迟”使得它直到被一个高级生物所观察才成为确定。我们的观测行为本身参予了宇宙的创造过程！这就是所谓的“参与性宇宙”模型（The Participatory Universe）。宇宙本身没有一个确定的答案，而其中的生物参与了这个谜题答案的构建本身！</p>
<p>这实际上是某种增强版的“人择原理”（anthropic principle）。人择原理是说，我们存在这个事实本身，决定了宇宙的某些性质为什么是这样的而不是那样的。也就是说，我们讨论所有问题的前提是：事实上已经存在了一些像我们这样的智能生物来讨论这些问题。我们回忆一下笛卡儿的“第一原理”：不管我怀疑什么也好，有一点我是不能怀疑的，那就是“我在怀疑”本身，也就是著名的“我思故我在”！类似的原则也适用于人择原理：不管这个宇宙有什么样的性质也好，它必须要使得智能生物可能存在于其中，不然就没有人来问“宇宙为什么是这样的？”这个问题了。随便什么问题也好，你首先得保证有一个“人”来问问题，不然就没有意义了。</p>
<p>缺点：对于观测者无法定义，对于意识无法定义</p>
<h2 id="多世界解释-Many-Worlds-Interpretation-MWI"><a href="#多世界解释-Many-Worlds-Interpretation-MWI" class="headerlink" title="多世界解释(Many Worlds Interpretation,MWI)"></a>多世界解释(Many Worlds Interpretation,MWI)</h2><p>电子即使在观测后仍然处于左/右叠加的,只不过，我们的世界本身也是叠加的一部分！当电子穿过双缝后，处于叠加态的不仅仅是电子，还包括我们整个世界！也就是说，当电子经过双缝后，出现了两个叠加在一起的世界，在其中的一个世界里电子穿过了左边的双缝，而在另一个世界里，电子穿过了右边的双缝！<br>波函数无须“塌缩”，去随机选择左还是右，事实上两种可能都发生了！只不过它表现为整个世界的叠加：生活在一个世界的人在他们那里电子通过左边的狭缝，而在另一个世界中，人们观测到的电子则在右边！<br>我们的宇宙可能是高维空间，真实世界的投影，可能有很多类似的空间。<br>缺点：多世界，我看不到</p>
<h3 id="量子自杀"><a href="#量子自杀" class="headerlink" title="量子自杀"></a>量子自杀</h3><p>这就是从量子自杀思想实验推出的怪论，美其名曰“量子永生”（quantumimmortality）。只要从主观视角来看，不但一个人永远无法完成自杀，事实上他一旦开始存在，就永远不会消失！总存在着一些量子效应，使得一个人不会衰老，而按照MWI，这些非常低的概率总是对应于某个实际的世界！如果多宇宙理论是正确的，那么我们得到的推论是：一旦一个“意识”开始存在，从它自身的角度来看，它就必定永生！（天哪，我们怎么又扯到了“意识”！）。这是最强版本的人择原理，也称为“终极人择原理</p>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="量子计算机"><a href="#量子计算机" class="headerlink" title="量子计算机"></a>量子计算机</h3><p>一个bit表示0,1的叠加，处理10位bit,处理的是2^10个这样的数。做的不能比图灵计算机多，但是速度更快。<br>基于大数分解的加密算法会失效。</p>
<h3 id="量子加密"><a href="#量子加密" class="headerlink" title="量子加密"></a>量子加密</h3><h2 id="隐变量理论"><a href="#隐变量理论" class="headerlink" title="隐变量理论"></a>隐变量理论</h2><p>如果你试图去测量一个电子的具体位置的话，你的测量仪器将首先与它的量子势发生作用，这将使电子本身发生微妙的变化，这些变化是不可预测的，因为主宰它们的是一些“隐变量”，你无法直接探测到它们。<br>恢复了实在性却放弃了定域性。</p>
<h2 id="贝尔不等式"><a href="#贝尔不等式" class="headerlink" title="贝尔不等式"></a>贝尔不等式</h2><p>如果世界的本质是经典的，具体的说，如果我们的世界同时满足：</p>
<ol>
<li>定域的，也就是没有超光速的信号传播</li>
<li>实在的，也就是说，存在一个独立于我们观察的外部世界</li>
</ol>
<p>那么我们任意去三个方向观察A、B的自旋，他们所表现的协作程度必定要受限于贝尔不等式之内<br>但在量子论中，贝尔不等式可以被突破(1964年)，实验证明该不等式被突破，世界不是经典的，爱因斯坦输了(1982)。</p>
<p>阿斯派克特实验之后，我们必须说服自己相信这样一件事情： 定域的隐变量理论是不存在的！ 换句话说，我们的世界不可能如同爱因斯坦所梦想的那样，既是定域的（没有超光速信号的传播），又是实在的（存在一个客观确定的世界，可以为隐变量所描述）。定域实在性（local realism）从我们的宇宙中被实验排除了出去，现在我们必须作出艰难的选择：要么放弃定域性，要么放弃实在性。</p>
<p>如果我们放弃实在性，那就回到量子论的老路上来，承认在我们观测之前，两个粒子不存在于“客观实在”之内。它们不具有通常意义上的物理属性（如自旋），只有当观测了以后，这种属性才变得有意义。这样一来牢固可靠的世界就崩塌了。</p>
<p>这样一来就必须放弃定域性。我们仍然有可能建立一个隐变量理论，如果容忍某种超光速的信号在其体系中来回，则它还是可以很好地说明我们观测到的一切。比如在EPR中，天际两头的两个电子仍然可以通过一种超光速的瞬时通信来确保它们之间进行成功的合作。事实上，玻姆的体系就很好地在阿斯派克特实验之后仍然存活着，因为他的“量子势”的确暗含着这样的超距作用。 可是要是这样的话，我们也许并不会觉得日子好过多少！超光速的信号？老大，那意味着什么？想一想爱因斯坦对此会怎么说吧，超光速意味着获得了回到过去的能力！</p>
<p>其实我们的史话一早已经讨论过，德布罗意那“相波”的速度c<sup>2</sup>/v就比光速要快，但只要不携带能量和信息，它就不违背相对论。</p>
<h2 id="超弦理论，M理论"><a href="#超弦理论，M理论" class="headerlink" title="超弦理论，M理论"></a>超弦理论，M理论</h2><p>时空变成11维<br>其他维度的扰动造成全部的量子不确定性</p>
<h1 id="对待科学的态度"><a href="#对待科学的态度" class="headerlink" title="对待科学的态度"></a>对待科学的态度</h1><p>事实上，我们对待科学的态度是，只要一个理论能够被证明为“错”但还未被证明“错”，我们就暂时接受它为可靠正确的。不过它必须随时积极地面对证伪，这也就是为什么科学总是在自我否定中不断完善。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;2017.8.5开始读，2017.8.12日读完&lt;br&gt;这是一本关于量子力学的历史的科普性著作&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;2017.8.14更新&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;经典物理的黄金时代&quot;&gt;&lt;a href=&quot;#经典物理的黄金时代&quot; class=&quot;headerlink&quot; title=&quot;经典物理的黄金时代&quot;&gt;&lt;/a&gt;经典物理的黄金时代&lt;/h1&gt;&lt;h2 id=&quot;光的本质&quot;&gt;&lt;a href=&quot;#光的本质&quot; class=&quot;headerlink&quot; title=&quot;光的本质&quot;&gt;&lt;/a&gt;光的本质&lt;/h2&gt;&lt;p&gt;波动说和粒子说&lt;/p&gt;
&lt;h2 id=&quot;波动粒子之争&quot;&gt;&lt;a href=&quot;#波动粒子之争&quot; class=&quot;headerlink&quot; title=&quot;波动粒子之争&quot;&gt;&lt;/a&gt;波动粒子之争&lt;/h2&gt;&lt;h3 id=&quot;第一次波粒战争&quot;&gt;&lt;a href=&quot;#第一次波粒战争&quot; class=&quot;headerlink&quot; title=&quot;第一次波粒战争&quot;&gt;&lt;/a&gt;第一次波粒战争&lt;/h3&gt;&lt;p&gt;主要参与人物：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;粒子说：牛顿&lt;ul&gt;
&lt;li&gt;《光学》，色散，牛顿环(明暗条纹)，衍射&lt;/li&gt;
&lt;li&gt;质疑如果光是波，为什么无法像声音那样绕开障碍物前进？&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;波动说：胡克(光是一种纵波)，惠更斯&lt;br&gt;第一次交锋以牛顿为首的微粒说战胜了波动说&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;第二次波粒战争&quot;&gt;&lt;a href=&quot;#第二次波粒战争&quot; class=&quot;headerlink&quot; title=&quot;第二次波粒战争&quot;&gt;&lt;/a&gt;第二次波粒战争&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;波的干涉&lt;br&gt; 托马斯.杨: 波的双缝干涉实验(1807年)&lt;br&gt; 波的叠加与抵消&lt;/li&gt;
&lt;li&gt;决定性事件(1819年)&lt;br&gt; 菲涅尔: 采用光是一种波动的观点，用严密的数学推理解释了光的衍射&lt;br&gt; 该理论用于圆盘衍射为一个亮斑，泊松质疑，阿拉果坚持实验检测，完美证明，后被误称为“泊松亮斑”&lt;/li&gt;
&lt;li&gt;光的偏振&lt;br&gt; 菲涅尔提出光是一种横波，而不是纵波，成功解析了偏振现象(1821年)&lt;/li&gt;
&lt;li&gt;光速&lt;br&gt; 傅科：“傅科摆”(1850年)&lt;br&gt; 测量光在真空和水中的速度，后者为前者的3/4&lt;/li&gt;
&lt;li&gt;电磁理论&lt;br&gt; 麦克斯韦发表电磁理论的论文，预言光是电磁波的一种(1861年)&lt;br&gt; 赫兹实验证明了麦克斯韦电磁理论(1887年)&lt;br&gt; 麦氏方程在数学上完美得难以置信，科学美的典范&lt;br&gt;至此，波动的光辉达到顶点
    
    </summary>
    
      <category term="读书笔记" scheme="http://happylg.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书" scheme="http://happylg.cn/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>动态规划</title>
    <link href="http://happylg.cn/2017/08/13/dynamic-programming/"/>
    <id>http://happylg.cn/2017/08/13/dynamic-programming/</id>
    <published>2017-08-13T06:03:14.000Z</published>
    <updated>2017-08-19T06:37:33.833Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>2017.08.17更新</p>
<hr>
<h1 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h1><h2 id="01背包"><a href="#01背包" class="headerlink" title="01背包"></a>01背包</h2><h3 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h3><p><code>dp[i][j]</code>表示前i个物品装到剩余容量为j时的最大价值</p>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p><code>dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i - 1]] + value[i - 1])</code><br>第<code>i</code>个物品装或者不装入背包，不装价值为<code>dp[i-1][j]</code>,装表示剩下<code>i-1</code>个物品装入<code>j-weight[i-1]</code>重的最大价值，加上<code>value[i-1]</code><br>注意讨论前<code>i</code>个物品装入背包的时候， 其实是在考查第<code>i-1</code>个物品装不装入背包（因为物品是从0开始编号的）<br><a id="more"></a></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">public class Pack_01 &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">//		int n = 5;// 物品个数</div><div class="line">//		int[] value = &#123; 48, 40, 12, 8, 7 &#125;;// 物品价值</div><div class="line">//		int[] weight = &#123; 6, 5, 2, 1, 1 &#125;;// 物品重量</div><div class="line">//		int capacity = 8;// 背包容量</div><div class="line"></div><div class="line">		int n = 4;</div><div class="line">		int[] value = &#123; 10, 40, 30, 50 &#125;;</div><div class="line">		int[] weight = &#123; 5, 4, 6, 3 &#125;;</div><div class="line">		int capacity = 12;</div><div class="line">		int res = pack_01(n, capacity, weight, value);</div><div class="line">		System.out.println(res);</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static int pack_01(int n, int capacity, int[] weight, int[] value) &#123;</div><div class="line">		int[][] dp = new int[n + 1][capacity + 1];</div><div class="line">		for (int i = 1; i &lt; dp.length; i++) &#123;//</div><div class="line">			for (int j = 1; j &lt; dp[0].length; j++) &#123;</div><div class="line">				if (j &gt;= weight[i - 1]) &#123;</div><div class="line">					dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i - 1]] + value[i - 1]);</div><div class="line">				&#125; else &#123;</div><div class="line">					dp[i][j] = dp[i - 1][j];// i只与i-1有关</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return dp[n][capacity];</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><h3 id="状态-1"><a href="#状态-1" class="headerlink" title="状态"></a>状态</h3><p><code>dp[i][j]</code>表示前i个物品装到剩余容量为j时的最大价值</p>
<h3 id="状态转移方程-1"><a href="#状态转移方程-1" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p><code>dp[i][j] = max(dp[i - 1][j - num * weight[i - 1]] + num * value[i - 1]) (0&lt;=num * weight[i - 1]&lt;=j)</code></p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">public class Pack_full &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		int n = 5;// 物品个数</div><div class="line">		int[] value = &#123; 48, 40, 12, 8, 7 &#125;;// 物品价值</div><div class="line">		int[] weight = &#123; 6, 5, 2, 1, 1 &#125;;// 物品重量</div><div class="line">		int capacity = 8;// 背包容量</div><div class="line"></div><div class="line">		// int n = 4;</div><div class="line">		// int[] value = &#123; 10, 5, 30, 40 &#125;;</div><div class="line">		// int[] weight = &#123; 5, 4, 6, 3 &#125;;</div><div class="line">		// int capacity = 12;</div><div class="line">		int res = pack_full(n, capacity, weight, value);</div><div class="line">		System.out.println(res);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static int pack_full(int n, int capacity, int[] weight, int[] value) &#123;</div><div class="line">		int[][] dp = new int[n + 1][capacity + 1];</div><div class="line">		for (int i = 1; i &lt; dp.length; i++) &#123;</div><div class="line">			for (int j = 1; j &lt; dp[0].length; j++) &#123;</div><div class="line">				for (int num = 0; j &gt;= num * weight[i - 1]; num++) &#123;</div><div class="line">					dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - num * weight[i - 1]] + num * value[i - 1]);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return dp[n][capacity];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<p>2017.08.18更新</p>
<hr>
<h2 id="硬币找零-方案数"><a href="#硬币找零-方案数" class="headerlink" title="硬币找零(方案数)"></a>硬币找零(方案数)</h2><h3 id="状态-2"><a href="#状态-2" class="headerlink" title="状态"></a>状态</h3><p><code>dp[i][j</code>]表示使用<code>changes[0-i]</code>硬币兑换<code>j</code>元的方法总数</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>使用i=0的钱币兑换，只有changes[0]的整数倍的金额才能有1种方法<br><code>dp[0][j * changes[0]] = 1</code></p>
<h3 id="状态转移方程-2"><a href="#状态转移方程-2" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>不装入第i种钱币，即使用0~i-1种钱币组成j的方法数；装入i钱币，使用0~i的钱币组成j-changes[i]金额的方法数<br><code>dp[i][j] = dp[i - 1][j] +  dp[i][j - changes[i]]</code></p>
<h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">//链接：https://www.nowcoder.com/questionTerminal/185dc37412de446bbfff6bd21e4356ec</div><div class="line">//来源：牛客网</div><div class="line">//</div><div class="line">//有一个数组changes，changes中所有的值都为正数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，对于一个给定值x，请设计一个高效算法，计算组成这个值的方案数。</div><div class="line">//给定一个int数组changes，代表所以零钱，同时给定它的大小n，另外给定一个正整数x，请返回组成x的方案数，保证n小于等于100且x小于等于10000。</div><div class="line">//测试样例：</div><div class="line">//[5,10,25,1],4,15</div><div class="line">//返回：</div><div class="line">//6</div><div class="line"></div><div class="line">public class ChangeMoney &#123;</div><div class="line"></div><div class="line">	public static void main(String[] args) &#123;</div><div class="line">		// TODO Auto-generated method stub</div><div class="line">		int[] changes = &#123; 5, 10, 25, 1 &#125;;</div><div class="line">		int n = 4;</div><div class="line">		int money = 15;</div><div class="line">		int res = change(changes, n, money);</div><div class="line">		System.out.println(res);</div><div class="line"></div><div class="line">	&#125;</div><div class="line"></div><div class="line">	public static int change(int[] changes, int n, int money) &#123;</div><div class="line">		int[][] dp = new int[n][money + 1];// dp[i][j]表示使用changes[0-i]硬币兑换j元的方法总数。</div><div class="line">		for (int i = 0; i &lt; n; i++) &#123; // j=0表示钱为0，组成0元的方法数为1</div><div class="line">			dp[i][0] = 1;</div><div class="line">		&#125;</div><div class="line">		for (int j = 0; j * changes[0] &lt; money + 1; j++) &#123;// 使用i=0的钱币兑换，只有changes[0]的整数倍的金额才能有1种方法</div><div class="line">			dp[0][j * changes[0]] = 1;</div><div class="line">		&#125;</div><div class="line">		// 填表</div><div class="line">		for (int i = 1; i &lt; dp.length; i++) &#123;// 数组长度1~n-1在changes数组中有效</div><div class="line">			for (int j = 1; j &lt; dp[0].length; j++) &#123;</div><div class="line">				// 不装入第i种钱币，即使用0~i-1种钱币组成j的方法数；装入i钱币，使用0~i的钱币组成j-changes[i]金额的方法数</div><div class="line">				dp[i][j] = dp[i - 1][j] + (j - changes[i] &gt;= 0 ? dp[i][j - changes[i]] : 0);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return dp[n - 1][money];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="硬币找零-最少硬币数"><a href="#硬币找零-最少硬币数" class="headerlink" title="硬币找零(最少硬币数)"></a>硬币找零(最少硬币数)</h2><h2 id="多重背包"><a href="#多重背包" class="headerlink" title="多重背包"></a>多重背包</h2><h2 id="最长子序列"><a href="#最长子序列" class="headerlink" title="最长子序列"></a>最长子序列</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="http://love-oriented.com/pack/" target="_blank" rel="external">背包问题九讲</a></li>
<li><a href="http://www.hawstein.com/posts/dp-knapsack.html" target="_blank" rel="external">动态规划之背包问题</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;2017.08.17更新&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;背包问题&quot;&gt;&lt;a href=&quot;#背包问题&quot; class=&quot;headerlink&quot; title=&quot;背包问题&quot;&gt;&lt;/a&gt;背包问题&lt;/h1&gt;&lt;h2 id=&quot;01背包&quot;&gt;&lt;a href=&quot;#01背包&quot; class=&quot;headerlink&quot; title=&quot;01背包&quot;&gt;&lt;/a&gt;01背包&lt;/h2&gt;&lt;h3 id=&quot;状态&quot;&gt;&lt;a href=&quot;#状态&quot; class=&quot;headerlink&quot; title=&quot;状态&quot;&gt;&lt;/a&gt;状态&lt;/h3&gt;&lt;p&gt;&lt;code&gt;dp[i][j]&lt;/code&gt;表示前i个物品装到剩余容量为j时的最大价值&lt;/p&gt;
&lt;h3 id=&quot;状态转移方程&quot;&gt;&lt;a href=&quot;#状态转移方程&quot; class=&quot;headerlink&quot; title=&quot;状态转移方程&quot;&gt;&lt;/a&gt;状态转移方程&lt;/h3&gt;&lt;p&gt;&lt;code&gt;dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i - 1]] + value[i - 1])&lt;/code&gt;&lt;br&gt;第&lt;code&gt;i&lt;/code&gt;个物品装或者不装入背包，不装价值为&lt;code&gt;dp[i-1][j]&lt;/code&gt;,装表示剩下&lt;code&gt;i-1&lt;/code&gt;个物品装入&lt;code&gt;j-weight[i-1]&lt;/code&gt;重的最大价值，加上&lt;code&gt;value[i-1]&lt;/code&gt;&lt;br&gt;注意讨论前&lt;code&gt;i&lt;/code&gt;个物品装入背包的时候， 其实是在考查第&lt;code&gt;i-1&lt;/code&gt;个物品装不装入背包（因为物品是从0开始编号的）&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://happylg.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://happylg.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript Puzzlers解析</title>
    <link href="http://happylg.cn/2017/08/12/js-puzzlers/"/>
    <id>http://happylg.cn/2017/08/12/js-puzzlers/</id>
    <published>2017-08-12T13:22:18.000Z</published>
    <updated>2017-08-19T06:37:33.877Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://javascript-puzzlers.herokuapp.com/" target="_blank" rel="external">JavaScript Puzzlers!</a>，题目基于ECMA 262 (5.1)的浏览器环境</p>
<hr>
<p>2017.08.15更新</p>
<hr>
<h3 id="1-What-is-the-result-of-this-expression-or-multiple-ones"><a href="#1-What-is-the-result-of-this-expression-or-multiple-ones" class="headerlink" title="1.What is the result of this expression? (or multiple ones)"></a>1.What is the result of this expression? (or multiple ones)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt)</div><div class="line">        </div><div class="line">A.[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]</div><div class="line">B.[1, 2, 3]</div><div class="line">C.[0, 1, 2]</div><div class="line">D.other</div></pre></td></tr></table></figure>
<p>考察<code>map</code>和<code>parseInt</code><br><code>Array.prototype.map()</code>接收三个参数<code>(element,index,Array)</code><br><code>parseInt()</code>接收两个参数<code>(val,radix)</code>,<code>radix</code>为基数，<code>parseInt(&#39;17&#39;,8) //15</code>,<code>radix</code>为0或无表示以10为基数。每个位上的数字不能比基数大，否则返回<code>NaN</code>,<code>radix</code>不能为1,范围为2-36。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">parseInt(&apos;1&apos;,0)//1</div><div class="line">parseInt(&apos;2&apos;,1)//每个位上的数字不能比基数大，且基数不能为1,返回NaN</div><div class="line">parseInt(&apos;3&apos;,2)//每个位上的数字不能比基数大,返回NaN</div></pre></td></tr></table></figure></p>
<p>所以选D<br><a id="more"></a></p>
<h3 id="2-What-is-the-result-of-this-expression-or-multiple-ones"><a href="#2-What-is-the-result-of-this-expression-or-multiple-ones" class="headerlink" title="2.What is the result of this expression? (or multiple ones)"></a>2.What is the result of this expression? (or multiple ones)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[typeof null, null instanceof Object]</div><div class="line">        </div><div class="line">A.[&quot;object&quot;, false]</div><div class="line">B.[null, false]</div><div class="line">C.[&quot;object&quot;, true]</div><div class="line">D.other</div></pre></td></tr></table></figure>
<p>考察<code>typeof</code>和<code>instanceof</code><br><code>typeof</code>检测非基本对象时，均返回<code>object</code><br><code>null</code>为基本类型，所以<code>null instanceof Object // false</code><br>选A</p>
<h3 id="3-What-is-the-result-of-this-expression-or-multiple-ones"><a href="#3-What-is-the-result-of-this-expression-or-multiple-ones" class="headerlink" title="3.What is the result of this expression? (or multiple ones)"></a>3.What is the result of this expression? (or multiple ones)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[ [3,2,1].reduce(Math.pow), [].reduce(Math.pow) ]</div><div class="line">        </div><div class="line">A.an error</div><div class="line">B.[9, 0]</div><div class="line">C.[9, NaN]</div><div class="line">D.[9, undefined]</div></pre></td></tr></table></figure>
<p>考察<code>reduce</code>函数的用法<br><code>Array.prototype.reduce()</code>接收两个参数<code>(function(accumulator, currentValue, currentIndex, array), initialValue)</code>空数组调用<code>reduce</code>时没有设置初始值将会报错。<br>所以选A</p>
<h3 id="4-What-is-the-result-of-this-expression-or-multiple-ones"><a href="#4-What-is-the-result-of-this-expression-or-multiple-ones" class="headerlink" title="4.What is the result of this expression? (or multiple ones)"></a>4.What is the result of this expression? (or multiple ones)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var val = &apos;smtg&apos;;</div><div class="line">console.log(&apos;Value is &apos; + (val === &apos;smtg&apos;) ? &apos;Something&apos; : &apos;Nothing&apos;);</div><div class="line">        </div><div class="line">A.Value is Something</div><div class="line">B.Value is Nothing</div><div class="line">C.NaN</div><div class="line">D.other</div></pre></td></tr></table></figure>
<p>考察运算符优先级，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" target="_blank" rel="external">MDN运算符优先级表</a><br>+(13级)优先级大于？(3级),所以<code>&#39;Value is &#39; + (val === &#39;smtg&#39;)</code>条件判断为<code>true</code>，答案为<code>&#39;Something&#39;</code>,选D</p>
<h3 id="5-What-is-the-result-of-this-expression-or-multiple-ones"><a href="#5-What-is-the-result-of-this-expression-or-multiple-ones" class="headerlink" title="5.What is the result of this expression? (or multiple ones)"></a>5.What is the result of this expression? (or multiple ones)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var name = &apos;World!&apos;;</div><div class="line">(function () &#123;</div><div class="line">    if (typeof name === &apos;undefined&apos;) &#123;</div><div class="line">        var name = &apos;Jack&apos;;</div><div class="line">        console.log(&apos;Goodbye &apos; + name);</div><div class="line">    &#125; else &#123;</div><div class="line">        console.log(&apos;Hello &apos; + name);</div><div class="line">    &#125;</div><div class="line">&#125;)();</div><div class="line">        </div><div class="line">A.Goodbye Jack</div><div class="line">B.Hello Jack</div><div class="line">C.Hello undefined</div><div class="line">D.Hello World</div></pre></td></tr></table></figure>
<p>考察<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/var" target="_blank" rel="external">变量声明提升</a>（var hoisting）<br>由于变量声明（以及其他声明）总是在任意代码执行之前处理的，所以在代码中的任意位置声明变量总是等效于在代码开头声明。这意味着变量可以在声明之前使用，这个行为叫做“hoisting”。“hoisting”就像是把所有的变量声明移动到函数或者全局代码的开头位置。<br>所以选A</p>
<h3 id="6-What-is-the-result-of-this-expression-or-multiple-ones"><a href="#6-What-is-the-result-of-this-expression-or-multiple-ones" class="headerlink" title="6.What is the result of this expression? (or multiple ones)"></a>6.What is the result of this expression? (or multiple ones)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var END = Math.pow(2, 53);</div><div class="line">var START = END - 100;</div><div class="line">var count = 0;</div><div class="line">for (var i = START; i &lt;= END; i++) &#123;</div><div class="line">    count++;</div><div class="line">&#125;</div><div class="line">console.log(count);</div><div class="line">        </div><div class="line">A.0</div><div class="line">B.100</div><div class="line">C.101</div><div class="line">D.other</div></pre></td></tr></table></figure>
<p>考察JavaScript中的安全整数范围<br><code>Number.MIN_SAFE_INTEGER</code>代表在JavaScript中最小的安全的<code>integer</code>型数字<code>-(2^53 - 1)</code>.<br><code>Number.MAX_SAFE_INTEGER</code>代表在JavaScript中最大的安全整数<code>(2^53 - 1)</code>。<br>这个数字形成的原因是，Javascript 使用 IEEE 754 中规定的<code>double-precision floating-point format numbers</code>，在这个规定中能安全的表示数字的范围在<code>-(2^53 - 1)</code>到<code>2^53 - 1</code>之间，包含<code>-(2^53 - 1)</code>和<code>2^53 - 1</code>。<br>2^53+1 与 2^53超过安全整数范围，<code>2^53+1 == 2^53//true</code>,所以为无限循环，选D</p>
<h3 id="7-What-is-the-result-of-this-expression-or-multiple-ones"><a href="#7-What-is-the-result-of-this-expression-or-multiple-ones" class="headerlink" title="7.What is the result of this expression? (or multiple ones)"></a>7.What is the result of this expression? (or multiple ones)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var ary = [0,1,2];</div><div class="line">ary[10] = 10;</div><div class="line">ary.filter(function(x) &#123; return x === undefined;&#125;);</div><div class="line">        </div><div class="line">A.[undefined × 7]</div><div class="line">B.[0, 1, 2, 10]</div><div class="line">C.[]</div><div class="line">D.[undefined]</div></pre></td></tr></table></figure>
<p>考察<code>filter</code>函数<br><code>filter</code>函数中<code>callback</code>只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用。<br>所以选C</p>
<h3 id="8-What-is-the-result-of-this-expression-or-multiple-ones"><a href="#8-What-is-the-result-of-this-expression-or-multiple-ones" class="headerlink" title="8.What is the result of this expression? (or multiple ones)"></a>8.What is the result of this expression? (or multiple ones)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var two   = 0.2</div><div class="line">var one   = 0.1</div><div class="line">var eight = 0.8</div><div class="line">var six   = 0.6</div><div class="line">[two - one == one, eight - six == two]</div><div class="line">        </div><div class="line">A.[true, true]</div><div class="line">B.[false, false]</div><div class="line">C.[true, false]</div><div class="line">D.other</div></pre></td></tr></table></figure>
<p>考察js大数和浮点数精度丢失的问题<br>计算机的二进制实现和位数限制有些数无法有限表示。就像一些无理数不能有限表示，如 圆周率 3.1415926…，1.3333… 等。JS 遵循 IEEE 754 规范，采用双精度存储（double precision），占用 64 bit。<br>解决方案：<br>对于整数，前端出现问题的几率可能比较低，毕竟很少有业务需要需要用到超大整数，只要运算结果不超过 Math.pow(2, 53) 就不会丢失精度。<br>对于小数，前端出现问题的几率还是很多的，尤其在一些电商网站涉及到金额等数据。解决方式：把小数放到位整数（乘倍数），再缩小回原来倍数（除倍数）<br>选择C，没有道理，时而准确时而不准，忧伤</p>
<h3 id="9-What-is-the-result-of-this-expression-or-multiple-ones"><a href="#9-What-is-the-result-of-this-expression-or-multiple-ones" class="headerlink" title="9.What is the result of this expression? (or multiple ones)"></a>9.What is the result of this expression? (or multiple ones)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function showCase(value) &#123;</div><div class="line">    switch(value) &#123;</div><div class="line">    case &apos;A&apos;:</div><div class="line">        console.log(&apos;Case A&apos;);</div><div class="line">        break;</div><div class="line">    case &apos;B&apos;:</div><div class="line">        console.log(&apos;Case B&apos;);</div><div class="line">        break;</div><div class="line">    case undefined:</div><div class="line">        console.log(&apos;undefined&apos;);</div><div class="line">        break;</div><div class="line">    default:</div><div class="line">        console.log(&apos;Do not know!&apos;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">showCase(new String(&apos;A&apos;));</div><div class="line">        </div><div class="line">A.Case A</div><div class="line">B.Case B</div><div class="line">C.Do not know!</div><div class="line">D.undefined</div></pre></td></tr></table></figure>
<p>考察<code>switch()</code>和判等<br><code>switch()</code>使用<code>===</code>判等，而<code>new String(&#39;A&#39;)!==&#39;A&#39;</code>,所以选C</p>
<h3 id="10-What-is-the-result-of-this-expression-or-multiple-ones"><a href="#10-What-is-the-result-of-this-expression-or-multiple-ones" class="headerlink" title="10.What is the result of this expression? (or multiple ones)"></a>10.What is the result of this expression? (or multiple ones)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function showCase2(value) &#123;</div><div class="line">    switch(value) &#123;</div><div class="line">    case &apos;A&apos;:</div><div class="line">        console.log(&apos;Case A&apos;);</div><div class="line">        break;</div><div class="line">    case &apos;B&apos;:</div><div class="line">        console.log(&apos;Case B&apos;);</div><div class="line">        break;</div><div class="line">    case undefined:</div><div class="line">        console.log(&apos;undefined&apos;);</div><div class="line">        break;</div><div class="line">    default:</div><div class="line">        console.log(&apos;Do not know!&apos;);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">showCase2(String(&apos;A&apos;));</div><div class="line">        </div><div class="line">A.Case A</div><div class="line">B.Case B</div><div class="line">C.Do not know!</div><div class="line">D.undefined</div></pre></td></tr></table></figure>
<p>考察<code>String()</code>方法和判等<br><code>String(&#39;A&#39;)</code>没有新建一个对象，而是返回一个<code>String</code>，所以选A</p>
<hr>
<p>2017.08.16更新</p>
<hr>
<h3 id="11-What-is-the-result-of-this-expression-or-multiple-ones"><a href="#11-What-is-the-result-of-this-expression-or-multiple-ones" class="headerlink" title="11.What is the result of this expression? (or multiple ones)"></a>11.What is the result of this expression? (or multiple ones)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function isOdd(num) &#123;</div><div class="line">    return num % 2 == 1;</div><div class="line">&#125;</div><div class="line">function isEven(num) &#123;</div><div class="line">    return num % 2 == 0;</div><div class="line">&#125;</div><div class="line">function isSane(num) &#123;</div><div class="line">    return isEven(num) || isOdd(num);</div><div class="line">&#125;</div><div class="line">var values = [7, 4, &apos;13&apos;, -9, Infinity];</div><div class="line">values.map(isSane);</div><div class="line"></div><div class="line">A.[true, true, true, true, true]</div><div class="line">B.[true, true, true, true, false]</div><div class="line">C.[true, true, true, false, false]</div><div class="line">D.[true, true, false, false, false]</div></pre></td></tr></table></figure>
<p>考察取余操作符<br>取余操作符保证符号，所以<code>-9 % 2 == -1 ，Infinity % 2 == NaN</code><br>所以选C</p>
<h3 id="12-What-is-the-result-of-this-expression-or-multiple-ones"><a href="#12-What-is-the-result-of-this-expression-or-multiple-ones" class="headerlink" title="12.What is the result of this expression? (or multiple ones)"></a>12.What is the result of this expression? (or multiple ones)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">parseInt(3, 8)</div><div class="line">parseInt(3, 2)</div><div class="line">parseInt(3, 0)</div><div class="line">        </div><div class="line">A.3, 3, 3</div><div class="line">B.3, 3, NaN</div><div class="line">C.3, NaN, NaN</div><div class="line">D.other</div></pre></td></tr></table></figure>
<p>考察<code>parseInt()</code>函数，分析见第1题，答案应该为<code>3,NaN,3</code> 所以选D</p>
<h3 id="13-What-is-the-result-of-this-expression-or-multiple-ones"><a href="#13-What-is-the-result-of-this-expression-or-multiple-ones" class="headerlink" title="13.What is the result of this expression? (or multiple ones)"></a>13.What is the result of this expression? (or multiple ones)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Array.isArray( Array.prototype )</div><div class="line">        </div><div class="line">A.true</div><div class="line">B.false</div><div class="line">C.error</div><div class="line">D.other</div></pre></td></tr></table></figure>
<p>考察<code>Array.prototype</code>，是数组，所以选A</p>
<h3 id="14-What-is-the-result-of-this-expression-or-multiple-ones"><a href="#14-What-is-the-result-of-this-expression-or-multiple-ones" class="headerlink" title="14.What is the result of this expression? (or multiple ones)"></a>14.What is the result of this expression? (or multiple ones)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var a = [0];</div><div class="line">if ([0]) &#123;</div><div class="line">  console.log(a == true);</div><div class="line">&#125; else &#123;</div><div class="line">  console.log(&quot;wut&quot;);</div><div class="line">&#125;</div><div class="line">        </div><div class="line">A.true</div><div class="line">B.false</div><div class="line">C.&quot;wut&quot;</div><div class="line">D.other</div></pre></td></tr></table></figure>
<p>考察<code>if()</code>和判等,见<a href="http://happylg.cn/2017/08/04/js-equal/">js相等性比较</a><br><code>if([])</code>都会执行，所以<code>if([0])</code>更会执行，对象和布尔值比较，布尔值转换为数字，对象转换为原始值比较,<code>[0] == true // false</code><br>所以选B</p>
<h3 id="15-What-is-the-result-of-this-expression-or-multiple-ones"><a href="#15-What-is-the-result-of-this-expression-or-multiple-ones" class="headerlink" title="15.What is the result of this expression? (or multiple ones)"></a>15.What is the result of this expression? (or multiple ones)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[]==[]</div><div class="line">        </div><div class="line">A.true</div><div class="line">B.false</div><div class="line">C.error</div><div class="line">D.other</div></pre></td></tr></table></figure>
<p>考察相等性比较，见<a href="http://happylg.cn/2017/08/04/js-equal/">js相等性比较</a><br>对象和对象比较，引用相同返回<code>true</code>,否则返回<code>false</code>,所以选B</p>
<h3 id="16-What-is-the-result-of-this-expression-or-multiple-ones"><a href="#16-What-is-the-result-of-this-expression-or-multiple-ones" class="headerlink" title="16.What is the result of this expression? (or multiple ones)"></a>16.What is the result of this expression? (or multiple ones)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&apos;5&apos; + 3</div><div class="line">&apos;5&apos; - 3</div><div class="line">   </div><div class="line">A.&quot;53&quot;, 2</div><div class="line">B.8, 2</div><div class="line">C.error</div><div class="line">D.other</div></pre></td></tr></table></figure>
<p>考察<code>+</code>,<code>-</code>运算符,字符串会使用<code>+</code>运算符做连接，但是遇到<code>-</code>则转换为数值进行运算<br>所以选A </p>
<h3 id="17-What-is-the-result-of-this-expression-or-multiple-ones"><a href="#17-What-is-the-result-of-this-expression-or-multiple-ones" class="headerlink" title="17.What is the result of this expression? (or multiple ones)"></a>17.What is the result of this expression? (or multiple ones)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">1 + - + + + - + 1</div><div class="line">        </div><div class="line">A.2</div><div class="line">B.1</div><div class="line">C.error</div><div class="line">D.other</div></pre></td></tr></table></figure>
<p>考察一元<code>+, -</code><br>中间一元加号不影响，两个一元减号负负得正变加号,所以选A</p>
<h3 id="18-What-is-the-result-of-this-expression-or-multiple-ones"><a href="#18-What-is-the-result-of-this-expression-or-multiple-ones" class="headerlink" title="18.What is the result of this expression? (or multiple ones)"></a>18.What is the result of this expression? (or multiple ones)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var ary = Array(3);</div><div class="line">ary[0]=2</div><div class="line">ary.map(function(elem) &#123; return &apos;1&apos;; &#125;);</div><div class="line">        </div><div class="line">A.[2, 1, 1]</div><div class="line">B.[&quot;1&quot;, &quot;1&quot;, &quot;1&quot;]</div><div class="line">C.[2, &quot;1&quot;, &quot;1&quot;]</div><div class="line">D.other</div></pre></td></tr></table></figure>
<p>考察<code>map</code>函数<br>删除或未赋值的元素不会被遍历到，所以选D</p>
<h3 id="19-What-is-the-result-of-this-expression-or-multiple-ones"><a href="#19-What-is-the-result-of-this-expression-or-multiple-ones" class="headerlink" title="19.What is the result of this expression? (or multiple ones)"></a>19.What is the result of this expression? (or multiple ones)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function sidEffecting(ary) &#123;</div><div class="line">  ary[0] = ary[2];</div><div class="line">&#125;</div><div class="line">function bar(a,b,c) &#123;</div><div class="line">  c = 10</div><div class="line">  sidEffecting(arguments);</div><div class="line">  return a + b + c;</div><div class="line">&#125;</div><div class="line">bar(1,1,1)</div><div class="line">        </div><div class="line">A.3</div><div class="line">B.12</div><div class="line">C.error</div><div class="line">D.other</div></pre></td></tr></table></figure>
<p>考察函数的<code>arguments</code><br>函数的<code>arguments</code>与参数是相对应的，但不是同一片内存空间，所以答案为21，选D</p>
<h3 id="20-What-is-the-result-of-this-expression-or-multiple-ones"><a href="#20-What-is-the-result-of-this-expression-or-multiple-ones" class="headerlink" title="20.What is the result of this expression? (or multiple ones)"></a>20.What is the result of this expression? (or multiple ones)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var a = 111111111111111110000,</div><div class="line">    b = 1111;</div><div class="line">a + b;</div><div class="line">        </div><div class="line">A.111111111111111111111</div><div class="line">B.111111111111111110000</div><div class="line">C.NaN</div><div class="line">D.Infinity</div></pre></td></tr></table></figure>
<p>考察js的大数精度<br>js中的大数精度也缺失了，选B </p>
<h3 id="21-What-is-the-result-of-this-expression-or-multiple-ones"><a href="#21-What-is-the-result-of-this-expression-or-multiple-ones" class="headerlink" title="21.What is the result of this expression? (or multiple ones)"></a>21.What is the result of this expression? (or multiple ones)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var x = [].reverse;</div><div class="line">x();</div><div class="line"></div><div class="line">A.[]</div><div class="line">B.undefined</div><div class="line">C.error</div><div class="line">D.window</div></pre></td></tr></table></figure>
<p>题目基于ECMA 262 (5.1)的浏览器环境，<code>[].reverse</code>返回<code>this</code>，被浏览器调用之后为<code>window</code>。<br>选D</p>
<h3 id="22-What-is-the-result-of-this-expression-or-multiple-ones"><a href="#22-What-is-the-result-of-this-expression-or-multiple-ones" class="headerlink" title="22.What is the result of this expression? (or multiple ones)"></a>22.What is the result of this expression? (or multiple ones)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Number.MIN_VALUE &gt; 0</div><div class="line">        </div><div class="line">A.false</div><div class="line">B.true</div><div class="line">C.error</div><div class="line">D.other</div></pre></td></tr></table></figure>
<p>考察<code>Number</code><br><code>Number.MIN_VALUE</code>是大于0的最小数，所以选B</p>
<h3 id="23-What-is-the-result-of-this-expression-or-multiple-ones"><a href="#23-What-is-the-result-of-this-expression-or-multiple-ones" class="headerlink" title="23.What is the result of this expression? (or multiple ones)"></a>23.What is the result of this expression? (or multiple ones)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[1 &lt; 2 &lt; 3, 3 &lt; 2 &lt; 1]</div><div class="line">        </div><div class="line">A.[true, true]</div><div class="line">B.[true, false]</div><div class="line">C.error</div><div class="line">D.other</div></pre></td></tr></table></figure>
<p>考察<code>&lt;</code>运算符<br><code>(1 &lt; 2) &lt; 3</code>,<code>1 &lt; 2 //true 转换为1</code> <code>1 &lt; 3 // true</code><br><code>(3 &lt; 2) &lt; 1</code>,<code>3 &lt; 2 //false 转换为0</code> <code>0 &lt; 1 //true</code><br>所以选A</p>
<h3 id="24-What-is-the-result-of-this-expression-or-multiple-ones"><a href="#24-What-is-the-result-of-this-expression-or-multiple-ones" class="headerlink" title="24.What is the result of this expression? (or multiple ones)"></a>24.What is the result of this expression? (or multiple ones)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">// the most classic wtf</div><div class="line">2 == [[[2]]]</div><div class="line">        </div><div class="line">A.true</div><div class="line">B.false</div><div class="line">C.undefined</div><div class="line">D.other</div></pre></td></tr></table></figure>
<p>考察<code>==</code><br>对象和其他值比较时，会将对象转换为原始值，<code>[[[2]]]</code>转换原始值为2<br>所以返回<code>true</code></p>
<hr>
<p>2017.08.17更新</p>
<hr>
<h3 id="25-What-is-the-result-of-this-expression-or-multiple-ones"><a href="#25-What-is-the-result-of-this-expression-or-multiple-ones" class="headerlink" title="25.What is the result of this expression? (or multiple ones)"></a>25.What is the result of this expression? (or multiple ones)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">3.toString()</div><div class="line">3..toString()</div><div class="line">3...toString()</div><div class="line">        </div><div class="line">A.&quot;3&quot;, error, error</div><div class="line">B.&quot;3&quot;, &quot;3.0&quot;, error</div><div class="line">C.error, &quot;3&quot;, error</div><div class="line">D.other</div></pre></td></tr></table></figure>
<h3 id="26-What-is-the-result-of-this-expression-or-multiple-ones"><a href="#26-What-is-the-result-of-this-expression-or-multiple-ones" class="headerlink" title="26.What is the result of this expression? (or multiple ones)"></a>26.What is the result of this expression? (or multiple ones)</h3><p>(function(){<br>  var x = y = 1;<br>})();<br>console.log(y);<br>console.log(x);</p>
<p>1, 1<br>error, error<br>1, error<br>other</p>
<p>What is the result of this expression? (or multiple ones)</p>
<p>var a = /123/,<br>    b = /123/;<br>a == b<br>a === b</p>
<p>true, true<br>true, false<br>false, false<br>other</p>
<p>What is the result of this expression? (or multiple ones)</p>
<p>var a = [1, 2, 3],<br>    b = [1, 2, 3],<br>    c = [1, 2, 4]<br>a ==  b<br>a === b<br>a &gt;   c<br>a &lt;   c</p>
<p>false, false, false, true<br>false, false, false, false<br>true, true, false, true<br>other</p>
<p>What is the result of this expression? (or multiple ones)</p>
<p>var a = {}, b = Object.prototype;<br>[a.prototype === b, Object.getPrototypeOf(a) === b]</p>
<p>[false, true]<br>[true, true]<br>[false, false]<br>other</p>
<p>What is the result of this expression? (or multiple ones)</p>
<p>function f() {}<br>var a = f.prototype, b = Object.getPrototypeOf(f);<br>a === b</p>
<p>true<br>false<br>null<br>other</p>
<p>What is the result of this expression? (or multiple ones)</p>
<p>function foo() { }<br>var oldName = foo.name;<br>foo.name = “bar”;<br>[oldName, foo.name]</p>
<p>error<br>[“”, “”]<br>[“foo”, “foo”]<br>[“foo”, “bar”]</p>
<p>What is the result of this expression? (or multiple ones)</p>
<p>“1 2 3”.replace(/\d/g, parseInt)</p>
<p>“1 2 3”<br>“0 1 2”<br>“NaN 2 3”<br>“1 NaN 3”</p>
<p>What is the result of this expression? (or multiple ones)</p>
<p>function f() {}<br>var parent = Object.getPrototypeOf(f);<br>f.name // ?<br>parent.name // ?<br>typeof eval(f.name) // ?<br>typeof eval(parent.name) //  ?</p>
<p>“f”, “Empty”, “function”, “function”<br>“f”, undefined, “function”, error<br>“f”, “Empty”, “function”, error<br>other</p>
<p>What is the result of this expression? (or multiple ones)</p>
<p>var lowerCaseOnly =  /^[a-z]+$/;<br>[lowerCaseOnly.test(null), lowerCaseOnly.test()]</p>
<p>[true, false]<br>error<br>[true, true]<br>[false, true]</p>
<p>What is the result of this expression? (or multiple ones)</p>
<p>[,,,].join(“, “)</p>
<p>“, , , “<br>“undefined, undefined, undefined, undefined”<br>“, , “<br>“”</p>
<p>What is the result of this expression? (or multiple ones)</p>
<p>var a = {class: “Animal”, name: ‘Fido’};<br>a.class</p>
<p>“Animal”<br>Object<br>an error<br>other</p>
<p>What is the result of this expression? (or multiple ones)</p>
<p>var a = new Date(“epoch”)</p>
<p>Thu Jan 01 1970 01:00:00 GMT+0100 (CET)<br>current time<br>error<br>other</p>
<p>What is the result of this expression? (or multiple ones)</p>
<p>var a = Function.length,<br>    b = new Function().length<br>a === b</p>
<p>true<br>false<br>error<br>other</p>
<p>What is the result of this expression? (or multiple ones)</p>
<p>var a = Date(0);<br>var b = new Date(0);<br>var c = new Date();<br>[a === b, b === c, a === c]</p>
<p>[true, true, true]<br>[false, false, false]<br>[false, true, false]<br>[true, false, false]</p>
<p>What is the result of this expression? (or multiple ones)</p>
<p>var min = Math.min(), max = Math.max()<br>min &lt; max</p>
<p>true<br>false<br>error<br>other</p>
<p>What is the result of this expression? (or multiple ones)</p>
<p>function captureOne(re, str) {<br>  var match = re.exec(str);<br>  return match &amp;&amp; match[1];<br>}<br>var numRe  = /num=(\d+)/ig,<br>    wordRe = /word=(\w+)/i,<br>    a1 = captureOne(numRe,  “num=1”),<br>    a2 = captureOne(wordRe, “word=1”),<br>    a3 = captureOne(numRe,  “NUM=2”),<br>    a4 = captureOne(wordRe,  “WORD=2”);<br>[a1 === a2, a3 === a4]</p>
<p>[true, true]<br>[false, false]<br>[true, false]<br>[false, true]</p>
<p>What is the result of this expression? (or multiple ones)</p>
<p>var a = new Date(“2014-03-19”),<br>    b = new Date(2014, 03, 19);<br>[a.getDay() === b.getDay(), a.getMonth() === b.getMonth()]</p>
<p>[true, true]<br>[true, false]<br>[false, true]<br>[false, false]</p>
<p>What is the result of this expression? (or multiple ones)</p>
<p>if (‘<a href="http://giftwrapped.com/picture.jpg&#39;.match(&#39;.gif" target="_blank" rel="external">http://giftwrapped.com/picture.jpg&#39;.match(&#39;.gif</a>‘)) {<br>  ‘a gif file’<br>} else {<br>  ‘not a gif file’<br>}</p>
<p>‘a gif file’<br>‘not a gif file’<br>error<br>other</p>
<p>What is the result of this expression? (or multiple ones)</p>
<p>function foo(a) {<br>    var a;<br>    return a;<br>}<br>function bar(a) {<br>    var a = ‘bye’;<br>    return a;<br>}<br>[foo(‘hello’), bar(‘hello’)]</p>
<p>[“hello”, “hello”]<br>[“hello”, “bye”]<br>[“bye”, “bye”]<br>other</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://javascript-puzzlers.herokuapp.com/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;JavaScript Puzzlers!&lt;/a&gt;，题目基于ECMA 262 (5.1)的浏览器环境&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;2017.08.15更新&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;1-What-is-the-result-of-this-expression-or-multiple-ones&quot;&gt;&lt;a href=&quot;#1-What-is-the-result-of-this-expression-or-multiple-ones&quot; class=&quot;headerlink&quot; title=&quot;1.What is the result of this expression? (or multiple ones)&quot;&gt;&lt;/a&gt;1.What is the result of this expression? (or multiple ones)&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;[&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;].map(parseInt)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;A.[&amp;quot;1&amp;quot;, &amp;quot;2&amp;quot;, &amp;quot;3&amp;quot;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;B.[1, 2, 3]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;C.[0, 1, 2]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;D.other&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;考察&lt;code&gt;map&lt;/code&gt;和&lt;code&gt;parseInt&lt;/code&gt;&lt;br&gt;&lt;code&gt;Array.prototype.map()&lt;/code&gt;接收三个参数&lt;code&gt;(element,index,Array)&lt;/code&gt;&lt;br&gt;&lt;code&gt;parseInt()&lt;/code&gt;接收两个参数&lt;code&gt;(val,radix)&lt;/code&gt;,&lt;code&gt;radix&lt;/code&gt;为基数，&lt;code&gt;parseInt(&amp;#39;17&amp;#39;,8) //15&lt;/code&gt;,&lt;code&gt;radix&lt;/code&gt;为0或无表示以10为基数。每个位上的数字不能比基数大，否则返回&lt;code&gt;NaN&lt;/code&gt;,&lt;code&gt;radix&lt;/code&gt;不能为1,范围为2-36。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;parseInt(&amp;apos;1&amp;apos;,0)//1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;parseInt(&amp;apos;2&amp;apos;,1)//每个位上的数字不能比基数大，且基数不能为1,返回NaN&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;parseInt(&amp;apos;3&amp;apos;,2)//每个位上的数字不能比基数大,返回NaN&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;所以选D&lt;br&gt;
    
    </summary>
    
      <category term="Javascript" scheme="http://happylg.cn/categories/Javascript/"/>
    
    
      <category term="js" scheme="http://happylg.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Javascript中的Function对象总结</title>
    <link href="http://happylg.cn/2017/08/12/js-function/"/>
    <id>http://happylg.cn/2017/08/12/js-function/</id>
    <published>2017-08-12T12:17:06.000Z</published>
    <updated>2017-08-19T06:37:33.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><h2 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h2><p><code>arguments</code>是一个类似数组的对象, 对应于传递给函数的参数。<br><code>arguments</code>对象是所有函数中可用的局部变量。你可以使用<code>arguments</code>对象在函数中引用函数的参数。此对象包含传递给函数的每个参数的条目，第一个条目的索引从0开始。</p>
<h3 id="转换数组"><a href="#转换数组" class="headerlink" title="转换数组"></a>转换数组</h3><p><code>arguments</code>对象不是一个<code>Array</code>。它类似于数组，但除了长度之外没有任何数组属性。例如，它没有<code>pop</code>方法。但是它可以被转换为一个真正的数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let args = Array.prototype.slice.call(arguments); </div><div class="line"></div><div class="line">let args = [].slice.call(arguments);</div></pre></td></tr></table></figure></p>
<p>你还可以使用<code>Array.from()</code>方法或<code>spread</code>运算符将<code>arguments</code>转换为真正的数组：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">let args = Array.from(arguments);</div><div class="line">let args = [...arguments];</div></pre></td></tr></table></figure></p>
<h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><p><code>arguments.callee</code><br>指向当前执行的函数。<br><code>arguments.length</code><br>指向传递给当前函数的参数数量。</p>
<h2 id="length"><a href="#length" class="headerlink" title="length"></a>length</h2><p><code>length</code>是函数对象的一个属性值，指该函数有多少个必须要传入的参数，那些已定义了默认值的参数不算在内，比如<code>function（xx = 0）</code>的<code>length</code>是0。与之对比的是，<code>arguments.length</code>是函数被调用时实际传参的个数。</p>
<p><code>Function</code>构造器本身也是个<code>Function</code>。他的<code>length</code>属性值为 1 。该属性 <code>Writable: false</code>, <code>Enumerable: false</code>,<code>Configurable: true</code>。</p>
<p><code>Function</code>原型对象的<code>length</code>属性值为 0 。<br><a id="more"></a></p>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="Function-prototype-apply"><a href="#Function-prototype-apply" class="headerlink" title="Function.prototype.apply()"></a>Function.prototype.apply()</h2><p><code>apply()</code>方法调用一个函数, 其具有一个指定的<code>this</code>值，以及作为一个数组（或类似数组的对象）提供的参数。</p>
<h3 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">func.apply(thisArg, [argsArray])</div></pre></td></tr></table></figure>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><code>thisArg</code><br>在<code>func</code>函数运行时指定的<code>this</code>值。需要注意的是，指定的<code>this</code>值并不一定是该函数执行时真正的<code>this</code>值，如果这个函数处于非严格模式下，则指定为<code>null</code>或<code>undefined</code>时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的<code>this</code>会指向该原始值的自动包装对象。<br><code>argsArray</code><br>一个数组或者类数组对象，其中的数组元素将作为单独的参数传给<code>func</code>函数。如果该参数的值为<code>null</code>或<code>undefined</code>，则表示不需要传入任何参数。从ECMAScript5开始可以使用类数组对象。浏览器兼容性请参阅本文底部内容。</p>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>在调用一个存在的函数时，你可以为其指定一个<code>this</code>对象。<code>this</code>指当前对象，也就是正在调用这个函数的对象。 使用 <code>apply</code>， 你可以只写一次这个方法然后在另一个对象中继承它，`而不用在新对象中重复写该方法。</p>
<p><code>apply</code>与<code>call</code>非常相似，不同之处在于提供参数的方式。<code>apply</code>使用参数数组而不是一组参数列表（原文：a named set of parameters）。<code>apply</code>可以使用数组字面量（array literal），如 <code>fun.apply(this, [&#39;eat&#39;, &#39;bananas&#39;])</code>，或数组对象， 如<code>fun.apply(this, new Array(&#39;eat&#39;, &#39;bananas&#39;))</code>。</p>
<p>你也可以使用<code>arguments</code>对象作为<code>argsArray</code>参数。<code>arguments</code>是一个函数的局部变量。它可以被用作被调用对象的所有未指定的参数。这样，你在使用apply函数的时候就不需要知道被调用对象的所有参数。 你可以使用<code>arguments</code>来把所有的参数传递给被调用对象。 被调用对象接下来就负责处理这些参数。</p>
<h2 id="Function-prototype-call"><a href="#Function-prototype-call" class="headerlink" title="Function.prototype.call()"></a>Function.prototype.call()</h2><p><code>call()</code>方法调用一个函数,其具有一个指定的<code>this</code>值和分别地提供的参数(参数的列表)。</p>
<p>注意：该方法的作用和<code>apply()</code>方法类似，只有一个区别，就是<code>call()</code>方法接受的是若干个参数的列表，而<code>apply()</code>方法接受的是一个包含多个参数的数组。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">func.call(thisArg[, arg1[, arg2[, ...]]])</div></pre></td></tr></table></figure>
<h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><p><code>thisArg</code><br>在<code>func</code>函数运行时指定的<code>this</code>值。需要注意的是，指定的<code>this</code>值并不一定是该函数执行时真正的<code>this</code>值，如果这个函数处于非严格模式下，则指定为<code>null</code>和<code>undefined</code>的<code>this</code>值会自动指向全局对象(浏览器中就是window对象)，同时值为原始值(数字，字符串，布尔值)的this会指向该原始值的自动包装对象。<br><code>arg1, arg2, ...</code><br>指定的参数列表。</p>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>返回结果包括指定的this值和参数。</p>
<h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>可以让<code>call()</code>中的对象调用当前对象所拥有的<code>function</code>。你可以使用<code>call()</code>来实现继承：写一个方法，然后让另外一个新的对象来继承它（而不是在新对象中再写一次这个方法）。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;属性&quot;&gt;&lt;a href=&quot;#属性&quot; class=&quot;headerlink&quot; title=&quot;属性&quot;&gt;&lt;/a&gt;属性&lt;/h1&gt;&lt;h2 id=&quot;arguments&quot;&gt;&lt;a href=&quot;#arguments&quot; class=&quot;headerlink&quot; title=&quot;arguments&quot;&gt;&lt;/a&gt;arguments&lt;/h2&gt;&lt;p&gt;&lt;code&gt;arguments&lt;/code&gt;是一个类似数组的对象, 对应于传递给函数的参数。&lt;br&gt;&lt;code&gt;arguments&lt;/code&gt;对象是所有函数中可用的局部变量。你可以使用&lt;code&gt;arguments&lt;/code&gt;对象在函数中引用函数的参数。此对象包含传递给函数的每个参数的条目，第一个条目的索引从0开始。&lt;/p&gt;
&lt;h3 id=&quot;转换数组&quot;&gt;&lt;a href=&quot;#转换数组&quot; class=&quot;headerlink&quot; title=&quot;转换数组&quot;&gt;&lt;/a&gt;转换数组&lt;/h3&gt;&lt;p&gt;&lt;code&gt;arguments&lt;/code&gt;对象不是一个&lt;code&gt;Array&lt;/code&gt;。它类似于数组，但除了长度之外没有任何数组属性。例如，它没有&lt;code&gt;pop&lt;/code&gt;方法。但是它可以被转换为一个真正的数组：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;let args = Array.prototype.slice.call(arguments); &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;let args = [].slice.call(arguments);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;你还可以使用&lt;code&gt;Array.from()&lt;/code&gt;方法或&lt;code&gt;spread&lt;/code&gt;运算符将&lt;code&gt;arguments&lt;/code&gt;转换为真正的数组：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;let args = Array.from(arguments);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;let args = [...arguments];&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&quot;属性-1&quot;&gt;&lt;a href=&quot;#属性-1&quot; class=&quot;headerlink&quot; title=&quot;属性&quot;&gt;&lt;/a&gt;属性&lt;/h3&gt;&lt;p&gt;&lt;code&gt;arguments.callee&lt;/code&gt;&lt;br&gt;指向当前执行的函数。&lt;br&gt;&lt;code&gt;arguments.length&lt;/code&gt;&lt;br&gt;指向传递给当前函数的参数数量。&lt;/p&gt;
&lt;h2 id=&quot;length&quot;&gt;&lt;a href=&quot;#length&quot; class=&quot;headerlink&quot; title=&quot;length&quot;&gt;&lt;/a&gt;length&lt;/h2&gt;&lt;p&gt;&lt;code&gt;length&lt;/code&gt;是函数对象的一个属性值，指该函数有多少个必须要传入的参数，那些已定义了默认值的参数不算在内，比如&lt;code&gt;function（xx = 0）&lt;/code&gt;的&lt;code&gt;length&lt;/code&gt;是0。与之对比的是，&lt;code&gt;arguments.length&lt;/code&gt;是函数被调用时实际传参的个数。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Function&lt;/code&gt;构造器本身也是个&lt;code&gt;Function&lt;/code&gt;。他的&lt;code&gt;length&lt;/code&gt;属性值为 1 。该属性 &lt;code&gt;Writable: false&lt;/code&gt;, &lt;code&gt;Enumerable: false&lt;/code&gt;,&lt;code&gt;Configurable: true&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Function&lt;/code&gt;原型对象的&lt;code&gt;length&lt;/code&gt;属性值为 0 。&lt;br&gt;
    
    </summary>
    
      <category term="Javascript" scheme="http://happylg.cn/categories/Javascript/"/>
    
    
      <category term="js" scheme="http://happylg.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>前端面试总结</title>
    <link href="http://happylg.cn/2017/08/09/interview/"/>
    <id>http://happylg.cn/2017/08/09/interview/</id>
    <published>2017-08-09T02:31:06.000Z</published>
    <updated>2017-08-19T06:37:33.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、开放性题目"><a href="#一、开放性题目" class="headerlink" title="一、开放性题目"></a>一、开放性题目</h1><h2 id="为什么选择前端？"><a href="#为什么选择前端？" class="headerlink" title="为什么选择前端？"></a>为什么选择前端？</h2><h2 id="项目遇到的问题及如何解决？"><a href="#项目遇到的问题及如何解决？" class="headerlink" title="项目遇到的问题及如何解决？"></a>项目遇到的问题及如何解决？</h2><h1 id="二、技术性问题"><a href="#二、技术性问题" class="headerlink" title="二、技术性问题"></a>二、技术性问题</h1><a id="more"></a>
<h2 id="JS类问题"><a href="#JS类问题" class="headerlink" title="JS类问题"></a>JS类问题</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ol>
<li>面向对象和继承，object.create的实现原理?<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h3 id="Jquery"><a href="#Jquery" class="headerlink" title="Jquery"></a>Jquery</h3></li>
<li>Jquery特性及优缺点？<h3 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h3></li>
<li>特性</li>
<li>ES6中的箭头函数可以用作构造函数吗？<br> 答：项目中用到了很多ES6语法，对ES6有一点了解。箭头函数不可以作为构造函数，因为箭头函数内部并没有this，它的this其实是函数外层的this，因次不可以用new操作符调用，所以不可以作为构造函数使用。</li>
</ol>
<h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><h3 id="前端JS框架React-Vue-NG"><a href="#前端JS框架React-Vue-NG" class="headerlink" title="前端JS框架React/Vue/NG"></a>前端JS框架React/Vue/NG</h3><ol>
<li>NG的双向数据绑定?<h3 id="面向切面编程和函数式编程"><a href="#面向切面编程和函数式编程" class="headerlink" title="面向切面编程和函数式编程"></a>面向切面编程和函数式编程</h3><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3></li>
<li>postmessage和iframe怎么结合使用?</li>
<li>那些操作会有跨域的限制？为什么要有跨域的限制？没有跨域的限制会怎么样？<br> 答：我只想到ajax请求会有跨域的限制（应该还有别的）。为了安全性考虑，如果通过ajax请求受到了一段恶意代码，所以会有很大的隐患。接着面试官问：就算接收到了恶意代码，你不添加到html中，恶意代码也不会执行呀！然后我就懵逼了。。。<h3 id="深拷贝怎么实现"><a href="#深拷贝怎么实现" class="headerlink" title="深拷贝怎么实现"></a>深拷贝怎么实现</h3></li>
</ol>
<h2 id="CSS问题"><a href="#CSS问题" class="headerlink" title="CSS问题"></a>CSS问题</h2><h3 id="浏览器CSS-hack"><a href="#浏览器CSS-hack" class="headerlink" title="浏览器CSS hack"></a>浏览器CSS hack</h3><h3 id="实现bootstrap栅格系统"><a href="#实现bootstrap栅格系统" class="headerlink" title="实现bootstrap栅格系统"></a>实现bootstrap栅格系统</h3><h3 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h3><ol>
<li>Canvas上画个圆，可以用诸如getElementById()之类的方法获取吗？<br> 答：不可以，canvas是通过js绘制的图形，图形是一个一个像素画上去的，不可以获取到。但是svg是基于XML格式，内部是一个个节点，可以用DOM操作获取节点。</li>
<li>canvas上的图像获取到吗？<br> 答：可以，canvas原生的toDataURL()方法获取图像的Base64编码</li>
</ol>
<h2 id="计算机网络问题"><a href="#计算机网络问题" class="headerlink" title="计算机网络问题"></a>计算机网络问题</h2><h3 id="HTTP、HTTPS协议"><a href="#HTTP、HTTPS协议" class="headerlink" title="HTTP、HTTPS协议"></a>HTTP、HTTPS协议</h3><h3 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h3><h2 id="Web后台问题-node"><a href="#Web后台问题-node" class="headerlink" title="Web后台问题(node)"></a>Web后台问题(node)</h2><ol>
<li>后端为什么使用node？<h3 id="express-koa"><a href="#express-koa" class="headerlink" title="express/koa"></a>express/koa</h3><h3 id="自动化构建工具"><a href="#自动化构建工具" class="headerlink" title="自动化构建工具"></a>自动化构建工具</h3></li>
<li>你使用过的构建工具，说说对webpack的理解?<h3 id="图片压缩、上传、下载和缓存"><a href="#图片压缩、上传、下载和缓存" class="headerlink" title="图片压缩、上传、下载和缓存"></a>图片压缩、上传、下载和缓存</h3></li>
</ol>
<h2 id="数据库问题"><a href="#数据库问题" class="headerlink" title="数据库问题"></a>数据库问题</h2><ol>
<li>数据库缓存</li>
</ol>
<h2 id="前端安全"><a href="#前端安全" class="headerlink" title="前端安全"></a>前端安全</h2><ol>
<li>HTTPS</li>
<li>sql注入</li>
<li>xss攻击</li>
<li>csrf攻击</li>
</ol>
<h2 id="移动端问题"><a href="#移动端问题" class="headerlink" title="移动端问题"></a>移动端问题</h2><h2 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h2><ol>
<li>快速排序</li>
<li>二叉排序树</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、开放性题目&quot;&gt;&lt;a href=&quot;#一、开放性题目&quot; class=&quot;headerlink&quot; title=&quot;一、开放性题目&quot;&gt;&lt;/a&gt;一、开放性题目&lt;/h1&gt;&lt;h2 id=&quot;为什么选择前端？&quot;&gt;&lt;a href=&quot;#为什么选择前端？&quot; class=&quot;headerlink&quot; title=&quot;为什么选择前端？&quot;&gt;&lt;/a&gt;为什么选择前端？&lt;/h2&gt;&lt;h2 id=&quot;项目遇到的问题及如何解决？&quot;&gt;&lt;a href=&quot;#项目遇到的问题及如何解决？&quot; class=&quot;headerlink&quot; title=&quot;项目遇到的问题及如何解决？&quot;&gt;&lt;/a&gt;项目遇到的问题及如何解决？&lt;/h2&gt;&lt;h1 id=&quot;二、技术性问题&quot;&gt;&lt;a href=&quot;#二、技术性问题&quot; class=&quot;headerlink&quot; title=&quot;二、技术性问题&quot;&gt;&lt;/a&gt;二、技术性问题&lt;/h1&gt;
    
    </summary>
    
      <category term="Interview" scheme="http://happylg.cn/categories/Interview/"/>
    
    
      <category term="前端" scheme="http://happylg.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="interview" scheme="http://happylg.cn/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>CSS hack</title>
    <link href="http://happylg.cn/2017/08/09/hack/"/>
    <id>http://happylg.cn/2017/08/09/hack/</id>
    <published>2017-08-09T02:29:27.000Z</published>
    <updated>2017-08-19T06:37:33.837Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="CSS" scheme="http://happylg.cn/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://happylg.cn/tags/CSS/"/>
    
      <category term="hack" scheme="http://happylg.cn/tags/hack/"/>
    
  </entry>
  
  <entry>
    <title>Javascript操作DOM总结</title>
    <link href="http://happylg.cn/2017/08/07/js-dom/"/>
    <id>http://happylg.cn/2017/08/07/js-dom/</id>
    <published>2017-08-07T03:11:59.000Z</published>
    <updated>2017-08-19T06:37:33.869Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Node-innerText"><a href="#Node-innerText" class="headerlink" title="Node.innerText"></a>Node.innerText</h2><p>Node.innerText 是一个表示一个节点及其后代的“渲染”文本内容的属性。</p>
<p>作为一个获取器，如果用光标突出显示元素的内容，然后将其复制到剪贴板，则它将近似于用户将获得的文本。此功能最初由Internet Explorer引入，并在所有主要浏览器供应商采用后于2016年在HTML标准中正式规定。</p>
<p><code>Node.textContent</code>是一个有点类似的替代方案，虽然两者之间有重要的区别。</p>
<h2 id="element-innerHTML"><a href="#element-innerHTML" class="headerlink" title="element.innerHTML"></a>element.innerHTML</h2><p><code>Element.innerHTML</code>属性设置或获取描述元素后代的HTML语句。</p>
<p>Note: 如果一个<code>&lt;div&gt;</code>,<code>&lt;span&gt;</code>, 或 <code>&lt;noembed&gt;</code>节点具有一个文本子节点,包含字符<code>(&amp;)</code>,<code>(&lt;)</code>,  或<code>(&gt;)</code>, <code>innerHTML</code>将这些字符分别返回为<code>＆amp;</code>, <code>＆lt;</code>和<code>＆gt;</code>。使用<code>Node.textContent</code>获取一个这些文本节点内容的正确副本。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Node-innerText&quot;&gt;&lt;a href=&quot;#Node-innerText&quot; class=&quot;headerlink&quot; title=&quot;Node.innerText&quot;&gt;&lt;/a&gt;Node.innerText&lt;/h2&gt;&lt;p&gt;Node.innerText 是一个表示一个
    
    </summary>
    
      <category term="Javascript" scheme="http://happylg.cn/categories/Javascript/"/>
    
    
      <category term="js" scheme="http://happylg.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Javascript零散笔记</title>
    <link href="http://happylg.cn/2017/08/06/js-other/"/>
    <id>http://happylg.cn/2017/08/06/js-other/</id>
    <published>2017-08-06T14:30:57.000Z</published>
    <updated>2017-08-19T08:36:02.287Z</updated>
    
    <content type="html"><![CDATA[<ol>
<li><p>JavaScript 中包含以下 7 个全局函数，用于完成一些常用的功能：escape( )、eval( )、isFinite( )、isNaN( )、parseFloat( )、parseInt( )、unescape( )。</p>
</li>
<li><p>JavaScript为指定元素绑定一个事件处理器函数</p>
</li>
<li><p>Javascript块内声明函数<br> 不要在块内声明一个函数（严格模式会报语法错误）。如果确实需要在块中定义函数，可以使用函数表达式来声明函数。</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/* Recommended */</div><div class="line">if (x) &#123;</div><div class="line">	var foo = function() &#123;&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">/* Wrong */</div><div class="line">if (x) &#123;</div><div class="line">	function foo() &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<a id="more"></a>
<ol>
<li><p>Jquery获取宽高</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">alert($(window).height()); //浏览器当前窗口可视区域高度 </div><div class="line">alert($(document).height()); //浏览器当前窗口文档的高度 </div><div class="line">alert($(document.body).height());//浏览器当前窗口文档body的高度 </div><div class="line">alert($(document.body).outerHeight(true));//浏览器当前窗口文档body的总高度 包括border padding margin </div><div class="line">alert($(window).width()); //浏览器当前窗口可视区域宽度 </div><div class="line">alert($(document).width());//浏览器当前窗口文档对象宽度 </div><div class="line">alert($(document.body).width());//浏览器当前窗口文档body的高度 </div><div class="line">alert($(document.body).outerWidth(true));//浏览器当前窗口文档body的总宽度 包括border padding margin</div></pre></td></tr></table></figure>
</li>
<li><p>浏览器兼容性问题</p>
</li>
</ol>
<ul>
<li>SD9017: Firefox 不支持 DOM 对象的 outerHTML、innerText、outerText 属性(参见<a href="http://w3help.org/zh-cn/causes/SD9017" target="_blank" rel="external">http://w3help.org/zh-cn/causes/SD9017</a>)</li>
<li>SD9010: 仅 IE 中的 createElement 方法支持传入 HTML String 做参数</li>
<li>SD9006: IE 混淆了 DOM 对象属性（property）及 HTML 标签属性（attribute），造成了对 setAttribute、getAttribute 的不正确实现</li>
</ul>
<hr>
<p>2017.08.15更新</p>
<hr>
<h2 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h2><p>parseInt() 函数解析一个字符串参数，并返回一个指定基数的整数 (数学系统的基础)。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">parseInt(string, radix);</div></pre></td></tr></table></figure>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><code>string</code><br>要被解析的值。如果参数不是一个字符串，则将其转换为字符串(使用<code>ToString</code>抽象操作)。字符串开头的空白符将会被忽略。<br><code>radix</code><br>一个介于2和36之间的整数(数学系统的基础)，表示上述字符串的基数。比如参数”10”表示使用我们通常使用的十进制数值系统。始终指定此参数可以消除阅读该代码时的困惑并且保证转换结果可预测。当未指定基数时，不同的实现会产生不同的结果，通常将值默认为10。</p>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>返回解析后的整数值。 如果被解析参数的第一个字符无法被转化成数值类型，则返回<code>NaN</code>。</p>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p><code>parseInt</code>函数将其第一个参数转换为字符串，解析它，并返回一个整数或<code>NaN</code>。如果不是<code>NaN</code>，返回的值将是作为指定基数（基数）中的数字的第一个参数的整数。<br>例如：<code>radix</code>参数为10将会把第一个参数看作是一个数的十进制表示，8对应八进制，16对应十六进制，等等。基数大于10时，用字母表中的字母来表示大于9的数字。例如十六进制中，使用A到F。<br>如果<code>parseInt</code>遇到了不属于<code>radix</code>参数所指定的基数中的字符那么该字符和其后的字符都将被忽略。接着返回已经解析的整数部分。<code>parseInt</code>将截取整数部分。开头和结尾的空白符允许存在，会被忽略。<br>在没有指定基数，或者基数为0的情况下，JavaScript作如下处理：</p>
<ol>
<li>如果字符串<code>string</code>以”0x”或者”0X”开头,则基数是16(16进制).</li>
<li>如果字符串<code>string</code>以”0”开头,基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript5规定使用10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出radix参数的值。</li>
<li>如果字符串<code>string</code>以其它任何值开头，则基数是10(十进制)。</li>
<li>如果第一个字符不能被转换成数字，<code>parseInt</code>返回<code>NaN</code>。</li>
</ol>
<p>算术上，<code>NaN</code>不是任何一个进制下的数。你可以调用<code>isNaN</code>来判断<code>parseInt</code>是否返回<code>NaN</code>。<code>NaN</code>参与的数学运算其结果总是<code>NaN</code>。<br>将整型数值以特定基数转换成它的字符串值可以使用<code>intValue.toString(radix)</code>.</p>
<h2 id="null与undefined"><a href="#null与undefined" class="headerlink" title="null与undefined"></a>null与undefined</h2><p>值<code>null</code>是一个 JavaScript 字面量，表示空值（null or an “empty” value），即没有对象被呈现（no object value is present）。它是JavaScript原始数据类型之一。</p>
<p>全局属性<code>undefined</code>表示原始值<code>undefined</code>。它是一个JavaScript的原始数据类型 。<br>JavaScript的原始数据类型：<code>String</code>,<code>Number</code>,<code>Bollean</code>,<code>null</code>,<code>undefined</code>,<code>symbol</code>(ES2015新增)</p>
<p><code>null</code>与<code>undefined</code>的不同点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">typeof null        // object (因为一些以前的原因而不是&apos;null&apos;)</div><div class="line">typeof undefined   // undefined</div><div class="line">null === undefined // false</div><div class="line">null  == undefined // true</div><div class="line">null === null // true</div><div class="line">null == null // true</div><div class="line">!null //true</div><div class="line">isNaN(1 + null) // false</div><div class="line">isNaN(1 + undefined) // true</div></pre></td></tr></table></figure></p>
<h2 id="js精度丢失"><a href="#js精度丢失" class="headerlink" title="js精度丢失"></a>js精度丢失</h2><p>计算机的二进制实现和位数限制有些数无法有限表示。就像一些无理数不能有限表示，如 圆周率 3.1415926…，1.3333… 等。JS 遵循 IEEE 754 规范，采用双精度存储（double precision），占用 64 bit。<br>解决方案：</p>
<ul>
<li>对于整数，前端出现问题的几率可能比较低，毕竟很少有业务需要需要用到超大整数，只要运算结果不超过 Math.pow(2, 53) 就不会丢失精度。</li>
<li>对于小数，前端出现问题的几率还是很多的，尤其在一些电商网站涉及到金额等数据。解决方式：把小数放到位整数（乘倍数），再缩小回原来倍数（除倍数）</li>
</ul>
<h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p><code>switch()</code>使用<code>===</code>判断相等</p>
]]></content>
    
    <summary type="html">
    
      &lt;ol&gt;
&lt;li&gt;&lt;p&gt;JavaScript 中包含以下 7 个全局函数，用于完成一些常用的功能：escape( )、eval( )、isFinite( )、isNaN( )、parseFloat( )、parseInt( )、unescape( )。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;JavaScript为指定元素绑定一个事件处理器函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Javascript块内声明函数&lt;br&gt; 不要在块内声明一个函数（严格模式会报语法错误）。如果确实需要在块中定义函数，可以使用函数表达式来声明函数。&lt;/p&gt;
 &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;/* Recommended */&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;if (x) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	var foo = function() &amp;#123;&amp;#125;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;/* Wrong */&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;if (x) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	function foo() &amp;#123;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Javascript" scheme="http://happylg.cn/categories/Javascript/"/>
    
    
      <category term="js" scheme="http://happylg.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Javascript函数和作用域总结</title>
    <link href="http://happylg.cn/2017/08/05/js-scope/"/>
    <id>http://happylg.cn/2017/08/05/js-scope/</id>
    <published>2017-08-05T14:53:00.000Z</published>
    <updated>2017-08-19T06:37:33.879Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、执行环境和作用域"><a href="#一、执行环境和作用域" class="headerlink" title="一、执行环境和作用域"></a>一、执行环境和作用域</h2><p>执行环境(execution context)定义了函数或变量有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象(variable object)，环境中定义的所有变量和函数都保存在这个对象中。全局执行环境是最外围的一个执行环境。某个执行环境的所有代码执行完毕后，该环境销毁，保存在其中的所有变量和函数定义也随之销毁。（全局执行环境直到应用程序退出才会销毁）每个函数都有自己的执行环境。当执行流程进入一个函数时，函数的环境就会被推入一个环境栈中，在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。</p>
<p>当代码在一个环境中执行时，会创建变量对象的一个作用域链(scope chain)。作用域的用途是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端始终是当前执行的代码所在的环境的变量对象。如果这个环境是函数，则将其活动对象(activation object)作为变量对象。活动对象最开始只包含一个变量，即<code>arguments</code>对象(这个对象在全局环境中不存在的)，作用域链中的下一个对象来自包含(外部)环境，一直延续到全局执行环境。全局执行环境的变量对象始终都是作用域链的最后一个对象。</p>
<p>标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程中始终从作用域链的前端开始。搜索过程始终从作用域链的前端开始然后逐级地向后回溯，知道找到标识符为止（若找不到，通常会导致错误发生）</p>
<p>js没有块级作用域，但是在es6中新增let关键字可定义块级变量。</p>
<h2 id="二、函数"><a href="#二、函数" class="headerlink" title="二、函数"></a>二、函数</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ol>
<li><p>函数声明</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function sum(num1,num2)&#123;</div><div class="line">    return num1 + num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>函数表达式</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var sum = function(num1,num2)&#123;</div><div class="line">    return num1 + num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 解析器会率先读取函数声明，并使其在执行任何代码之前可用(可以访问)；<br> 函数表达式则必须等到解析器执行到它所在的代码行，才会真正被解析执行。<br> 在代码开始之前，解析器就已通过一个名为函数声明提升(function declaration hoisting)的过程，将函数声明添加到执行环境中。对代码求值时，Javascript引擎在第一遍会声明函数并将他们放到源代码树的顶部。所以，即使声明函数的代码在调用它的代码后面，Javascript引擎也能把函数声明提升到顶部。</p>
</li>
<li><p>Function构造函数</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//接收任意数量参数，最后一个参数始终被看做函数体</div><div class="line">var sum = new Function(&apos;num1&apos;,&apos;num2&apos;,&apos;return num1 + num2&apos;);//不推荐</div></pre></td></tr></table></figure>
<p> 函数是对象，函数名是指针</p>
</li>
</ol>
<h3 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h3><p>同名函数后一个函数会覆盖前一个函数，不会发生函数重载<br><a id="more"></a></p>
<h2 id="三、参数传递"><a href="#三、参数传递" class="headerlink" title="三、参数传递"></a>三、参数传递</h2><ol>
<li><p>基本类型按值传递</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function setNum(num)&#123;</div><div class="line">    num += 10;</div><div class="line">    return num;</div><div class="line">&#125;</div><div class="line">var a = 10;</div><div class="line">var result = setNum(a);</div><div class="line">console.log(result);//20</div></pre></td></tr></table></figure>
</li>
<li><p>引用类型按指针的值传递，并非按引用传递</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">    function setObj(obj)&#123;</div><div class="line">        obj.name = &apos;zxlg&apos;;</div><div class="line">        return obj;</div><div class="line">    &#125;</div><div class="line">    var person = new Object();</div><div class="line">    setObj(person);</div><div class="line">    console.log(person.name);// &apos;zxlg&apos;</div><div class="line"></div><div class="line">//使用对象，看似按引用传递，</div><div class="line">//其实不然，参数传递的是指针的值，</div><div class="line">//指针的值是不会变的，指针指向的内容有可能会被改变</div><div class="line">    function setObj(obj)&#123;</div><div class="line">        obj.name = &apos;zxlg&apos;;</div><div class="line">        obj = new Object();</div><div class="line">        obj.name = &apos;fool&apos;;</div><div class="line">        return obj;</div><div class="line">    &#125;</div><div class="line">    var person = new Object();</div><div class="line">    setObj(person);</div><div class="line">    console.log(person.name);//&apos;zxlg&apos;</div></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="四、arguments对象和this对象"><a href="#四、arguments对象和this对象" class="headerlink" title="四、arguments对象和this对象"></a>四、arguments对象和this对象</h2><h3 id="arguments对象"><a href="#arguments对象" class="headerlink" title="arguments对象"></a>arguments对象</h3><p>类数组对象，包含着传入函数中的所有参数，可以用方括号访问它的每一个元素，使用<code>length</code>来确定传进多少个元素。函数命名的参数只提供便利，但不是必需的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">function doAdd(num1,num2)&#123;</div><div class="line">    arguments[1] = 10;</div><div class="line">    console.log(arguments[0] + num2);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>arguments</code>的值永远与对应命名参数的值保持同步。在非严格模式下，重写<code>arguments[1]</code>，也就修改了<code>num2</code>,结果均变为10(严格模式下重写<code>arguments</code>的值会导致语法错误)。但它们的内存空间是独立的，而<code>arguments</code>的值会与参数的值同步。</p>
<p>若只传入一个参数，那么<code>arguments[1]</code>设置的值不会反应到命名参数中，<strong>因为<code>arguments</code>对象的长度是由传入参数的个数决定的，不是由定义函数的参数的个数决定的。</strong></p>
<p>没有传递值的命名参数自动被赋予<code>undefined</code>值，类似于定义变量但没有初始化。</p>
<p><code>arguments</code>的主要用途是保存函数参数，但这个对象还有一个名叫<code>callee</code>的属性，该属性是一个指针，指向这个拥有<code>arguments</code>对象的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//阶乘函数</div><div class="line">function factorial(num)&#123;</div><div class="line">    if(num &lt; 1)&#123;</div><div class="line">        return 1;</div><div class="line">    &#125;else&#123;</div><div class="line">        return num * factorial(num - 1);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>函数有名字，函数的执行与函数名factorial紧紧耦合在一起，使用<code>arguments.callee</code>可消除这种耦合。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function factorial(num)&#123;</div><div class="line">    if(num &lt; 1)&#123;</div><div class="line">        return 1;</div><div class="line">    &#125;else&#123;</div><div class="line">        return num * arguments.callee(num - 1);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="this对象"><a href="#this对象" class="headerlink" title="this对象"></a>this对象</h3><p>this引用的是函数执行的环境对象，<strong>即调用函数的那个对象</strong>。<br>参考<a href="http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html" target="_blank" rel="external">阮老师的文章</a></p>
<ul>
<li><p><strong>纯粹的函数调用</strong><br>  这是函数的最通常用法，属于全局性调用，因此this就代表全局对象Global。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var x = 1;</div><div class="line">　　function test()&#123;</div><div class="line">　　　　this.x = 0;</div><div class="line">　　&#125;</div><div class="line">　　test();</div><div class="line">　　alert(x); //0</div></pre></td></tr></table></figure>
</li>
<li><p><strong>作为对象方法的调用</strong><br>  函数还可以作为某个对象的方法调用，这时this就指这个上级对象。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function test()&#123;</div><div class="line">　　　　alert(this.x);</div><div class="line">　　&#125;</div><div class="line">　　var o = &#123;&#125;;</div><div class="line">　　o.x = 1;</div><div class="line">　　o.m = test;</div><div class="line">　　o.m(); // 1</div></pre></td></tr></table></figure>
</li>
<li><p><strong>作为构造函数调用</strong><br>  所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var x = 2;</div><div class="line">　　function test()&#123;</div><div class="line">　　　　this.x = 1;</div><div class="line">　　&#125;</div><div class="line">　　var o = new test();</div><div class="line">　　alert(x); //2</div></pre></td></tr></table></figure>
</li>
<li><p><strong>apply调用</strong><br>  apply()是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。因此，this指的就是这第一个参数。 </p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var x = 0;</div><div class="line">　　function test()&#123;</div><div class="line">　　　　alert(this.x);</div><div class="line">　　&#125;</div><div class="line">　　var o=&#123;&#125;;</div><div class="line">　　o.x = 1;</div><div class="line">　　o.m = test;</div><div class="line">　　o.m.apply(); //0</div><div class="line">　　o.m.apply(o); //1</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="五、prototype属性"><a href="#五、prototype属性" class="headerlink" title="五、prototype属性"></a>五、prototype属性</h2><h2 id="六、变量提升"><a href="#六、变量提升" class="headerlink" title="六、变量提升"></a>六、变量提升</h2><p>变量提升(Hoisting)被认为是思考执行上下文（特别是创建和执行阶段）在JavaScript中如何工作的一般方式。但变量提升(Hoisting)可能会导致误解。例如，提升教导变量和函数声明被物理移动到编码的顶部，这不算什么。<strong>真正发生的什么是在编译阶段将变量和函数声明放入内存中，但仍然保留在编码中键入的位置。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line">* 不推荐的方式：先调用函数，再声明函数 </div><div class="line">*/</div><div class="line"></div><div class="line">catName(&quot;Chloe&quot;);</div><div class="line"></div><div class="line">function catName(name) &#123;</div><div class="line">    console.log(&quot;My cat&apos;s name is &quot; + name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">/*</div><div class="line">The result of the code above is: &quot;My cat&apos;s name is Chloe&quot;</div><div class="line">*/</div><div class="line"></div><div class="line">// 等价于</div><div class="line"></div><div class="line">/*函数声明提升*/</div><div class="line">function catName(name) &#123;</div><div class="line">    console.log(&quot;My cat&apos;s name is &quot; + name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">catName(&quot;Tigger&quot;);</div><div class="line"></div><div class="line">/*</div><div class="line">The result of the code above is: &quot;My cat&apos;s name is Chloe&quot;</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<p>即使我们先在代码中调用函数，在写该函数之前，代码仍然可以工作。</p>
<p>Hoisting 也适用于其他数据类型和变量。变量可以在声明之前进行初始化和使用。但是如果没有初始化，就不能使用。<br><strong>JavaScript 仅提升声明，而不是初始化。</strong>如果你使用的是在使用后声明和初始化的一个变量，那么该值将是 undefined。以下两个示例演示了相同的行为。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var x = 1; // 声明 + 初始化 x</div><div class="line"></div><div class="line">console.log(x + &quot; &quot; + y);  // y 是未定义的</div><div class="line"></div><div class="line">var y = 2;// 声明 + 初始化 y</div><div class="line"></div><div class="line"></div><div class="line">//上面的代码和下面的代码是一样的 </div><div class="line"></div><div class="line">var x = 1; // 声明 + 初始化 x</div><div class="line"></div><div class="line">var y; //声明 y</div><div class="line"></div><div class="line">console.log(x + &quot; &quot; + y);  //y 是未定义的</div><div class="line"></div><div class="line">y = 2; // 初始化  y</div></pre></td></tr></table></figure></p>
<p><strong>ES6 : let 不存在 Hoisting</strong></p>
<h2 id="七、检测类型"><a href="#七、检测类型" class="headerlink" title="七、检测类型"></a>七、检测类型</h2><ol>
<li><p>检测基本数据类型：<code>typeof</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var str = &apos;zxlg&apos;; console.log(typeof str); // string</div><div class="line">var num = 9; console.log(typeof num);// number</div><div class="line">var bool = true; console.log(typeof bool);// boolean</div><div class="line">var u; console.log(typeof u);// undefined</div><div class="line">var nul = null; console.log(typeof nul);// object</div><div class="line">var obj = new Object(); console.log(typeof obj);// object</div></pre></td></tr></table></figure>
</li>
<li><p>检测引用类型：<code>instanceof</code><br><code>typeof</code>检测所有引用类型均为<code>object</code>，想得到何种引用类型可使用<code>instanceof</code></p>
</li>
</ol>
<hr>
<p>(2017.8.7新增)<br>检测一个引用类型值和<code>Object</code>构造函数时，<code>instanceof</code>操作符始终会返回<code>true</code>。<br><strong>如果使用<code>instanceof</code>操作符检测基本类型的值，则该操作符始终会返回<code>false</code>,因为基本类型都不是对象。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var arr = [1,2,3];</div><div class="line">console.log(arr instanceof Object); // true</div><div class="line">console.log(arr instanceof Array); // true</div><div class="line">var reg = /\d+/;</div><div class="line">console.log(arr instanceof Array); // false</div><div class="line">console.log(arr instanceof RegExp); // true</div></pre></td></tr></table></figure>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Hoisting" target="_blank" rel="external">MDN变量提升</a></li>
<li>Javascript高级程序设计(第3版)</li>
<li><a href="http://www.ruanyifeng.com/blog/2010/04/using_this_keyword_in_javascript.html" target="_blank" rel="external">Javascript的this用法</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、执行环境和作用域&quot;&gt;&lt;a href=&quot;#一、执行环境和作用域&quot; class=&quot;headerlink&quot; title=&quot;一、执行环境和作用域&quot;&gt;&lt;/a&gt;一、执行环境和作用域&lt;/h2&gt;&lt;p&gt;执行环境(execution context)定义了函数或变量有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象(variable object)，环境中定义的所有变量和函数都保存在这个对象中。全局执行环境是最外围的一个执行环境。某个执行环境的所有代码执行完毕后，该环境销毁，保存在其中的所有变量和函数定义也随之销毁。（全局执行环境直到应用程序退出才会销毁）每个函数都有自己的执行环境。当执行流程进入一个函数时，函数的环境就会被推入一个环境栈中，在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。&lt;/p&gt;
&lt;p&gt;当代码在一个环境中执行时，会创建变量对象的一个作用域链(scope chain)。作用域的用途是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端始终是当前执行的代码所在的环境的变量对象。如果这个环境是函数，则将其活动对象(activation object)作为变量对象。活动对象最开始只包含一个变量，即&lt;code&gt;arguments&lt;/code&gt;对象(这个对象在全局环境中不存在的)，作用域链中的下一个对象来自包含(外部)环境，一直延续到全局执行环境。全局执行环境的变量对象始终都是作用域链的最后一个对象。&lt;/p&gt;
&lt;p&gt;标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程中始终从作用域链的前端开始。搜索过程始终从作用域链的前端开始然后逐级地向后回溯，知道找到标识符为止（若找不到，通常会导致错误发生）&lt;/p&gt;
&lt;p&gt;js没有块级作用域，但是在es6中新增let关键字可定义块级变量。&lt;/p&gt;
&lt;h2 id=&quot;二、函数&quot;&gt;&lt;a href=&quot;#二、函数&quot; class=&quot;headerlink&quot; title=&quot;二、函数&quot;&gt;&lt;/a&gt;二、函数&lt;/h2&gt;&lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;函数声明&lt;/p&gt;
 &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;function sum(num1,num2)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    return num1 + num2;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;函数表达式&lt;/p&gt;
 &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;var sum = function(num1,num2)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    return num1 + num2;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; 解析器会率先读取函数声明，并使其在执行任何代码之前可用(可以访问)；&lt;br&gt; 函数表达式则必须等到解析器执行到它所在的代码行，才会真正被解析执行。&lt;br&gt; 在代码开始之前，解析器就已通过一个名为函数声明提升(function declaration hoisting)的过程，将函数声明添加到执行环境中。对代码求值时，Javascript引擎在第一遍会声明函数并将他们放到源代码树的顶部。所以，即使声明函数的代码在调用它的代码后面，Javascript引擎也能把函数声明提升到顶部。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Function构造函数&lt;/p&gt;
 &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;//接收任意数量参数，最后一个参数始终被看做函数体&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;var sum = new Function(&amp;apos;num1&amp;apos;,&amp;apos;num2&amp;apos;,&amp;apos;return num1 + num2&amp;apos;);//不推荐&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt; 函数是对象，函数名是指针&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;没有重载&quot;&gt;&lt;a href=&quot;#没有重载&quot; class=&quot;headerlink&quot; title=&quot;没有重载&quot;&gt;&lt;/a&gt;没有重载&lt;/h3&gt;&lt;p&gt;同名函数后一个函数会覆盖前一个函数，不会发生函数重载&lt;br&gt;
    
    </summary>
    
      <category term="Javascript" scheme="http://happylg.cn/categories/Javascript/"/>
    
    
      <category term="js" scheme="http://happylg.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议总结</title>
    <link href="http://happylg.cn/2017/08/05/http/"/>
    <id>http://happylg.cn/2017/08/05/http/</id>
    <published>2017-08-05T08:02:45.000Z</published>
    <updated>2017-08-19T06:37:33.839Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><h2 id="参考文献："><a href="#参考文献：" class="headerlink" title="参考文献："></a>参考文献：</h2><p>1.<a href="http://www.ruanyifeng.com/blog/2016/08/http.html" target="_blank" rel="external">阮一峰的网络网络日志</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HTTP&quot;&gt;&lt;a href=&quot;#HTTP&quot; class=&quot;headerlink&quot; title=&quot;HTTP&quot;&gt;&lt;/a&gt;HTTP&lt;/h2&gt;&lt;h2 id=&quot;HTTPS&quot;&gt;&lt;a href=&quot;#HTTPS&quot; class=&quot;headerlink&quot; title=&quot;HTTPS&quot;&gt;
    
    </summary>
    
      <category term="网络" scheme="http://happylg.cn/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="http://happylg.cn/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="http" scheme="http://happylg.cn/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>TCP/IP协议总结</title>
    <link href="http://happylg.cn/2017/08/05/tcp-ip/"/>
    <id>http://happylg.cn/2017/08/05/tcp-ip/</id>
    <published>2017-08-05T08:01:38.000Z</published>
    <updated>2017-08-19T06:37:33.889Z</updated>
    
    <content type="html"><![CDATA[<p>暂封</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;暂封&lt;/p&gt;

    
    </summary>
    
      <category term="网络" scheme="http://happylg.cn/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="ip" scheme="http://happylg.cn/tags/ip/"/>
    
      <category term="tcp" scheme="http://happylg.cn/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>Javascript异步总结</title>
    <link href="http://happylg.cn/2017/08/05/js-async/"/>
    <id>http://happylg.cn/2017/08/05/js-async/</id>
    <published>2017-08-05T07:57:53.000Z</published>
    <updated>2017-08-19T06:37:33.867Z</updated>
    
    <content type="html"><![CDATA[<p>暂封</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;暂封&lt;/p&gt;

    
    </summary>
    
      <category term="Javascript" scheme="http://happylg.cn/categories/Javascript/"/>
    
    
      <category term="js" scheme="http://happylg.cn/tags/js/"/>
    
      <category term="async" scheme="http://happylg.cn/tags/async/"/>
    
  </entry>
  
  <entry>
    <title>前端Ajax操作总结</title>
    <link href="http://happylg.cn/2017/08/05/ajax/"/>
    <id>http://happylg.cn/2017/08/05/ajax/</id>
    <published>2017-08-05T07:55:28.000Z</published>
    <updated>2017-08-19T06:37:32.780Z</updated>
    
    <content type="html"><![CDATA[<p>暂封</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;暂封&lt;/p&gt;

    
    </summary>
    
      <category term="Ajax" scheme="http://happylg.cn/categories/Ajax/"/>
    
    
      <category term="前端" scheme="http://happylg.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="ajax" scheme="http://happylg.cn/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>《影响力》读书笔记</title>
    <link href="http://happylg.cn/2017/08/05/effect/"/>
    <id>http://happylg.cn/2017/08/05/effect/</id>
    <published>2017-08-05T07:27:48.000Z</published>
    <updated>2017-08-19T06:37:33.835Z</updated>
    
    <content type="html"><![CDATA[<p>于2017.7.1读完，于2017.8.5建立读书笔记<br>暂封</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;于2017.7.1读完，于2017.8.5建立读书笔记&lt;br&gt;暂封&lt;/p&gt;

    
    </summary>
    
      <category term="读书笔记" scheme="http://happylg.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书" scheme="http://happylg.cn/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>《自控力》读书笔记</title>
    <link href="http://happylg.cn/2017/08/05/self-control/"/>
    <id>http://happylg.cn/2017/08/05/self-control/</id>
    <published>2017-08-05T07:25:58.000Z</published>
    <updated>2017-08-19T06:37:33.886Z</updated>
    
    <content type="html"><![CDATA[<p>于2017.7.22读完，于2017.8.5建读书笔记<br>暂封</p>
<h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;于2017.7.22读完，于2017.8.5建读书笔记&lt;br&gt;暂封&lt;/p&gt;
&lt;h2 id=&quot;更新&quot;&gt;&lt;a href=&quot;#更新&quot; class=&quot;headerlink&quot; title=&quot;更新&quot;&gt;&lt;/a&gt;更新&lt;/h2&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://happylg.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="读书" scheme="http://happylg.cn/tags/%E8%AF%BB%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>Markdown技巧</title>
    <link href="http://happylg.cn/2017/08/04/markdown/"/>
    <id>http://happylg.cn/2017/08/04/markdown/</id>
    <published>2017-08-04T02:11:44.000Z</published>
    <updated>2017-08-19T06:37:33.882Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、代码"><a href="#一、代码" class="headerlink" title="一、代码"></a>一、代码</h1><h2 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h2><ul>
<li>第一种，只要简单地缩进 4 个空格或是 1 个制表符就可以</li>
<li>第二种，在代码段落的头部和尾部用```包围起来</li>
</ul>
<h2 id="行内代码块"><a href="#行内代码块" class="headerlink" title="行内代码块"></a>行内代码块</h2><p>用` `包围</p>
<h1 id="二、链接"><a href="#二、链接" class="headerlink" title="二、链接"></a>二、链接</h1><ol>
<li><p>文字链接 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[链接名称](http://链接网址)</div></pre></td></tr></table></figure>
</li>
<li><p>网址链接 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;http://链接网址&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="三、图片"><a href="#三、图片" class="headerlink" title="三、图片"></a>三、图片</h1><ol>
<li><p>行内式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![alt图片名称](http://图片网址)</div></pre></td></tr></table></figure>
</li>
<li><p>参考式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![alt图片名称][本地图片地址]</div></pre></td></tr></table></figure>
</li>
</ol>
<p>目前为止Markdown 还没有办法指定图片的宽高，如果需要，可以使用普通的<code>&lt;img&gt;</code>标签。<br><a id="more"></a></p>
<h1 id="四、表格"><a href="#四、表格" class="headerlink" title="四、表格"></a>四、表格</h1><h2 id="单元格和表头"><a href="#单元格和表头" class="headerlink" title="单元格和表头"></a>单元格和表头</h2><p>使用<code>|</code>来分隔不同的单元格，使用<code>-</code>来分隔表头和其他行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">name | age</div><div class="line">---- | ---</div><div class="line">LearnShare | 12</div><div class="line">Mike |  32</div></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>name</th>
<th>age</th>
</tr>
</thead>
<tbody>
<tr>
<td>LearnShare</td>
<td>12</td>
</tr>
<tr>
<td>Mike</td>
<td>32</td>
</tr>
</tbody>
</table>
<h2 id="对齐"><a href="#对齐" class="headerlink" title="对齐"></a>对齐</h2><p>在表头下方的分隔线标记中加入<code>:</code>，即可标记下方单元格内容的对齐方式：</p>
<p><code>:---</code>代表左对齐<br><code>:--:</code>代表居中对齐<br><code>---:</code>代表右对齐<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">| left | center | right |</div><div class="line">| :--- | :----: | ----: |</div><div class="line">| aaaa | bbbbbb | ccccc |</div><div class="line">| a    | b      | c     |</div></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th style="text-align:left">left</th>
<th style="text-align:center">center</th>
<th style="text-align:right">right</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">aaaa</td>
<td style="text-align:center">bbbbbb</td>
<td style="text-align:right">ccccc</td>
</tr>
<tr>
<td style="text-align:left">a</td>
<td style="text-align:center">b</td>
<td style="text-align:right">c</td>
</tr>
</tbody>
</table>
<h1 id="五、内嵌HTML"><a href="#五、内嵌HTML" class="headerlink" title="五、内嵌HTML"></a>五、内嵌HTML</h1><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown，只要直接加标签就可以了。</p>
<p>注意 HTML 区块元素，比如 <code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code>、<code>&lt;p&gt;</code> 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 <code>&lt;p&gt;</code>标签。</p>
<h1 id="六、公式"><a href="#六、公式" class="headerlink" title="六、公式"></a>六、公式</h1><p>如果想要在Markdown文档中显示一个公式就需要先插入下面一句话，这实际上是插入了一个图片。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![公式名](http://latex.codecogs.com/png.latex?这里输入您的公式)</div></pre></td></tr></table></figure></p>
<p>上面这句话是插入一个png图片格式的公式，而下面这句话则是插入gif图片格式的公式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">![公式名](http://latex.codecogs.com/png.latex?这里输入您的公式)</div></pre></td></tr></table></figure></p>
<h1 id="七、转义"><a href="#七、转义" class="headerlink" title="七、转义"></a>七、转义</h1><p>Markdown符号用反斜杠\转义</p>
<hr>
<p>2017.08.15更新</p>
<hr>
<h1 id="八、横线"><a href="#八、横线" class="headerlink" title="八、横线"></a>八、横线</h1><p>在一行中用三个以上的星号(*)、减号(-)、下划线(_)来建立一个分隔线；除空格外行内不能有其他字符；（除第一个符号的左侧最多添加三个空格外）三个相同符号两侧可以添加任意多个空格。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol>
<li><a href="https://kennylee26.gitbooks.io/markdown/content/grammar/Inline-HTML.html" target="_blank" rel="external">Markdown教程</a></li>
<li><a href="https://segmentfault.com/markdown#articleHeader7" target="_blank" rel="external">Markdown 编辑器语法指南</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、代码&quot;&gt;&lt;a href=&quot;#一、代码&quot; class=&quot;headerlink&quot; title=&quot;一、代码&quot;&gt;&lt;/a&gt;一、代码&lt;/h1&gt;&lt;h2 id=&quot;代码区块&quot;&gt;&lt;a href=&quot;#代码区块&quot; class=&quot;headerlink&quot; title=&quot;代码区块&quot;&gt;&lt;/a&gt;代码区块&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;第一种，只要简单地缩进 4 个空格或是 1 个制表符就可以&lt;/li&gt;
&lt;li&gt;第二种，在代码段落的头部和尾部用```包围起来&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;行内代码块&quot;&gt;&lt;a href=&quot;#行内代码块&quot; class=&quot;headerlink&quot; title=&quot;行内代码块&quot;&gt;&lt;/a&gt;行内代码块&lt;/h2&gt;&lt;p&gt;用` `包围&lt;/p&gt;
&lt;h1 id=&quot;二、链接&quot;&gt;&lt;a href=&quot;#二、链接&quot; class=&quot;headerlink&quot; title=&quot;二、链接&quot;&gt;&lt;/a&gt;二、链接&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;文字链接 &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;[链接名称](http://链接网址)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;网址链接 &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&amp;lt;http://链接网址&amp;gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&quot;三、图片&quot;&gt;&lt;a href=&quot;#三、图片&quot; class=&quot;headerlink&quot; title=&quot;三、图片&quot;&gt;&lt;/a&gt;三、图片&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;行内式&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;![alt图片名称](http://图片网址)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;参考式&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;![alt图片名称][本地图片地址]&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;目前为止Markdown 还没有办法指定图片的宽高，如果需要，可以使用普通的&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;标签。&lt;br&gt;
    
    </summary>
    
      <category term="Markdown" scheme="http://happylg.cn/categories/Markdown/"/>
    
    
      <category term="Markdown" scheme="http://happylg.cn/tags/Markdown/"/>
    
  </entry>
  
  <entry>
    <title>Javascript相等性比较</title>
    <link href="http://happylg.cn/2017/08/04/js-equal/"/>
    <id>http://happylg.cn/2017/08/04/js-equal/</id>
    <published>2017-08-04T01:43:39.000Z</published>
    <updated>2017-08-19T06:37:33.870Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript有两种比较方式：严格比较运算符和转换类型比较运算符。对于严格比较运算符（<code>===</code>）来说，仅当两个操作数的类型相同且值相等为<code>true</code>，而对于被广泛使用的比较运算符（<code>==</code>）来说，会在进行比较之前，将两个操作数转换成相同的类型。对于关系运算符（比如 <code>&lt;=</code>）来说，会先将操作数转为原始值，使它们类型相同，再进行比较运算。</p>
<p>字符串比较则是使用基于标准字典的Unicode值来进行比较的。</p>
<h2 id="一、宽松相等"><a href="#一、宽松相等" class="headerlink" title="一、宽松相等(==)"></a>一、宽松相等(==)</h2><p>比较操作符会为两个不同类型的操作数转换类型，然后进行严格比较。当两个操作数都是对象时，JavaScript会比较其内部引用，当且仅当他们的引用指向内存中的相同对象（区域）时才相等，即他们在栈内存中的引用地址相同。</p>
<ul>
<li>当比较数字和字符串时，字符串会转换成数字值。 JavaScript 尝试将数字字面量转换为数字类型的值。 首先, 一个数学上的值会从数字字面量中衍生出来，然后得到被四舍五入后的数字类型的值。</li>
<li>如果其中一个操作数为布尔类型，那么布尔操作数如果为true，那么会转换为1，如果为false，会转换为整数0，即0。</li>
<li>如果是一个对象与数字或字符串向比较，JavaScript会尝试返回对象的默认值。操作符会尝试将对象转换为其原始值（一个字符串或数字值）通过方法valueOf和toString。如果尝试转换失败，会产生一个运行时错误。</li>
<li>注意：当且仅当与原始值比较时，对象会被转换为原始值。<strong>当两个操作数均为对象时，它们作为对象进行比较，仅当它们引用相同对象时返回true</strong>。</li>
</ul>
<p><img src="/img/非严格相等.png" alt="非严格相等比较" align="center"><br>在上面的表格中，<code>ToNumber(A)</code> 尝试在比较前将参数<code>A</code>转换为数字，这与<code>+A</code>（单目运算符+）的效果相同。通过尝试依次调用<code>A</code>的<code>A.toString</code>和<code>A.valueOf</code>方法，将参数<code>A</code>转换为原始值（<code>Primitive</code>）。<br>一般而言，根据 ECMAScript 规范，所有的对象都与<code>undefined</code>和<code>null</code>不相等。但是大部分浏览器允许非常窄的一类对象（即，所有页面中的<code>document.all</code>对象），在某些情况下，充当效仿<code>undefined</code>的角色。相等操作符就是在这样的一个背景下。因此，<code>IsFalsy(A)</code>方法的值为<code>true</code>，当且仅当<code>A</code>效仿<code>undefined</code>。在其他所有情况下，一个对象都不会等于<code>undefined</code>或<code>null</code>。<br><a id="more"></a></p>
<h2 id="二、一致-严格相等"><a href="#二、一致-严格相等" class="headerlink" title="二、一致/严格相等(===)"></a>二、一致/严格相等(===)</h2><p>一致运算符不会进行类型转换，仅当操作数严格相等时返回<code>true</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var num = 0;</div><div class="line">var obj = new String(&quot;0&quot;);</div><div class="line">var str = &quot;0&quot;;</div><div class="line">var b = false;</div><div class="line"></div><div class="line">console.log(num === num); // true</div><div class="line">console.log(obj === obj); // true</div><div class="line">console.log(str === str); // true</div><div class="line"></div><div class="line">console.log(num === obj); // false</div><div class="line">console.log(num === str); // false</div><div class="line">console.log(obj === str); // false</div><div class="line">console.log(null === undefined); // false</div><div class="line">console.log(obj === null); // false</div><div class="line">console.log(obj === undefined); // false</div></pre></td></tr></table></figure></p>
<p>对于除了数值之外的值，全等操作符使用明确的语义进行比较：一个值只与自身全等。对于数值，全等操作符使用略加修改的语义来处理两个特殊情况：第一个情况是，浮点数<code>0</code>是不分正负的。区分<code>+0</code>和<code>-0</code>在解决一些特定的数学问题时是必要的，但是大部分境况下我们并不用关心。全等操作符认为这两个值是全等的。第二个情况是，浮点数包含了<code>NaN</code>值，用来表示某些定义不明确的数学问题的解，例如：正无穷加负无穷。全等操作符认为<code>NaN</code>与其他任何值都不全等，包括它自己。（等式 (<code>x !== x</code>) 成立的唯一情况是 <code>x</code> 的值为<code>NaN</code>）</p>
<h2 id="三、Object-is-（ECMAScript-2015-ES6-新特性）"><a href="#三、Object-is-（ECMAScript-2015-ES6-新特性）" class="headerlink" title="三、Object.is （ECMAScript 2015/ ES6 新特性）"></a>三、Object.is （ECMAScript 2015/ ES6 新特性）</h2><p><code>Object.is</code>的行为方式与三等式相同，但是对于<code>NaN</code>和<code>-0</code>和<code>+0</code>进行特殊处理，所以最后两个不相同，而<code>Object.is（NaN，NaN）</code>将为<code>true</code>。(通常使用双等号或三等于将<code>NaN</code>与<code>NaN</code>进行比较结果为<code>false</code>，因为IEEE 754如是说。)除了<code>+0</code>和<code>-0</code>,其他时候避免使用<code>Object.is</code>,包括<code>NaN</code>。</p>
<h2 id="四、判等表"><a href="#四、判等表" class="headerlink" title="四、判等表"></a>四、判等表</h2><table>
<thead>
<tr>
<th>x</th>
<th>y</th>
<th>==</th>
<th>===</th>
<th>Object.is</th>
</tr>
</thead>
<tbody>
<tr>
<td>undefined</td>
<td>undefined</td>
<td>true</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>null</td>
<td>null</td>
<td>true</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>true</td>
<td>true</td>
<td>true</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>false</td>
<td>false</td>
<td>true</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>“foo”</td>
<td>“foo”</td>
<td>true</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>{ foo: “bar” }</td>
<td>x</td>
<td>true</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>true</td>
<td>true</td>
<td>true</td>
</tr>
<tr>
<td>+0</td>
<td>-0</td>
<td>true</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>0</td>
<td>false</td>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>“”</td>
<td>false</td>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>“”</td>
<td>0</td>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>“0”</td>
<td>0</td>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>“17”</td>
<td>17</td>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>[1,2]</td>
<td>“1,2”</td>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>new String(“foo”)</td>
<td>“foo”</td>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>null</td>
<td>undefined</td>
<td>true</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>null</td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>undefined</td>
<td>false</td>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>{ foo: “bar” }</td>
<td>{ foo: “bar” }</td>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>new String(“foo”)</td>
<td>new String(“foo”)</td>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>0</td>
<td>null</td>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>0</td>
<td>NaN</td>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>“foo”</td>
<td>NaN</td>
<td>false</td>
<td>false</td>
<td>false</td>
</tr>
<tr>
<td>NaN</td>
<td>NaN</td>
<td>false</td>
<td>false</td>
<td>true</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">// true 两个操作数均为String</div><div class="line">&apos;foo&apos; === &apos;foo&apos;</div><div class="line"></div><div class="line">var a = new String(&apos;foo&apos;);</div><div class="line">var b = new String(&apos;foo&apos;);</div><div class="line"></div><div class="line">// false a,b对象引用不同</div><div class="line">a == b </div><div class="line"></div><div class="line">// false a,b均为对象，但是引用不同</div><div class="line">a === b </div><div class="line"></div><div class="line">// true 操作数类型不同，对象a转换为String类型</div><div class="line">a == &apos;foo&apos;</div></pre></td></tr></table></figure>
<h2 id="五、参见"><a href="#五、参见" class="headerlink" title="五、参见"></a>五、参见</h2><h3 id="比较表"><a href="#比较表" class="headerlink" title="==比较表"></a><code>==</code>比较表</h3><p><img src="/img/js比较表.png" alt="js比较表" align="center"></p>
<hr>
<h3 id="if-比较表-2017-8-6新增"><a href="#if-比较表-2017-8-6新增" class="headerlink" title="if()比较表(2017.8.6新增)"></a><code>if()</code>比较表(2017.8.6新增)</h3><p><img src="/img/if比较表.png" alt="if比较表" align="center"></p>
<p><a href="http://dorey.github.io/JavaScript-Equality-Table/" target="_blank" rel="external">Javascript比较表</a></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ol>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Comparison_Operators" target="_blank" rel="external">MDN比较运算符</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness" target="_blank" rel="external">MDN相等性比较</a></li>
<li><a href="http://www.ecma-international.org/ecma-262/5.1/#sec-11.9" target="_blank" rel="external">ECMAScript官方文件</a></li>
<li><a href="http://dorey.github.io/JavaScript-Equality-Table/" target="_blank" rel="external">js比较表</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript有两种比较方式：严格比较运算符和转换类型比较运算符。对于严格比较运算符（&lt;code&gt;===&lt;/code&gt;）来说，仅当两个操作数的类型相同且值相等为&lt;code&gt;true&lt;/code&gt;，而对于被广泛使用的比较运算符（&lt;code&gt;==&lt;/code&gt;）来说，会在进行比较之前，将两个操作数转换成相同的类型。对于关系运算符（比如 &lt;code&gt;&amp;lt;=&lt;/code&gt;）来说，会先将操作数转为原始值，使它们类型相同，再进行比较运算。&lt;/p&gt;
&lt;p&gt;字符串比较则是使用基于标准字典的Unicode值来进行比较的。&lt;/p&gt;
&lt;h2 id=&quot;一、宽松相等&quot;&gt;&lt;a href=&quot;#一、宽松相等&quot; class=&quot;headerlink&quot; title=&quot;一、宽松相等(==)&quot;&gt;&lt;/a&gt;一、宽松相等(==)&lt;/h2&gt;&lt;p&gt;比较操作符会为两个不同类型的操作数转换类型，然后进行严格比较。当两个操作数都是对象时，JavaScript会比较其内部引用，当且仅当他们的引用指向内存中的相同对象（区域）时才相等，即他们在栈内存中的引用地址相同。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当比较数字和字符串时，字符串会转换成数字值。 JavaScript 尝试将数字字面量转换为数字类型的值。 首先, 一个数学上的值会从数字字面量中衍生出来，然后得到被四舍五入后的数字类型的值。&lt;/li&gt;
&lt;li&gt;如果其中一个操作数为布尔类型，那么布尔操作数如果为true，那么会转换为1，如果为false，会转换为整数0，即0。&lt;/li&gt;
&lt;li&gt;如果是一个对象与数字或字符串向比较，JavaScript会尝试返回对象的默认值。操作符会尝试将对象转换为其原始值（一个字符串或数字值）通过方法valueOf和toString。如果尝试转换失败，会产生一个运行时错误。&lt;/li&gt;
&lt;li&gt;注意：当且仅当与原始值比较时，对象会被转换为原始值。&lt;strong&gt;当两个操作数均为对象时，它们作为对象进行比较，仅当它们引用相同对象时返回true&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;/img/非严格相等.png&quot; alt=&quot;非严格相等比较&quot; align=&quot;center&quot;&gt;&lt;br&gt;在上面的表格中，&lt;code&gt;ToNumber(A)&lt;/code&gt; 尝试在比较前将参数&lt;code&gt;A&lt;/code&gt;转换为数字，这与&lt;code&gt;+A&lt;/code&gt;（单目运算符+）的效果相同。通过尝试依次调用&lt;code&gt;A&lt;/code&gt;的&lt;code&gt;A.toString&lt;/code&gt;和&lt;code&gt;A.valueOf&lt;/code&gt;方法，将参数&lt;code&gt;A&lt;/code&gt;转换为原始值（&lt;code&gt;Primitive&lt;/code&gt;）。&lt;br&gt;一般而言，根据 ECMAScript 规范，所有的对象都与&lt;code&gt;undefined&lt;/code&gt;和&lt;code&gt;null&lt;/code&gt;不相等。但是大部分浏览器允许非常窄的一类对象（即，所有页面中的&lt;code&gt;document.all&lt;/code&gt;对象），在某些情况下，充当效仿&lt;code&gt;undefined&lt;/code&gt;的角色。相等操作符就是在这样的一个背景下。因此，&lt;code&gt;IsFalsy(A)&lt;/code&gt;方法的值为&lt;code&gt;true&lt;/code&gt;，当且仅当&lt;code&gt;A&lt;/code&gt;效仿&lt;code&gt;undefined&lt;/code&gt;。在其他所有情况下，一个对象都不会等于&lt;code&gt;undefined&lt;/code&gt;或&lt;code&gt;null&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="Javascript" scheme="http://happylg.cn/categories/Javascript/"/>
    
    
      <category term="js" scheme="http://happylg.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>Javascript中的Array对象总结</title>
    <link href="http://happylg.cn/2017/08/03/js-Array/"/>
    <id>http://happylg.cn/2017/08/03/js-Array/</id>
    <published>2017-08-03T10:23:35.000Z</published>
    <updated>2017-08-19T06:37:33.864Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、属性"><a href="#一、属性" class="headerlink" title="一、属性"></a>一、属性</h1><h2 id="Array-length"><a href="#Array-length" class="headerlink" title="Array.length"></a>Array.length</h2><p><code>length</code>属性的值是一个 0 到 2^32-1的整数。</p>
<p>你可以通过减小<code>length</code>属性的值来截短一个数组，但不能通过增大<code>length</code>属性的值来延长这个数组</p>
<h2 id="Array-prototype"><a href="#Array-prototype" class="headerlink" title="Array.prototype"></a>Array.prototype</h2><p><code>Array.prototype</code>属性表示<code>Array</code>构造函数的原型;<code>Array.prototype</code>本身也是一个<code>Array</code></p>
<h1 id="二、方法"><a href="#二、方法" class="headerlink" title="二、方法"></a>二、方法</h1><h2 id="Array-prototype-concat"><a href="#Array-prototype-concat" class="headerlink" title="Array.prototype.concat()"></a>Array.prototype.concat()</h2><p><strong>不改变数组</strong></p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code>var new_array = old_array.concat(value1[, value2[, ...[, valueN]]])
</code></pre><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p><code>valueN</code>需要与原数组合并的数组或非数组值。详见下文。</p>
<h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>新的<code>Array</code>实例。</p>
<h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p><code>concat</code>方法将创建一个新的数组，然后将调用它的对象(<code>this</code>指向的对象)中的元素以及所有参数中的数组类型的参数中的元素以及非数组类型的参数本身按照顺序放入这个新数组,并返回该数组.</p>
<p><code>concat</code>方法并不修改调用它的对象(<code>this</code>指向的对象) 和参数中的各个数组本身的值,而是将他们的每个元素拷贝一份放在组合成的新数组中.原数组中的元素有两种被拷贝的方式:</p>
<ul>
<li>对象引用(非对象直接量):<code>concat</code>方法会复制对象引用放到组合的新数组里,原数组和新数组中的对象引用都指向同一个实际的对象,所以,当实际的对象被修改时,两个数组也同时会被修改.</li>
<li>字符串和数字(是原始值,而不是包装原始值的<code>String</code>和<code>Number</code>对象):<code>concat</code>方法会复制字符串和数字的值放到新数组里</li>
</ul>
<a id="more"></a>
<h2 id="Array-prototype-filter"><a href="#Array-prototype-filter" class="headerlink" title="Array.prototype.filter()"></a>Array.prototype.filter()</h2><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><pre><code>var new_array = arr.filter(callback[, thisArg])
</code></pre><h3 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h3><p><code>callback</code>用来测试数组的每个元素的函数。调用时使用参数<code>(element, index, array)</code>。返回<code>true</code>表示保留该元素（通过测试），<code>false</code>则不保留。<br><code>thisArg</code>可选。执行<code>callback</code>时的用于<code>this</code>的值。</p>
<h3 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h3><p>一个新的通过测试的元素的集合的数组</p>
<h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p><code>filter</code>为数组中的每个元素调用一次<code>callback</code>函数，并利用所有使得<code>callback</code>返回<code>true</code>或等价于<code>true</code>的值的元素创建一个新数组。<code>callback</code>只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用。那些没有通过<code>callback</code>测试的元素会被跳过，不会被包含在新数组中。<br><code>callback</code>被调用时传入三个参数：</p>
<ol>
<li>元素的值</li>
<li>元素的索引</li>
<li>被遍历的数组</li>
</ol>
<p>如果为<code>filter</code>提供一个<code>thisArg</code>参数，则它会被作为<code>callback</code>被调用时的<code>this</code>值。否则，<code>callback</code>的<code>this</code>值在非严格模式下将是全局对象，严格模式下为<code>undefined</code>。</p>
<p><strong>filter不会改变原数组。</strong><br><code>filter</code>遍历的元素范围在第一次调用<code>callback</code>之前就已经确定了。在调用<code>filter</code>之后被添加到数组中的元素不会被filter遍历到。如果已经存在的元素被改变了，则他们传入<code>callback</code>的值是<code>filter</code>遍历到它们那一刻的值。<strong>被删除或从来未被赋值的元素不会被遍历到。</strong></p>
<h2 id="Array-prototype-find"><a href="#Array-prototype-find" class="headerlink" title="Array.prototype.find()"></a>Array.prototype.find()</h2><h2 id="Array-prototype-forEach"><a href="#Array-prototype-forEach" class="headerlink" title="Array.prototype.forEach()"></a>Array.prototype.forEach()</h2><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">array.forEach(callback(currentValue, index, array)&#123;</div><div class="line">	//do something</div><div class="line">&#125;, this)</div><div class="line">array.forEach(callback[, thisArg])</div></pre></td></tr></table></figure>
<h3 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h3><p><code>callback</code>为数组中每个元素执行的函数，该函数接收三个参数：</p>
<ul>
<li><code>currentValue</code>(当前值)数组中正在处理的当前元素。</li>
<li><code>index</code>(索引)数组中正在处理的当前元素的索引。</li>
<li><code>array``forEach()</code>方法正在操作的数组。</li>
</ul>
<p><code>thisArg</code>可选参数。当执行回调 函数时用作<code>this</code>的值(参考对象)。</p>
<h3 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h3><p><code>undefined</code></p>
<h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p><code>forEach</code>方法按升序为数组中含有效值的每一项执行一次<code>callback</code>函数，那些已删除（使用<code>delete</code>方法等情况）或者未初始化的项将被跳过（但不包括那些值为<code>undefined</code>的项）（例如在稀疏数组上）。<br><code>callback</code>函数会被依次传入三个参数：</p>
<ol>
<li>数组当前项的值</li>
<li>数组当前项的索引</li>
<li>数组对象本身</li>
</ol>
<p>如果给<code>forEach</code>传递了<code>thisArg</code>参数，当调用时，它将被传给<code>callback</code>函数，作为它的<code>this</code>值。否则，将会传入<code>undefined</code>作为它的<code>this</code>值。<code>callback</code>函数最终可观察到<code>this</code>值，这取决于函数观察到<code>this</code>的常用规则。<br><code>forEach</code>遍历的范围在第一次调用<code>callback</code>前就会确定。调用<code>forEach</code>后添加到数组中的项不会被<code>callback</code>访问到。如果已经存在的值被改变，则传递给<code>callback</code>的值是<code>forEach</code>遍历到他们那一刻的值。已删除的项不会被遍历到。如果已访问的元素在迭代时被删除了(例如使用<code>shift()</code>) ，之后的元素将被跳过.<br><code>forEach()</code>为每个数组元素执行<code>callback</code>函数；不像<code>map()</code>或者<code>reduce()</code> ，它总是返回<code>undefined</code>值，并且不可链式调用。典型用例是在一个链的最后执行副作用。</p>
<h2 id="Array-prototype-indexOf"><a href="#Array-prototype-indexOf" class="headerlink" title="Array.prototype.indexOf()"></a>Array.prototype.indexOf()</h2><p>indexOf()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。</p>
<h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">arr.indexOf(searchElement)</div><div class="line">arr.indexOf(searchElement[, fromIndex = 0])</div></pre></td></tr></table></figure>
<h3 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h3><p><code>searchElement</code>要查找的元素。<br><code>fromIndex</code>开始查找的位置。如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回-1。如果参数中提供的索引值是一个负值，则将其作为数组末尾的一个抵消，即-1表示从最后一个元素开始查找，-2表示从倒数第二个元素开始查找，以此类推。注意：如果参数中提供的索引值是一个负值，仍然从前向后查询数组。如果抵消后的索引值仍小于0，则整个数组都将会被查询。其默认值为0.</p>
<h3 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h3><p>首个被找到的元素在数组中的索引位置;若没有找到则返回-1</p>
<h2 id="Array-prototype-join"><a href="#Array-prototype-join" class="headerlink" title="Array.prototype.join()"></a>Array.prototype.join()</h2><p><strong>不改变数组</strong></p>
<h2 id="Array-prototype-keys"><a href="#Array-prototype-keys" class="headerlink" title="Array.prototype.keys()"></a>Array.prototype.keys()</h2><h2 id="Array-prototype-values"><a href="#Array-prototype-values" class="headerlink" title="Array.prototype.values()"></a>Array.prototype.values()</h2><h2 id="Array-prototype-entries"><a href="#Array-prototype-entries" class="headerlink" title="Array.prototype.entries()"></a>Array.prototype.entries()</h2><h2 id="Array-prototype-pop"><a href="#Array-prototype-pop" class="headerlink" title="Array.prototype.pop()"></a>Array.prototype.pop()</h2><h2 id="Array-prototype-push"><a href="#Array-prototype-push" class="headerlink" title="Array.prototype.push()"></a>Array.prototype.push()</h2><h2 id="Array-prototype-shift"><a href="#Array-prototype-shift" class="headerlink" title="Array.prototype.shift()"></a>Array.prototype.shift()</h2><h2 id="Array-prototype-unshift"><a href="#Array-prototype-unshift" class="headerlink" title="Array.prototype.unshift()"></a>Array.prototype.unshift()</h2><h2 id="Array-prototype-map"><a href="#Array-prototype-map" class="headerlink" title="Array.prototype.map()"></a>Array.prototype.map()</h2><h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let array = arr.map(function callback(currentValue, index, array) &#123; </div><div class="line">   	// Return element for new_array </div><div class="line">&#125;[, thisArg])</div></pre></td></tr></table></figure>
<h3 id="参数-4"><a href="#参数-4" class="headerlink" title="参数"></a>参数</h3><p><code>callback</code>生成新数组元素的函数，使用三个参数：<br><code>currentValue``callback</code>的第一个参数，数组中正在处理的当前元素。<br><code>index``callback</code>的第二个参数，数组中正在处理的当前元素的索引。<br><code>array``callback</code>的第三个参数，<code>map</code>方法被调用的数组。<br><code>thisArg</code>可选的。执行<code>callback</code>函数时,使用的<code>this</code>值。</p>
<h3 id="返回值-4"><a href="#返回值-4" class="headerlink" title="返回值"></a>返回值</h3><p>一个新数组，每个元素都是回调函数的结果。</p>
<h3 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h3><p><code>map</code>方法会给原数组中的每个元素都按顺序调用一次<code>callback</code>函数。<code>callback</code>每次执行后的返回值（包括<code>undefined</code>）组合起来形成一个新数组。<code>callback</code>函数只会在有值的索引上被调用；那些从来没被赋过值或者使用<code>delete</code>删除的索引则不会被调用。<br><code>callback</code>函数会被自动传入三个参数：数组元素，元素索引，原数组本身。<br>如果<code>thisArg</code>参数有值，则每次<code>callback</code>函数被调用的时候，<code>this</code>都会指向<code>thisArg</code>参数上的这个对象。如果省略了<code>thisArg</code>参数,或者赋值为<code>null</code>或<code>undefined</code>，则<code>this</code>指向全局对象。<br><strong>map不修改调用它的原数组本身</strong>（当然可以在<code>callback</code>执行时改变原数组）。<br>使用<code>map</code>方法处理数组时，数组元素的范围是在<code>callback</code>方法第一次调用之前就已经确定了。在<code>map</code>方法执行的过程中：原数组中新增加的元素将不会被<code>callback</code>访问到；若已经存在的元素被改变或删除了，则它们的传递到<code>callback</code>的值是<code>map</code>方法遍历到它们的那一时刻的值；<strong>而被删除的元素将不会被访问到。</strong></p>
<h2 id="Array-prototype-reduce"><a href="#Array-prototype-reduce" class="headerlink" title="Array.prototype.reduce()"></a>Array.prototype.reduce()</h2><h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><pre><code>array.reduce(function(accumulator, currentValue, currentIndex, array), initialValue)
</code></pre><h3 id="参数-5"><a href="#参数-5" class="headerlink" title="参数"></a>参数</h3><p><code>callback</code>执行数组中每个值的函数，包含四个参数<br><code>accumulator</code>上一次调用回调返回的值，或者是提供的初始值<code>initialValue</code><br><code>currentValue</code>数组中正在处理的元素<br><code>currentIndex</code>数据中正在处理的元素索引,如果提供了<code>initialValue</code>,从0开始;否则从1开始<br><code>array</code>调用<code>reduce</code>的数组<br><code>initialValue</code>可选项，其值用于第一次调用<code>callback</code>的第一个参数。如果没有设置初始值，则将数组中的第一个元素作为初始值。<strong>空数组调用<code>reduce</code>时没有设置初始值将会报错。</strong></p>
<h3 id="返回值-5"><a href="#返回值-5" class="headerlink" title="返回值"></a>返回值</h3><p>函数累计处理的结果</p>
<h3 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h3><p><code>reduce</code>为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：<br><code>accumulator</code>初始值（或者上一次回调函数的返回值）<br><code>currentValue</code>当前元素值<br><code>currentIndex</code>当前索引<br><code>array</code>调用<code>reduce</code>的数组。<br>回调函数第一次执行时，<code>accumulator</code>和<code>currentValue</code>的取值有两种情况：调用<code>reduce</code>时提供<code>initialValue</code>，<code>accumulator</code>取值为<code>initialValue</code>，<code>currentValue</code>取数组中的第一个值；没有提供<code>initialValue</code>，<code>accumulator</code>取数组中的第一个值，<code>currentValue</code>取数组中的第二个值。<br><strong>注意</strong>: </p>
<ol>
<li>不提供<code>initialValue</code>，<code>reduce</code>会从索引1的地方开始执行<code>callback</code>方法，跳过第一个索引。提供<code>initialValue</code>，从索引0开始。</li>
<li>如果数组为空并且没有提供<code>initialValue</code>，会抛出<code>TypeError</code>。如果数组仅有一个元素（无论位置如何）并且没有提供<code>initialValue</code>，或者有提供<code>initialValue</code>但是数组为空，那么此唯一值将被返回并且<code>callback</code>不会被执行。</li>
</ol>
<h2 id="Array-prototype-reduceRight"><a href="#Array-prototype-reduceRight" class="headerlink" title="Array.prototype.reduceRight()"></a>Array.prototype.reduceRight()</h2><h2 id="Array-prototype-sort"><a href="#Array-prototype-sort" class="headerlink" title="Array.prototype.sort()"></a>Array.prototype.sort()</h2><p><strong>改变数组</strong></p>
<h2 id="Array-prototype-reverse"><a href="#Array-prototype-reverse" class="headerlink" title="Array.prototype.reverse()"></a>Array.prototype.reverse()</h2><p><strong>改变数组</strong></p>
<h2 id="Array-prototype-slice"><a href="#Array-prototype-slice" class="headerlink" title="Array.prototype.slice()"></a>Array.prototype.slice()</h2><p><strong>注意:’slice()’为浅拷贝,不改变数组</strong></p>
<h3 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h3><pre><code>arr.slice(begin,end)
</code></pre><h3 id="参数-6"><a href="#参数-6" class="headerlink" title="参数"></a>参数</h3><p><code>begin</code>可选，从索引处开始提取，默认为0。如果参数为负数-a，从倒数第a个元素开始提取。<code>slice(-2)</code>表示从倒数第二提取到倒数第一(包含最后一个元素)。<br><code>end</code>可选，从索引处结束提取。<code>slice(begin,end)</code>包含<code>begin</code>但不包含<code>end</code>。如果为负数表示在倒数第几个结束提取，slice(-2,-1),不包含最后一个。<br><code>end</code>省略或大于数组长度，一直提取到原数组末尾</p>
<h3 id="返回值-6"><a href="#返回值-6" class="headerlink" title="返回值"></a>返回值</h3><p>一个含有提取元素的新数组</p>
<h3 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h3><p><code>slice()</code>不会修改数组，只会浅拷贝，规则如下：</p>
<ul>
<li>对象引用(非对象直接量):<code>concat</code>方法会复制对象引用放到组合的新数组里,原数组和新数组中的对象引用都指向同一个实际的对象,所以,当实际的对象被修改时,两个数组也同时会被修改.</li>
<li>对于字符串、数字及布尔值来说（不是<code>String</code>、<code>Number</code>或者<code>Boolean</code>对象），<code>slice</code>会拷贝这些值到新的数组里。在别的数组里修改这些字符串或数字或是布尔值，将不会影响另一个数组。</li>
</ul>
<p>如果向两个数组任一中添加了新元素，则另一个不会受到影响。</p>
<h2 id="Array-prototype-splice"><a href="#Array-prototype-splice" class="headerlink" title="Array.prototype.splice()"></a>Array.prototype.splice()</h2><p><strong>改变数组，返回被删除元素组成的数组</strong></p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array" target="_blank" rel="external">MDN</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;一、属性&quot;&gt;&lt;a href=&quot;#一、属性&quot; class=&quot;headerlink&quot; title=&quot;一、属性&quot;&gt;&lt;/a&gt;一、属性&lt;/h1&gt;&lt;h2 id=&quot;Array-length&quot;&gt;&lt;a href=&quot;#Array-length&quot; class=&quot;headerlink&quot; title=&quot;Array.length&quot;&gt;&lt;/a&gt;Array.length&lt;/h2&gt;&lt;p&gt;&lt;code&gt;length&lt;/code&gt;属性的值是一个 0 到 2^32-1的整数。&lt;/p&gt;
&lt;p&gt;你可以通过减小&lt;code&gt;length&lt;/code&gt;属性的值来截短一个数组，但不能通过增大&lt;code&gt;length&lt;/code&gt;属性的值来延长这个数组&lt;/p&gt;
&lt;h2 id=&quot;Array-prototype&quot;&gt;&lt;a href=&quot;#Array-prototype&quot; class=&quot;headerlink&quot; title=&quot;Array.prototype&quot;&gt;&lt;/a&gt;Array.prototype&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Array.prototype&lt;/code&gt;属性表示&lt;code&gt;Array&lt;/code&gt;构造函数的原型;&lt;code&gt;Array.prototype&lt;/code&gt;本身也是一个&lt;code&gt;Array&lt;/code&gt;&lt;/p&gt;
&lt;h1 id=&quot;二、方法&quot;&gt;&lt;a href=&quot;#二、方法&quot; class=&quot;headerlink&quot; title=&quot;二、方法&quot;&gt;&lt;/a&gt;二、方法&lt;/h1&gt;&lt;h2 id=&quot;Array-prototype-concat&quot;&gt;&lt;a href=&quot;#Array-prototype-concat&quot; class=&quot;headerlink&quot; title=&quot;Array.prototype.concat()&quot;&gt;&lt;/a&gt;Array.prototype.concat()&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;不改变数组&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;var new_array = old_array.concat(value1[, value2[, ...[, valueN]]])
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;参数&quot;&gt;&lt;a href=&quot;#参数&quot; class=&quot;headerlink&quot; title=&quot;参数&quot;&gt;&lt;/a&gt;参数&lt;/h3&gt;&lt;p&gt;&lt;code&gt;valueN&lt;/code&gt;需要与原数组合并的数组或非数组值。详见下文。&lt;/p&gt;
&lt;h3 id=&quot;返回值&quot;&gt;&lt;a href=&quot;#返回值&quot; class=&quot;headerlink&quot; title=&quot;返回值&quot;&gt;&lt;/a&gt;返回值&lt;/h3&gt;&lt;p&gt;新的&lt;code&gt;Array&lt;/code&gt;实例。&lt;/p&gt;
&lt;h3 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描述&quot;&gt;&lt;/a&gt;描述&lt;/h3&gt;&lt;p&gt;&lt;code&gt;concat&lt;/code&gt;方法将创建一个新的数组，然后将调用它的对象(&lt;code&gt;this&lt;/code&gt;指向的对象)中的元素以及所有参数中的数组类型的参数中的元素以及非数组类型的参数本身按照顺序放入这个新数组,并返回该数组.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;concat&lt;/code&gt;方法并不修改调用它的对象(&lt;code&gt;this&lt;/code&gt;指向的对象) 和参数中的各个数组本身的值,而是将他们的每个元素拷贝一份放在组合成的新数组中.原数组中的元素有两种被拷贝的方式:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象引用(非对象直接量):&lt;code&gt;concat&lt;/code&gt;方法会复制对象引用放到组合的新数组里,原数组和新数组中的对象引用都指向同一个实际的对象,所以,当实际的对象被修改时,两个数组也同时会被修改.&lt;/li&gt;
&lt;li&gt;字符串和数字(是原始值,而不是包装原始值的&lt;code&gt;String&lt;/code&gt;和&lt;code&gt;Number&lt;/code&gt;对象):&lt;code&gt;concat&lt;/code&gt;方法会复制字符串和数字的值放到新数组里&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Javascript" scheme="http://happylg.cn/categories/Javascript/"/>
    
    
      <category term="js" scheme="http://happylg.cn/tags/js/"/>
    
  </entry>
  
</feed>
