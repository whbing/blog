<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[NexT主题升级]]></title>
    <url>%2F2017%2F08%2F19%2Fnext-theme-upgrade%2F</url>
    <content type="text"><![CDATA[目前升级 NexT 主题的时候并不是非常的流畅。若使用 git pull 的方式，很多时候可能会产生冲突；而下载新版本覆盖安装的方式又需要手动合并主题的 _config.yml 文件。 在此修改之前， NexT 建议将配置分离，一部分在 站点的配置文件中，另外一部分在主题的配置文件中。将需要自定的选项放置在 站点配置文件中，从而脱离避免更新主题时可能遇到的麻烦。这种方式是可行，但是有一些缺点： 配置分离成了两个部分用户可能会疑惑一些选项该放置在哪里比较合适为了解决这个问题， NexT 将会使用 Hexo 的 Data Files 。然而由于 Data Files 是在 Hexo 3 版本时引进的，所以要使用这个特性，需要 Hexo 的版本不低于 3。 特性通过这个特性，你可以将所有的主题配置放置在站点的 source/_data/next.yml 文件中。原先放置在 站点配置文件 中的选项可以迁移到新的位置，同时，主题配置文件可以不用做任何修改。若后续版本有配置相关的改动时，你仅需在 next.yml 中做相应调整即可。 使用请先确保你所使用的 Hexo 版本在 3 以上在站点的 source/_data 目录下新建 next.yml 文件（_data目录可能需要新建）迁移站点配置文件和主题配置文件中的配置到 next.yml 中 参考文献： NexT主题升级]]></content>
      <categories>
        <category>建站日志</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里巴巴在线笔试]]></title>
    <url>%2F2017%2F08%2F17%2Falibaba-interview%2F</url>
    <content type="text"><![CDATA[前端题目利用面向对象思想完成买家信息删除功能，每一条买家信息包含 姓名 (name) 性别 (sex) 电话号码 (number) 省份 (province) 要求 不能借助任何三方库，需使用原生代码实现 结合给出的基本代码结构，在下方2处code here处补充代码，完成买家信息的删除功能，注意此页面需要在手机上清晰显示。 js代码可任意调整，例如可使用es6语法完成 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!--code here--&gt; &lt;title&gt;demo&lt;/title&gt; &lt;style&gt; * &#123; padding: 0; margin: 0; &#125; .head, li div &#123; display: inline-block; width: 70px; text-align: center; &#125; li .id, li .sex, .id, .sex &#123; width: 15px; &#125; li .name, .name &#123; width: 40px; &#125; li .tel, .tel &#123; width: 90px; &#125; li .del, .del &#123; width: 15px; &#125; ul &#123; list-style: none; &#125; .user-delete &#123; cursor: pointer; &#125; @media screen and (max-width: 768px) &#123; //宽度小于768px时 .head, li div &#123; display: inline-block; width: 23.3%; text-align: center; &#125; li .id, li .sex, .id, .sex &#123; width: 5%; &#125; li .name, .name &#123; width: 13.3%; &#125; li .tel, .tel &#123; width: 30%; &#125; li .del, .del &#123; width: 5%; &#125; ul &#123; list-style: none; &#125; .user-delete &#123; cursor: pointer; &#125; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;J_container&quot;&gt; &lt;div class=&quot;record-head&quot;&gt; &lt;div class=&quot;head id&quot;&gt;序号&lt;/div&gt; &lt;div class=&quot;head name&quot;&gt;姓名&lt;/div&gt; &lt;div class=&quot;head sex&quot;&gt;性别&lt;/div&gt; &lt;div class=&quot;head tel&quot;&gt;电话号码&lt;/div&gt; &lt;div class=&quot;head province&quot;&gt;省份&lt;/div&gt; &lt;div class=&quot;head&quot;&gt;操作&lt;/div&gt; &lt;/div&gt; &lt;ul id=&quot;J_List&quot;&gt; &lt;li&gt; &lt;div class=&quot;id&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;name&quot;&gt;张三&lt;/div&gt; &lt;div class=&quot;sex&quot;&gt;男&lt;/div&gt; &lt;div class=&quot;tel&quot;&gt;13788888888&lt;/div&gt; &lt;div class=&quot;province&quot;&gt;浙江&lt;/div&gt; &lt;div class=&quot;user-delete&quot;&gt;删除&lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;div class=&quot;id&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;name&quot;&gt;李四&lt;/div&gt; &lt;div class=&quot;sex&quot;&gt;女&lt;/div&gt; &lt;div class=&quot;tel&quot;&gt;13788887777&lt;/div&gt; &lt;div class=&quot;province&quot;&gt;四川&lt;/div&gt; &lt;div class=&quot;user-delete&quot;&gt;删除&lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;div class=&quot;id&quot;&gt;3&lt;/div&gt; &lt;div class=&quot;name&quot;&gt;王二&lt;/div&gt; &lt;div class=&quot;sex&quot;&gt;男&lt;/div&gt; &lt;div class=&quot;tel&quot;&gt;13788889999&lt;/div&gt; &lt;div class=&quot;province&quot;&gt;广东&lt;/div&gt; &lt;div class=&quot;user-delete&quot;&gt;删除&lt;/div&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script&gt; var ul = document.getElementById(&quot;J_List&quot;); var del = document.getElementsByClassName(&apos;user-delete&apos;); for (let i = 0; i &lt; del.length; i++) &#123; del[i].onclick = function(event) &#123; ul.removeChild(event.target.parentNode); &#125;; &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 测试题目菜鸟网络仓库有一排小货架，共有N个，货架的底部是空的，现在智能机器人在某个货架下，小明写了一个非常简单的智能机器人移动程序,逻辑如下：每过1分钟，智能机器人必须随机的从一个货架下移动到相邻的一个货架下。比如刚开始智能机器人在第4个货架下，过1分钟后，智能机器人可能会在第3个货架下或者在第5个货架下。如果刚开始时智能机器人在第1个货架下，过1分钟以后，智能机器人一定会在第2个货架下。现在告诉你货架的数目N，已经智能机器人开始所在的位置P，小明很想知道，在M分钟后，智能机器人到达第T货架，一共有多少种行走方案。请帮小明算一算。输入：NPMT输出：一共有多少种行走方案 代码12345678910111213141516171819202122232425262728// javaimport java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); while (sc.hasNext()) &#123; int N = sc.nextInt();// 货架数量 int P = sc.nextInt();// 起始位置 int M = sc.nextInt();// 时间 int T = sc.nextInt();// 结束位置 int res = solution(N, P, M, T); System.out.println(res); &#125; &#125; public static int solution(int n, int p, int m, int t) &#123; int[][] dp = new int[m + 1][n + 2];// 起始末尾添加两列，防止越界 dp[0][p] = 1; for (int i = 1; i &lt; dp.length; i++) &#123; // 时间从1开始，dp[0][p]为1，其他均为0 for (int j = 1; j &lt; dp[0].length - 1; j++) &#123;// 位置从1开始到length-2是为了防止数组越界 dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1]; &#125; &#125; return dp[m][t]; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344// jsvar readline = require(&apos;readline&apos;);const rl = readline.createInterface(&#123; input: process.stdin, output: process.stdout&#125;);var length = 4;var flag = 0;var arr = [];rl.on(&apos;line&apos;, function (input) &#123; flag++; input = parseInt(input); arr.push(input); if (flag == length) &#123; var res = soulution(arr); console.log(res); flag = 0; arr = []; &#125;&#125;).on(&apos;close&apos;, function () &#123;&#125;);function soulution(arr) &#123; var n = arr[0];//货架数量 var p = arr[1];//初始位置 var m = arr[2];//经过时间 var t = arr[3];//结束位置 var dp = []; for (var i = 0; i &lt; m + 1; i++) &#123; dp[i] = new Array; for (var j = 0; j &lt; n + 2; j++) &#123; dp[i][j] = 0; &#125; &#125; dp[0][p] = 1; for (var i = 1; i &lt; dp.length; i++) &#123; for (var j = 1; j &lt; dp[0].length - 1; j++) &#123; //1-n防止数组越界 dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j + 1]; &#125; &#125; return dp[m][t];&#125;]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>html</tag>
        <tag>css</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《上帝掷骰子吗？——量子力学史话》读书笔记]]></title>
    <url>%2F2017%2F08%2F14%2Fdoes-god-throw-dice%2F</url>
    <content type="text"><![CDATA[2017.8.5开始读，2017.8.12日读完这是一本关于量子力学的历史的科普性著作 2017.8.14更新 经典物理的黄金时代光的本质波动说和粒子说 波动粒子之争第一次波粒战争主要参与人物： 粒子说：牛顿 《光学》，色散，牛顿环(明暗条纹)，衍射 质疑如果光是波，为什么无法像声音那样绕开障碍物前进？ 波动说：胡克(光是一种纵波)，惠更斯第一次交锋以牛顿为首的微粒说战胜了波动说 第二次波粒战争 波的干涉 托马斯.杨: 波的双缝干涉实验(1807年) 波的叠加与抵消 决定性事件(1819年) 菲涅尔: 采用光是一种波动的观点，用严密的数学推理解释了光的衍射 该理论用于圆盘衍射为一个亮斑，泊松质疑，阿拉果坚持实验检测，完美证明，后被误称为“泊松亮斑” 光的偏振 菲涅尔提出光是一种横波，而不是纵波，成功解析了偏振现象(1821年) 光速 傅科：“傅科摆”(1850年) 测量光在真空和水中的速度，后者为前者的3/4 电磁理论 麦克斯韦发表电磁理论的论文，预言光是电磁波的一种(1861年) 赫兹实验证明了麦克斯韦电磁理论(1887年) 麦氏方程在数学上完美得难以置信，科学美的典范至此，波动的光辉达到顶点 乌云开尔文《在热和光动力理论上空的十九世纪乌云》两朵乌云分别指：经典物理在光以太和麦克斯韦-玻尔兹曼能量均分学说遇到的难题，具体而言为迈克尔逊-莫雷实验和黑体辐射研究中的困难 第一朵乌云第一朵乌云为迈克尔逊-莫雷实验：探测光以太对于地球的漂移速度经典的失败实验最终导致了相对论革命的爆发 第二朵乌云第二朵乌云为黑体辐射实验和理论的不一致最终导致了量子革命的爆发 黑体辐射研究黑体辐射研究：物体的辐射能量和温度具有怎样的函数关系？从粒子角度去推导，维恩提出辐射能量分布定律公式(1894年)，即著名的维恩分布公式实验证明：黑体加热到1000K以上的高温时，测到短波范围内的曲线和维恩公式符合的很好，但在长波方面，实验出现了偏差从经典的电磁波的角度去推导，瑞利和金斯提出如瑞利-金斯公式，长波符合，短波出现偏差两套公式均无法给出正确的黑体辐射分布 普朗克黑体辐射研究普朗克利用数学上的内插法，凑出一个公式。在长波的时候，它表现得就像正比关系一样。而在短波的时候，它则退化为维恩公式的原始形式。这就是著名的普朗克黑体公式。普朗克寻找该公式的物理意义。如果要使得新的方程成立，就必须做一个假定：假设能量在发射和吸收的时候不是连续不断而是分成一份一份的正是这个假定，推翻了自牛顿200多年来曾经被认为是坚固不可摧毁的经典世界。以前一切自然个过程被当做连续不断的，但现在能量不是连续不断的了。能量必须只有有限个可能态，必须有个最小单位。在两个最小单位之间，是能量的禁区，我们永远不会发现，能量的计量会出现小数点以后的数字。1900年普朗克宣读《黑体光谱中的能量分布》，称这个基本单位为“能量子”,后改为“量子”。E=hv(E为单个量子的能量，V是频率，h为普朗克常数)，普朗克常数h、引力常数g和光速c构成我们宇宙最为重要的三个基本物理常数。量子论告诉我们，“无限分割”的概念是一种数学上的理想，而不可能在现实中实现。一切都是不连续的，连续性的美好蓝图也行不过时我们的一种想象。 量子力学光电效应赫兹证明电磁波的实验引出了“光电效应”光电效应和电磁理论的不协调之处：电磁理论认为，光作为一种波动，它的强度代表了它的能量，而实验证明：光的频率，而不是强度决定它能否从金属表面打出电子来；光的强度而不是频率，则决定打出电子的数目。1905年，爱因斯坦从普朗克的量子假设出发。E=hv，提高频率不正是提高了单个量子的能量吗？而更高能量的量子，不正好打击出更高能量的电子吗？另一方面，提高光的强度，只是增加量子的数量罢了。组成光的能量的这种最小基本单位，称之为光量子。光以量子的形式吸收能量，没有连续性，不能累积。一个光量子发出一个对应的电子。于是实验揭示出的瞬时作用也解决，量子作用本来就是瞬时作用，没有积累的说法。微粒说的一种翻版。 康普顿效应康普顿X射线被自由电子散射实验：散射出来的X射线分成两个部分，一部分和原来的入射射线波长相同，另一部分却比原来的射线波长要长，具体的大小和散射角存在函数关系。运用通常的波动理论，散射应该不会改变入射光的波长。于是其引入光量子的假设，光子像普通小球那样，不仅带有能量还具有冲量，当其与电子发生碰撞时，自己的一部分能量交换给电子，有E=hv可知，E下降导致v下降，导致波长变长。实验完全吻合。 原子模型卢瑟福实验α粒子轰击极薄的金箔(1910年)1911年修改汤姆逊的原子模型为“行星模型”，负电的电子围绕带正电的原子核。物理学家指出其不稳定，经典的电磁理论预言，这样的体系将会无可避免的释放出辐射能量，电子必将坠毁，导致体系崩溃 玻尔模型玻尔面临选择：放弃经典电磁理论，或者放弃卢瑟福原子模型。玻尔选择了前者。(1913年)原子内部只能释放特定量的能量，说明电子只能再特定的“势能位置”之间转换。也就是说，电子必须按照某些“确定的”轨道运行，这些轨道必须符合一定的势能条件，从而使得电子在这些轨道之间跃迁时，只能释放出符合巴尔末公式的能量来。电子只能释放或者吸收特定的能量而不是连续不断的。电子从E1跃迁到E2并不表示电子经过了E1和E2之间的任意状态。玻尔的这些思想，以三篇论文发表，量子物理划时代的文献，即伟大的“三部曲”。玻尔模型是卢瑟福模型的延续，一系列量子化条件被引入。1900年普朗克宣告了量子的诞生，1913年玻尔将一个完整的关于原子的理论体系建立起来，宣告了量子进入青年时代。 1918年玻尔发布“对应原理”，试图与麦氏理论调和，力图证明两种理论都正确，但是有不同的适用范围。导致了其最终的衰败。 玻尔假设，电子只能具有量子化的能级和轨道，但没有说明理由。而且无法解释“反常塞曼效应”，这种现象要求引进值为1/2的量子数。泡利在访问玻尔家时就曾经对玻尔夫人的问好回以暴躁的抱怨：“我当然不好！我不理解‘反常塞曼效应’”。 1925年泡利提出“不相容原理”。他发现没有两个电子能享有相同的状态，同一轨道包容的不同状态，其数目也是有限的，也就是说一个轨道有一定的容量。当电子填满一个轨道后其他电子无法加入到这个轨道中来。解决了电子长期占据外层电子轨道而不会失去能量落到低层轨道上的问题。解决了“反常塞曼效应”的问题 德布罗意波在玻尔模型中自然引进一个周期的概念，以符合观测到的现实。原本这个条件是强加在电子上的量子化模式：电子轨道是不连续的。德布罗意准备解释原因。E=mc^2,E=hv。hv=mc^2 电子具有一个内禀的频率，v=mc^2/h。电子以速度v0前进必定伴随一个速度为c^2/v0的波，德布罗意将其称为“相波”，后人称之为德布罗意波。电子也是一种波。这个波的速度比光速还快，但是这种波不能携带能量和信息，因此并不违反相对论。德布罗意是有史以来第一个凭借博士论文就获得诺贝尔奖的人。 海森堡矩阵力学对绝对“能级”或者“频率”表示怀疑。单独的能级无法观测，只有“能级差”可以频率表示为两个能级X，Y的函数。使用矩阵推导出量子化的原子能级和辐射频率。不需要像玻尔的旧模型那样，强行加一个不自然的量子条件。1924年，玻恩，海森堡，约尔当发表“三人论文”，《论量子力学I》《论量子力学II》 薛定谔波动力学薛定谔情人众多，世界观迥异。薛定谔从经典力学的哈密顿-雅可比方程触发，利用变分法和德布罗意公式，最后求出了一个非相对论的波动方程(1926年)。原子的神秘光谱不再为矩阵力学所专美，它同样可以从波动方程中被自然的推导出来。后薛定谔、泡利、约尔当均证明矩阵力学和波动力学在数学上说是完全等价的，均是从经典的哈密顿函数而来。但是薛定谔定义的Ψ波函数，说这是空间中定义的某种分布，他自己也没见过，不知道其物理意义。 2017.8.15更新 玻恩的概率解释玻恩说这个波函数Ψ里面装的是“骰子”。它代表的是一种随机，一种概率，而决不是薛定谔本人理解的，是电子电荷在空间中的实际分布。玻恩争辩道，Ψ或者更准确的说，Ψ^2代表了电子在某个地点出现的“概率”。电子本身不会像波那样扩展开去，但是它出现的概率则像一个波，严格按照Ψ的分布所展开。 单个电子打到感光屏。激发出一个小点。我们不能预言它组成类波的干涉条纹，因为一个电子只会留下一个点而已，而且出现的位置也不确定。但是只有当成群的电子穿过双缝后才会逐渐组成干涉条纹。规律：电子在某些地方出现的可能性要大一些，在另一些地方则小一些。出现频率高的地方，恰恰是波动所预言的干涉条纹的亮处，出现频率低的地方则对应于暗处。虽然每一个电子的行为是随机的，但是这个随机分布的总的模式是确定的，它就是一个干涉条纹的图案。这就像我们掷骰子，虽然每一个骰子掷下去，它的结果是完全随机的，但是如果大量的骰子到地上，你会发现1-6的结果差不多是平均的。物理不能预测电子的行为，它只能找到电子出现的概率而已。理论上，只要我们了解每一个分子的状态，我们完全可以严格地推断出整个系统的行为，分毫不爽。可是玻恩的意思是，就算我们把电子的初始状态测量的精确无误，就算我们拥有最强大的计算机可以计算一切环境对电子的影响，即便如此，我们也不能预言电子最后的准确位置。这种不确定不是因为我们的计算能力不足，它是深藏在物理定律本身内部的一种属性。即使从理论上来说，我们也不能准确地预测大自然。这已经不是推翻某个理论的问题，这是对整个决定论系统的挑战，而决定论是那时整个科学的基础。量子论要改造整个科学。 海森堡的不确定性原理1927年，海森堡由矩阵力学提出不确定性原理又称测不准原理。p×q ≠ q×p,p是动量，q是位置，这不是说先观测动量p，再观测位置q，这和先观测q再观测p，其结果是不一样的吗？除非测量动量p这个动作本身，影响到了q的数值。反之亦如此。这个方程告诉我们同时观测p和q是不可能的吗？理论不但决定了我们能够观察到的东西，它还决定哪些是我们观察不到的东西。关键在测量上，在电子层面上，由于观测时不能忽略光子对它的撞击，为了测量位置，我们剧烈改变了它的动量。我们没法同时即准确地知道一个电子的位置同时又准确的了解它的动量。最后得出：∆p×∆q&gt;h/4π,∆p、∆p分别表示测量误差。∆p非常小，∆q相应地必定变得非常大。后又发现能量E和时间t也满足类似的不确定性规则：∆E×∆t&gt;h。在非常断点一刹那，也就是t非常确定的一瞬间，即使真空也会出现巨大的能量起伏，这种能量完全是靠着不确定性而凭空出现的，它的确违反了能量守恒定律，但是一刹那很短，在人们还没来得及发现以前，它又神秘消失，使得能量守恒在整体上得以维持。在玻尔指导下，其声明不确定性其实同时建筑在连续性和不连续性两者之上。 玻尔的互补原理福尔摩斯说：“我的方法，就建立在这样一种假设上面：当你把一切不可能的结论都排除之后，那剩下的，不管多么离奇，也必然是事实。”电子不可能不是个粒子，它也不可能不是波，那剩下的唯一可能性就是：它既是个粒子也是个波。我们每次观察电子，它只展现出其中的一面，这里面关键是我们“如何”观察它，而不是它“究竟”是什么。讨论哪个是“真实”毫无意义。我们唯一能说的是在某种观察方式确定的前提下，它能呈现出什么样子来。但一旦观察方式确定了，电子就要选择一种表现形式，它得作为一个波或者粒子出现，而不能再暧昧的混杂在一起。波和粒子在同一时刻是互斥的，但它们却又在一个更高的层次上统一在一起，作为电子的两面被纳入一个整体概念中，这就是玻尔的“互补原理”。。 量子论与测量只有观测手段明确之后，答案才有意义。而脱离了观测手段去讨论这个图案“本质上”到底是什么是无意义的。在量子论中观测者和外部宇宙是结合在一起的，它们之间现在已经没有明确的界限，是一个整体。换言之，不存在一个客观的，绝对的世界。唯一存在的，就是我们能够观测到的世界。物理学的全部一样，不在于它能够揭示出自然“是什么”，而在于它能够明确，关于自然我们能“说什么”。没有一个脱离于观测而存在的“绝对自然”，只有我们和那些复杂的测量关系，熙熙攘攘纵横交错，构成了这个令人心醉的宇宙的全部。测量时新物理学的核心，测量行为创造了整个世界。 “存在，但绝对观测不到”之类的论断都是毫无意义的，因为这和“不存在”根本就是一码事，无法区分开来。 量子论“哥本哈根解释”总结玻恩的的概率解释、海森堡的不确定性和互补原理共同构成量子论“哥本哈根解释”的核心，前两者捣毁了经典世界的(严格)因果性，互补原理和不确定性原理有合力摧毁了世界的(绝对)客观性。它们至今仍然影响我们队宇宙的终极认识。首先，不确定性原理限制了我们队微观事物认识的极限，而这个极限也就是具有物理意义的一切。其次，因为存在着观测者对于被观测物的不可避免的扰动，现在主体和客观世界必须被理解成一个不可分割的整体。没有一个孤立地存在于客观世界的“事物”，事实上一个纯粹的客观世界是没有的，任何事物都只有结合一个特定的观测手段，才谈得上具有具体意义。对象所表现出的形态，很大程度上取决于我们的观测方法。对于同一个现象来说，这些表现形态可能是相互排斥的，但必须被同时作用域对这个对象的描述中，也就是互补原理。最后，因为我们的观测给事物带来各种原则上不可预测的扰动，量子世界本质是“随机的”。传统世界严格发因果关系在量子世界是不存在的，必须以一种统计性的解释来取而代之，波函数Ψ就是一种统计，它的平方代表了粒子出现在某处的概率。当我们说“电子出现在x处”时，我们并不知道这个事件的“原因”是什么，它是一个完全随机的过程，没有因果关系。 量子幽灵在电子通过双缝前，如果我们不去测量它的位置，那么它的波函数就按照方程发散开去，同时通过两个缝而自我相互干涉。但要是我们试图在两条缝上装个仪器以探测它究竟通过了哪条缝，在那一刹那，电子的波函数便塌缩了，电子随机地选择一个缝通过。而塌缩过的波函数自然就无法再进行干涉，于是乎，干涉条纹一去不复返。 第三次波粒战争微粒说：光电效应，康普顿效应，玻色-爱因斯坦统计,矩阵力学波动说：麦克斯韦理论，德布罗意波(电子也是一种波)，波动力学在互补原理、玻恩的的概率解释和海森堡的不确定性提出后，第三次波粒战争以戏剧化结尾收场，两者是不可分割的一个整体，即“波粒二象性”。 玻尔、爱因斯坦之争爱因斯坦光箱实验ERP佯谬 薛定谔的猫薛定谔想象了一种结构巧妙的精密装置，每当原子衰变而放出一个中子，它就激发一连串的连锁反应，最终结果是打破箱子里的一个毒气瓶，而同时箱子里还有一只猫。若原子衰变，猫就被毒死，反之，猫活着。当它们都被锁在箱子里时，因为我们没有观察，所以原子处在衰变/不衰变的叠加态。因为原子的状态不确定，所以猫的状态也不确定，只有打开箱子才能最终定论。问题是，当我们没有打开箱子之前，这只猫处于什么状态？似乎唯一的可能就是，它和我们的原子一样处在叠加态，这只猫当时陷于死/活的混合。 量子力学延伸意识为什么机器来测量就得叠加，而人来就得到确定结果呢？难道说，人类意识的参与才是波函数塌缩的原因？只有当电子的随机结果被“意识到”，它才真正地变为现实，从波函数中脱胎而出来到这个世界上。 量子通信不可复制原理：传输量子态的同时一定会毁掉原来的那个原本。 延迟实验我们何时选择“光子”的模式，对于实验结果无影响。 这说明，宇宙的历史，可以在它已经发生后才决定究竟是怎样发生的！在薛定谔的猫实验里，如果我们设计某种延迟实验，我们就能在实验结束后决定猫是死是活！比如说，原子在一点钟要么衰变毒死猫，要么断开装置使猫存活。但如果有某个延迟装置能够让我们在2点钟来“延迟决定”原子衰变与否，我么就可以在两点钟这个“未来”去实际决定猫在一点钟的死活。 宇宙本身由一个有意识的观测者创造出来也不是什么不可能的事情。虽然宇宙的行为在道理上讲已经演化了一百多亿年，但某种“延迟”使得它直到被一个高级生物所观察才成为确定。我们的观测行为本身参予了宇宙的创造过程！这就是所谓的“参与性宇宙”模型（The Participatory Universe）。宇宙本身没有一个确定的答案，而其中的生物参与了这个谜题答案的构建本身！ 这实际上是某种增强版的“人择原理”（anthropic principle）。人择原理是说，我们存在这个事实本身，决定了宇宙的某些性质为什么是这样的而不是那样的。也就是说，我们讨论所有问题的前提是：事实上已经存在了一些像我们这样的智能生物来讨论这些问题。我们回忆一下笛卡儿的“第一原理”：不管我怀疑什么也好，有一点我是不能怀疑的，那就是“我在怀疑”本身，也就是著名的“我思故我在”！类似的原则也适用于人择原理：不管这个宇宙有什么样的性质也好，它必须要使得智能生物可能存在于其中，不然就没有人来问“宇宙为什么是这样的？”这个问题了。随便什么问题也好，你首先得保证有一个“人”来问问题，不然就没有意义了。 缺点：对于观测者无法定义，对于意识无法定义 多世界解释(Many Worlds Interpretation,MWI)电子即使在观测后仍然处于左/右叠加的,只不过，我们的世界本身也是叠加的一部分！当电子穿过双缝后，处于叠加态的不仅仅是电子，还包括我们整个世界！也就是说，当电子经过双缝后，出现了两个叠加在一起的世界，在其中的一个世界里电子穿过了左边的双缝，而在另一个世界里，电子穿过了右边的双缝！波函数无须“塌缩”，去随机选择左还是右，事实上两种可能都发生了！只不过它表现为整个世界的叠加：生活在一个世界的人在他们那里电子通过左边的狭缝，而在另一个世界中，人们观测到的电子则在右边！我们的宇宙可能是高维空间，真实世界的投影，可能有很多类似的空间。缺点：多世界，我看不到 量子自杀这就是从量子自杀思想实验推出的怪论，美其名曰“量子永生”（quantumimmortality）。只要从主观视角来看，不但一个人永远无法完成自杀，事实上他一旦开始存在，就永远不会消失！总存在着一些量子效应，使得一个人不会衰老，而按照MWI，这些非常低的概率总是对应于某个实际的世界！如果多宇宙理论是正确的，那么我们得到的推论是：一旦一个“意识”开始存在，从它自身的角度来看，它就必定永生！（天哪，我们怎么又扯到了“意识”！）。这是最强版本的人择原理，也称为“终极人择原理 应用量子计算机一个bit表示0,1的叠加，处理10位bit,处理的是2^10个这样的数。做的不能比图灵计算机多，但是速度更快。基于大数分解的加密算法会失效。 量子加密隐变量理论如果你试图去测量一个电子的具体位置的话，你的测量仪器将首先与它的量子势发生作用，这将使电子本身发生微妙的变化，这些变化是不可预测的，因为主宰它们的是一些“隐变量”，你无法直接探测到它们。恢复了实在性却放弃了定域性。 贝尔不等式如果世界的本质是经典的，具体的说，如果我们的世界同时满足： 定域的，也就是没有超光速的信号传播 实在的，也就是说，存在一个独立于我们观察的外部世界 那么我们任意去三个方向观察A、B的自旋，他们所表现的协作程度必定要受限于贝尔不等式之内但在量子论中，贝尔不等式可以被突破(1964年)，实验证明该不等式被突破，世界不是经典的，爱因斯坦输了(1982)。 阿斯派克特实验之后，我们必须说服自己相信这样一件事情： 定域的隐变量理论是不存在的！ 换句话说，我们的世界不可能如同爱因斯坦所梦想的那样，既是定域的（没有超光速信号的传播），又是实在的（存在一个客观确定的世界，可以为隐变量所描述）。定域实在性（local realism）从我们的宇宙中被实验排除了出去，现在我们必须作出艰难的选择：要么放弃定域性，要么放弃实在性。 如果我们放弃实在性，那就回到量子论的老路上来，承认在我们观测之前，两个粒子不存在于“客观实在”之内。它们不具有通常意义上的物理属性（如自旋），只有当观测了以后，这种属性才变得有意义。这样一来牢固可靠的世界就崩塌了。 这样一来就必须放弃定域性。我们仍然有可能建立一个隐变量理论，如果容忍某种超光速的信号在其体系中来回，则它还是可以很好地说明我们观测到的一切。比如在EPR中，天际两头的两个电子仍然可以通过一种超光速的瞬时通信来确保它们之间进行成功的合作。事实上，玻姆的体系就很好地在阿斯派克特实验之后仍然存活着，因为他的“量子势”的确暗含着这样的超距作用。 可是要是这样的话，我们也许并不会觉得日子好过多少！超光速的信号？老大，那意味着什么？想一想爱因斯坦对此会怎么说吧，超光速意味着获得了回到过去的能力！ 其实我们的史话一早已经讨论过，德布罗意那“相波”的速度c2/v就比光速要快，但只要不携带能量和信息，它就不违背相对论。 超弦理论，M理论时空变成11维其他维度的扰动造成全部的量子不确定性 对待科学的态度事实上，我们对待科学的态度是，只要一个理论能够被证明为“错”但还未被证明“错”，我们就暂时接受它为可靠正确的。不过它必须随时积极地面对证伪，这也就是为什么科学总是在自我否定中不断完善。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划]]></title>
    <url>%2F2017%2F08%2F13%2Fdynamic-programming%2F</url>
    <content type="text"><![CDATA[2017.08.17更新 背包问题01背包状态dp[i][j]表示前i个物品装到剩余容量为j时的最大价值 状态转移方程dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i - 1]] + value[i - 1])第i个物品装或者不装入背包，不装价值为dp[i-1][j],装表示剩下i-1个物品装入j-weight[i-1]重的最大价值，加上value[i-1]注意讨论前i个物品装入背包的时候， 其实是在考查第i-1个物品装不装入背包（因为物品是从0开始编号的） 代码123456789101112131415161718192021222324252627282930313233public class Pack_01 &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub// int n = 5;// 物品个数// int[] value = &#123; 48, 40, 12, 8, 7 &#125;;// 物品价值// int[] weight = &#123; 6, 5, 2, 1, 1 &#125;;// 物品重量// int capacity = 8;// 背包容量 int n = 4; int[] value = &#123; 10, 40, 30, 50 &#125;; int[] weight = &#123; 5, 4, 6, 3 &#125;; int capacity = 12; int res = pack_01(n, capacity, weight, value); System.out.println(res); &#125; public static int pack_01(int n, int capacity, int[] weight, int[] value) &#123; int[][] dp = new int[n + 1][capacity + 1]; for (int i = 1; i &lt; dp.length; i++) &#123;// for (int j = 1; j &lt; dp[0].length; j++) &#123; if (j &gt;= weight[i - 1]) &#123; dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - weight[i - 1]] + value[i - 1]); &#125; else &#123; dp[i][j] = dp[i - 1][j];// i只与i-1有关 &#125; &#125; &#125; return dp[n][capacity]; &#125;&#125; 完全背包状态dp[i][j]表示前i个物品装到剩余容量为j时的最大价值 状态转移方程dp[i][j] = max(dp[i - 1][j - num * weight[i - 1]] + num * value[i - 1]) (0&lt;=num * weight[i - 1]&lt;=j) 代码1234567891011121314151617181920212223242526272829public class Pack_full &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub int n = 5;// 物品个数 int[] value = &#123; 48, 40, 12, 8, 7 &#125;;// 物品价值 int[] weight = &#123; 6, 5, 2, 1, 1 &#125;;// 物品重量 int capacity = 8;// 背包容量 // int n = 4; // int[] value = &#123; 10, 5, 30, 40 &#125;; // int[] weight = &#123; 5, 4, 6, 3 &#125;; // int capacity = 12; int res = pack_full(n, capacity, weight, value); System.out.println(res); &#125; public static int pack_full(int n, int capacity, int[] weight, int[] value) &#123; int[][] dp = new int[n + 1][capacity + 1]; for (int i = 1; i &lt; dp.length; i++) &#123; for (int j = 1; j &lt; dp[0].length; j++) &#123; for (int num = 0; j &gt;= num * weight[i - 1]; num++) &#123; dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - num * weight[i - 1]] + num * value[i - 1]); &#125; &#125; &#125; return dp[n][capacity]; &#125;&#125; 2017.08.18更新 硬币找零(方案数)状态dp[i][j]表示使用changes[0-i]硬币兑换j元的方法总数 分析使用i=0的钱币兑换，只有changes[0]的整数倍的金额才能有1种方法dp[0][j * changes[0]] = 1 状态转移方程不装入第i种钱币，即使用0~i-1种钱币组成j的方法数；装入i钱币，使用0~i的钱币组成j-changes[i]金额的方法数dp[i][j] = dp[i - 1][j] + dp[i][j - changes[i]] 代码12345678910111213141516171819202122232425262728293031323334353637383940//链接：https://www.nowcoder.com/questionTerminal/185dc37412de446bbfff6bd21e4356ec//来源：牛客网////有一个数组changes，changes中所有的值都为正数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，对于一个给定值x，请设计一个高效算法，计算组成这个值的方案数。//给定一个int数组changes，代表所以零钱，同时给定它的大小n，另外给定一个正整数x，请返回组成x的方案数，保证n小于等于100且x小于等于10000。//测试样例：//[5,10,25,1],4,15//返回：//6public class ChangeMoney &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub int[] changes = &#123; 5, 10, 25, 1 &#125;; int n = 4; int money = 15; int res = change(changes, n, money); System.out.println(res); &#125; public static int change(int[] changes, int n, int money) &#123; int[][] dp = new int[n][money + 1];// dp[i][j]表示使用changes[0-i]硬币兑换j元的方法总数。 for (int i = 0; i &lt; n; i++) &#123; // j=0表示钱为0，组成0元的方法数为1 dp[i][0] = 1; &#125; for (int j = 0; j * changes[0] &lt; money + 1; j++) &#123;// 使用i=0的钱币兑换，只有changes[0]的整数倍的金额才能有1种方法 dp[0][j * changes[0]] = 1; &#125; // 填表 for (int i = 1; i &lt; dp.length; i++) &#123;// 数组长度1~n-1在changes数组中有效 for (int j = 1; j &lt; dp[0].length; j++) &#123; // 不装入第i种钱币，即使用0~i-1种钱币组成j的方法数；装入i钱币，使用0~i的钱币组成j-changes[i]金额的方法数 dp[i][j] = dp[i - 1][j] + (j - changes[i] &gt;= 0 ? dp[i][j - changes[i]] : 0); &#125; &#125; return dp[n - 1][money]; &#125;&#125; 硬币找零(最少硬币数)多重背包最长子序列参考文献 背包问题九讲 动态规划之背包问题]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript Puzzlers解析]]></title>
    <url>%2F2017%2F08%2F12%2Fjs-puzzlers%2F</url>
    <content type="text"><![CDATA[JavaScript Puzzlers!，题目基于ECMA 262 (5.1)的浏览器环境 2017.08.15更新 1.What is the result of this expression? (or multiple ones)123456[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt) A.[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]B.[1, 2, 3]C.[0, 1, 2]D.other 考察map和parseIntArray.prototype.map()接收三个参数(element,index,Array)parseInt()接收两个参数(val,radix),radix为基数，parseInt(&#39;17&#39;,8) //15,radix为0或无表示以10为基数。每个位上的数字不能比基数大，否则返回NaN,radix不能为1,范围为2-36。123parseInt(&apos;1&apos;,0)//1parseInt(&apos;2&apos;,1)//每个位上的数字不能比基数大，且基数不能为1,返回NaNparseInt(&apos;3&apos;,2)//每个位上的数字不能比基数大,返回NaN 所以选D 2.What is the result of this expression? (or multiple ones)123456[typeof null, null instanceof Object] A.[&quot;object&quot;, false]B.[null, false]C.[&quot;object&quot;, true]D.other 考察typeof和instanceoftypeof检测非基本对象时，均返回objectnull为基本类型，所以null instanceof Object // false选A 3.What is the result of this expression? (or multiple ones)123456[ [3,2,1].reduce(Math.pow), [].reduce(Math.pow) ] A.an errorB.[9, 0]C.[9, NaN]D.[9, undefined] 考察reduce函数的用法Array.prototype.reduce()接收两个参数(function(accumulator, currentValue, currentIndex, array), initialValue)空数组调用reduce时没有设置初始值将会报错。所以选A 4.What is the result of this expression? (or multiple ones)1234567var val = &apos;smtg&apos;;console.log(&apos;Value is &apos; + (val === &apos;smtg&apos;) ? &apos;Something&apos; : &apos;Nothing&apos;); A.Value is SomethingB.Value is NothingC.NaND.other 考察运算符优先级，MDN运算符优先级表+(13级)优先级大于？(3级),所以&#39;Value is &#39; + (val === &#39;smtg&#39;)条件判断为true，答案为&#39;Something&#39;,选D 5.What is the result of this expression? (or multiple ones)1234567891011121314var name = &apos;World!&apos;;(function () &#123; if (typeof name === &apos;undefined&apos;) &#123; var name = &apos;Jack&apos;; console.log(&apos;Goodbye &apos; + name); &#125; else &#123; console.log(&apos;Hello &apos; + name); &#125;&#125;)(); A.Goodbye JackB.Hello JackC.Hello undefinedD.Hello World 考察变量声明提升（var hoisting）由于变量声明（以及其他声明）总是在任意代码执行之前处理的，所以在代码中的任意位置声明变量总是等效于在代码开头声明。这意味着变量可以在声明之前使用，这个行为叫做“hoisting”。“hoisting”就像是把所有的变量声明移动到函数或者全局代码的开头位置。所以选A 6.What is the result of this expression? (or multiple ones)123456789101112var END = Math.pow(2, 53);var START = END - 100;var count = 0;for (var i = START; i &lt;= END; i++) &#123; count++;&#125;console.log(count); A.0B.100C.101D.other 考察JavaScript中的安全整数范围Number.MIN_SAFE_INTEGER代表在JavaScript中最小的安全的integer型数字-(2^53 - 1).Number.MAX_SAFE_INTEGER代表在JavaScript中最大的安全整数(2^53 - 1)。这个数字形成的原因是，Javascript 使用 IEEE 754 中规定的double-precision floating-point format numbers，在这个规定中能安全的表示数字的范围在-(2^53 - 1)到2^53 - 1之间，包含-(2^53 - 1)和2^53 - 1。2^53+1 与 2^53超过安全整数范围，2^53+1 == 2^53//true,所以为无限循环，选D 7.What is the result of this expression? (or multiple ones)12345678var ary = [0,1,2];ary[10] = 10;ary.filter(function(x) &#123; return x === undefined;&#125;); A.[undefined × 7]B.[0, 1, 2, 10]C.[]D.[undefined] 考察filter函数filter函数中callback只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用。所以选C 8.What is the result of this expression? (or multiple ones)12345678910var two = 0.2var one = 0.1var eight = 0.8var six = 0.6[two - one == one, eight - six == two] A.[true, true]B.[false, false]C.[true, false]D.other 考察js大数和浮点数精度丢失的问题计算机的二进制实现和位数限制有些数无法有限表示。就像一些无理数不能有限表示，如 圆周率 3.1415926…，1.3333… 等。JS 遵循 IEEE 754 规范，采用双精度存储（double precision），占用 64 bit。解决方案：对于整数，前端出现问题的几率可能比较低，毕竟很少有业务需要需要用到超大整数，只要运算结果不超过 Math.pow(2, 53) 就不会丢失精度。对于小数，前端出现问题的几率还是很多的，尤其在一些电商网站涉及到金额等数据。解决方式：把小数放到位整数（乘倍数），再缩小回原来倍数（除倍数）选择C，没有道理，时而准确时而不准，忧伤 9.What is the result of this expression? (or multiple ones)123456789101112131415161718192021function showCase(value) &#123; switch(value) &#123; case &apos;A&apos;: console.log(&apos;Case A&apos;); break; case &apos;B&apos;: console.log(&apos;Case B&apos;); break; case undefined: console.log(&apos;undefined&apos;); break; default: console.log(&apos;Do not know!&apos;); &#125;&#125;showCase(new String(&apos;A&apos;)); A.Case AB.Case BC.Do not know!D.undefined 考察switch()和判等switch()使用===判等，而new String(&#39;A&#39;)!==&#39;A&#39;,所以选C 10.What is the result of this expression? (or multiple ones)123456789101112131415161718192021function showCase2(value) &#123; switch(value) &#123; case &apos;A&apos;: console.log(&apos;Case A&apos;); break; case &apos;B&apos;: console.log(&apos;Case B&apos;); break; case undefined: console.log(&apos;undefined&apos;); break; default: console.log(&apos;Do not know!&apos;); &#125;&#125;showCase2(String(&apos;A&apos;)); A.Case AB.Case BC.Do not know!D.undefined 考察String()方法和判等String(&#39;A&#39;)没有新建一个对象，而是返回一个String，所以选A 2017.08.16更新 11.What is the result of this expression? (or multiple ones)12345678910111213141516function isOdd(num) &#123; return num % 2 == 1;&#125;function isEven(num) &#123; return num % 2 == 0;&#125;function isSane(num) &#123; return isEven(num) || isOdd(num);&#125;var values = [7, 4, &apos;13&apos;, -9, Infinity];values.map(isSane);A.[true, true, true, true, true]B.[true, true, true, true, false]C.[true, true, true, false, false]D.[true, true, false, false, false] 考察取余操作符取余操作符保证符号，所以-9 % 2 == -1 ，Infinity % 2 == NaN所以选C 12.What is the result of this expression? (or multiple ones)12345678parseInt(3, 8)parseInt(3, 2)parseInt(3, 0) A.3, 3, 3B.3, 3, NaNC.3, NaN, NaND.other 考察parseInt()函数，分析见第1题，答案应该为3,NaN,3 所以选D 13.What is the result of this expression? (or multiple ones)123456Array.isArray( Array.prototype ) A.trueB.falseC.errorD.other 考察Array.prototype，是数组，所以选A 14.What is the result of this expression? (or multiple ones)1234567891011var a = [0];if ([0]) &#123; console.log(a == true);&#125; else &#123; console.log(&quot;wut&quot;);&#125; A.trueB.falseC.&quot;wut&quot;D.other 考察if()和判等,见js相等性比较if([])都会执行，所以if([0])更会执行，对象和布尔值比较，布尔值转换为数字，对象转换为原始值比较,[0] == true // false所以选B 15.What is the result of this expression? (or multiple ones)123456[]==[] A.trueB.falseC.errorD.other 考察相等性比较，见js相等性比较对象和对象比较，引用相同返回true,否则返回false,所以选B 16.What is the result of this expression? (or multiple ones)1234567&apos;5&apos; + 3&apos;5&apos; - 3 A.&quot;53&quot;, 2B.8, 2C.errorD.other 考察+,-运算符,字符串会使用+运算符做连接，但是遇到-则转换为数值进行运算所以选A 17.What is the result of this expression? (or multiple ones)1234561 + - + + + - + 1 A.2B.1C.errorD.other 考察一元+, -中间一元加号不影响，两个一元减号负负得正变加号,所以选A 18.What is the result of this expression? (or multiple ones)12345678var ary = Array(3);ary[0]=2ary.map(function(elem) &#123; return &apos;1&apos;; &#125;); A.[2, 1, 1]B.[&quot;1&quot;, &quot;1&quot;, &quot;1&quot;]C.[2, &quot;1&quot;, &quot;1&quot;]D.other 考察map函数删除或未赋值的元素不会被遍历到，所以选D 19.What is the result of this expression? (or multiple ones)1234567891011121314function sidEffecting(ary) &#123; ary[0] = ary[2];&#125;function bar(a,b,c) &#123; c = 10 sidEffecting(arguments); return a + b + c;&#125;bar(1,1,1) A.3B.12C.errorD.other 考察函数的arguments函数的arguments与参数是相对应的，但不是同一片内存空间，所以答案为21，选D 20.What is the result of this expression? (or multiple ones)12345678var a = 111111111111111110000, b = 1111;a + b; A.111111111111111111111B.111111111111111110000C.NaND.Infinity 考察js的大数精度js中的大数精度也缺失了，选B 21.What is the result of this expression? (or multiple ones)1234567var x = [].reverse;x();A.[]B.undefinedC.errorD.window 题目基于ECMA 262 (5.1)的浏览器环境，[].reverse返回this，被浏览器调用之后为window。选D 22.What is the result of this expression? (or multiple ones)123456Number.MIN_VALUE &gt; 0 A.falseB.trueC.errorD.other 考察NumberNumber.MIN_VALUE是大于0的最小数，所以选B 23.What is the result of this expression? (or multiple ones)123456[1 &lt; 2 &lt; 3, 3 &lt; 2 &lt; 1] A.[true, true]B.[true, false]C.errorD.other 考察&lt;运算符(1 &lt; 2) &lt; 3,1 &lt; 2 //true 转换为1 1 &lt; 3 // true(3 &lt; 2) &lt; 1,3 &lt; 2 //false 转换为0 0 &lt; 1 //true所以选A 24.What is the result of this expression? (or multiple ones)1234567// the most classic wtf2 == [[[2]]] A.trueB.falseC.undefinedD.other 考察==对象和其他值比较时，会将对象转换为原始值，[[[2]]]转换原始值为2所以返回true 2017.08.17更新 25.What is the result of this expression? (or multiple ones)123456783.toString()3..toString()3...toString() A.&quot;3&quot;, error, errorB.&quot;3&quot;, &quot;3.0&quot;, errorC.error, &quot;3&quot;, errorD.other 26.What is the result of this expression? (or multiple ones)(function(){ var x = y = 1;})();console.log(y);console.log(x); 1, 1error, error1, errorother What is the result of this expression? (or multiple ones) var a = /123/, b = /123/;a == ba === b true, truetrue, falsefalse, falseother What is the result of this expression? (or multiple ones) var a = [1, 2, 3], b = [1, 2, 3], c = [1, 2, 4]a == ba === ba &gt; ca &lt; c false, false, false, truefalse, false, false, falsetrue, true, false, trueother What is the result of this expression? (or multiple ones) var a = {}, b = Object.prototype;[a.prototype === b, Object.getPrototypeOf(a) === b] [false, true][true, true][false, false]other What is the result of this expression? (or multiple ones) function f() {}var a = f.prototype, b = Object.getPrototypeOf(f);a === b truefalsenullother What is the result of this expression? (or multiple ones) function foo() { }var oldName = foo.name;foo.name = “bar”;[oldName, foo.name] error[“”, “”][“foo”, “foo”][“foo”, “bar”] What is the result of this expression? (or multiple ones) “1 2 3”.replace(/\d/g, parseInt) “1 2 3”“0 1 2”“NaN 2 3”“1 NaN 3” What is the result of this expression? (or multiple ones) function f() {}var parent = Object.getPrototypeOf(f);f.name // ?parent.name // ?typeof eval(f.name) // ?typeof eval(parent.name) // ? “f”, “Empty”, “function”, “function”“f”, undefined, “function”, error“f”, “Empty”, “function”, errorother What is the result of this expression? (or multiple ones) var lowerCaseOnly = /^[a-z]+$/;[lowerCaseOnly.test(null), lowerCaseOnly.test()] [true, false]error[true, true][false, true] What is the result of this expression? (or multiple ones) [,,,].join(“, “) “, , , ““undefined, undefined, undefined, undefined”“, , ““” What is the result of this expression? (or multiple ones) var a = {class: “Animal”, name: ‘Fido’};a.class “Animal”Objectan errorother What is the result of this expression? (or multiple ones) var a = new Date(“epoch”) Thu Jan 01 1970 01:00:00 GMT+0100 (CET)current timeerrorother What is the result of this expression? (or multiple ones) var a = Function.length, b = new Function().lengtha === b truefalseerrorother What is the result of this expression? (or multiple ones) var a = Date(0);var b = new Date(0);var c = new Date();[a === b, b === c, a === c] [true, true, true][false, false, false][false, true, false][true, false, false] What is the result of this expression? (or multiple ones) var min = Math.min(), max = Math.max()min &lt; max truefalseerrorother What is the result of this expression? (or multiple ones) function captureOne(re, str) { var match = re.exec(str); return match &amp;&amp; match[1];}var numRe = /num=(\d+)/ig, wordRe = /word=(\w+)/i, a1 = captureOne(numRe, “num=1”), a2 = captureOne(wordRe, “word=1”), a3 = captureOne(numRe, “NUM=2”), a4 = captureOne(wordRe, “WORD=2”);[a1 === a2, a3 === a4] [true, true][false, false][true, false][false, true] What is the result of this expression? (or multiple ones) var a = new Date(“2014-03-19”), b = new Date(2014, 03, 19);[a.getDay() === b.getDay(), a.getMonth() === b.getMonth()] [true, true][true, false][false, true][false, false] What is the result of this expression? (or multiple ones) if (‘http://giftwrapped.com/picture.jpg&#39;.match(&#39;.gif‘)) { ‘a gif file’} else { ‘not a gif file’} ‘a gif file’‘not a gif file’errorother What is the result of this expression? (or multiple ones) function foo(a) { var a; return a;}function bar(a) { var a = ‘bye’; return a;}[foo(‘hello’), bar(‘hello’)] [“hello”, “hello”][“hello”, “bye”][“bye”, “bye”]other]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript中的Function对象总结]]></title>
    <url>%2F2017%2F08%2F12%2Fjs-function%2F</url>
    <content type="text"><![CDATA[属性argumentsarguments是一个类似数组的对象, 对应于传递给函数的参数。arguments对象是所有函数中可用的局部变量。你可以使用arguments对象在函数中引用函数的参数。此对象包含传递给函数的每个参数的条目，第一个条目的索引从0开始。 转换数组arguments对象不是一个Array。它类似于数组，但除了长度之外没有任何数组属性。例如，它没有pop方法。但是它可以被转换为一个真正的数组：123let args = Array.prototype.slice.call(arguments); let args = [].slice.call(arguments); 你还可以使用Array.from()方法或spread运算符将arguments转换为真正的数组：12let args = Array.from(arguments);let args = [...arguments]; 属性arguments.callee指向当前执行的函数。arguments.length指向传递给当前函数的参数数量。 lengthlength是函数对象的一个属性值，指该函数有多少个必须要传入的参数，那些已定义了默认值的参数不算在内，比如function（xx = 0）的length是0。与之对比的是，arguments.length是函数被调用时实际传参的个数。 Function构造器本身也是个Function。他的length属性值为 1 。该属性 Writable: false, Enumerable: false,Configurable: true。 Function原型对象的length属性值为 0 。 方法Function.prototype.apply()apply()方法调用一个函数, 其具有一个指定的this值，以及作为一个数组（或类似数组的对象）提供的参数。 语法：1func.apply(thisArg, [argsArray]) 参数thisArg在func函数运行时指定的this值。需要注意的是，指定的this值并不一定是该函数执行时真正的this值，如果这个函数处于非严格模式下，则指定为null或undefined时会自动指向全局对象（浏览器中就是window对象），同时值为原始值（数字，字符串，布尔值）的this会指向该原始值的自动包装对象。argsArray一个数组或者类数组对象，其中的数组元素将作为单独的参数传给func函数。如果该参数的值为null或undefined，则表示不需要传入任何参数。从ECMAScript5开始可以使用类数组对象。浏览器兼容性请参阅本文底部内容。 描述在调用一个存在的函数时，你可以为其指定一个this对象。this指当前对象，也就是正在调用这个函数的对象。 使用 apply， 你可以只写一次这个方法然后在另一个对象中继承它，`而不用在新对象中重复写该方法。 apply与call非常相似，不同之处在于提供参数的方式。apply使用参数数组而不是一组参数列表（原文：a named set of parameters）。apply可以使用数组字面量（array literal），如 fun.apply(this, [&#39;eat&#39;, &#39;bananas&#39;])，或数组对象， 如fun.apply(this, new Array(&#39;eat&#39;, &#39;bananas&#39;))。 你也可以使用arguments对象作为argsArray参数。arguments是一个函数的局部变量。它可以被用作被调用对象的所有未指定的参数。这样，你在使用apply函数的时候就不需要知道被调用对象的所有参数。 你可以使用arguments来把所有的参数传递给被调用对象。 被调用对象接下来就负责处理这些参数。 Function.prototype.call()call()方法调用一个函数,其具有一个指定的this值和分别地提供的参数(参数的列表)。 注意：该方法的作用和apply()方法类似，只有一个区别，就是call()方法接受的是若干个参数的列表，而apply()方法接受的是一个包含多个参数的数组。 语法1func.call(thisArg[, arg1[, arg2[, ...]]]) 参数thisArg在func函数运行时指定的this值。需要注意的是，指定的this值并不一定是该函数执行时真正的this值，如果这个函数处于非严格模式下，则指定为null和undefined的this值会自动指向全局对象(浏览器中就是window对象)，同时值为原始值(数字，字符串，布尔值)的this会指向该原始值的自动包装对象。arg1, arg2, ...指定的参数列表。 返回值返回结果包括指定的this值和参数。 描述可以让call()中的对象调用当前对象所拥有的function。你可以使用call()来实现继承：写一个方法，然后让另外一个新的对象来继承它（而不是在新对象中再写一次这个方法）。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试总结]]></title>
    <url>%2F2017%2F08%2F09%2Finterview%2F</url>
    <content type="text"><![CDATA[一、开放性题目为什么选择前端？项目遇到的问题及如何解决？二、技术性问题 JS类问题作用域原型闭包继承 面向对象和继承，object.create的实现原理?设计模式Jquery Jquery特性及优缺点？ES6 特性 ES6中的箭头函数可以用作构造函数吗？ 答：项目中用到了很多ES6语法，对ES6有一点了解。箭头函数不可以作为构造函数，因为箭头函数内部并没有this，它的this其实是函数外层的this，因次不可以用new操作符调用，所以不可以作为构造函数使用。 Ajax前端JS框架React/Vue/NG NG的双向数据绑定?面向切面编程和函数式编程跨域 postmessage和iframe怎么结合使用? 那些操作会有跨域的限制？为什么要有跨域的限制？没有跨域的限制会怎么样？ 答：我只想到ajax请求会有跨域的限制（应该还有别的）。为了安全性考虑，如果通过ajax请求受到了一段恶意代码，所以会有很大的隐患。接着面试官问：就算接收到了恶意代码，你不添加到html中，恶意代码也不会执行呀！然后我就懵逼了。。。深拷贝怎么实现 CSS问题浏览器CSS hack实现bootstrap栅格系统Canvas Canvas上画个圆，可以用诸如getElementById()之类的方法获取吗？ 答：不可以，canvas是通过js绘制的图形，图形是一个一个像素画上去的，不可以获取到。但是svg是基于XML格式，内部是一个个节点，可以用DOM操作获取节点。 canvas上的图像获取到吗？ 答：可以，canvas原生的toDataURL()方法获取图像的Base64编码 计算机网络问题HTTP、HTTPS协议TCP/IP协议Web后台问题(node) 后端为什么使用node？express/koa自动化构建工具 你使用过的构建工具，说说对webpack的理解?图片压缩、上传、下载和缓存 数据库问题 数据库缓存 前端安全 HTTPS sql注入 xss攻击 csrf攻击 移动端问题数据结构和算法 快速排序 二叉排序树]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS hack]]></title>
    <url>%2F2017%2F08%2F09%2Fhack%2F</url>
    <content type="text"></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>hack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript操作DOM总结]]></title>
    <url>%2F2017%2F08%2F07%2Fjs-dom%2F</url>
    <content type="text"><![CDATA[Node.innerTextNode.innerText 是一个表示一个节点及其后代的“渲染”文本内容的属性。 作为一个获取器，如果用光标突出显示元素的内容，然后将其复制到剪贴板，则它将近似于用户将获得的文本。此功能最初由Internet Explorer引入，并在所有主要浏览器供应商采用后于2016年在HTML标准中正式规定。 Node.textContent是一个有点类似的替代方案，虽然两者之间有重要的区别。 element.innerHTMLElement.innerHTML属性设置或获取描述元素后代的HTML语句。 Note: 如果一个&lt;div&gt;,&lt;span&gt;, 或 &lt;noembed&gt;节点具有一个文本子节点,包含字符(&amp;),(&lt;), 或(&gt;), innerHTML将这些字符分别返回为＆amp;, ＆lt;和＆gt;。使用Node.textContent获取一个这些文本节点内容的正确副本。]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript零散笔记]]></title>
    <url>%2F2017%2F08%2F06%2Fjs-other%2F</url>
    <content type="text"><![CDATA[JavaScript 中包含以下 7 个全局函数，用于完成一些常用的功能：escape( )、eval( )、isFinite( )、isNaN( )、parseFloat( )、parseInt( )、unescape( )。 JavaScript为指定元素绑定一个事件处理器函数 Javascript块内声明函数 不要在块内声明一个函数（严格模式会报语法错误）。如果确实需要在块中定义函数，可以使用函数表达式来声明函数。 12345678910/* Recommended */if (x) &#123; var foo = function() &#123;&#125;;&#125;/* Wrong */if (x) &#123; function foo() &#123;&#125;&#125; Jquery获取宽高 12345678alert($(window).height()); //浏览器当前窗口可视区域高度 alert($(document).height()); //浏览器当前窗口文档的高度 alert($(document.body).height());//浏览器当前窗口文档body的高度 alert($(document.body).outerHeight(true));//浏览器当前窗口文档body的总高度 包括border padding margin alert($(window).width()); //浏览器当前窗口可视区域宽度 alert($(document).width());//浏览器当前窗口文档对象宽度 alert($(document.body).width());//浏览器当前窗口文档body的高度 alert($(document.body).outerWidth(true));//浏览器当前窗口文档body的总宽度 包括border padding margin 浏览器兼容性问题 SD9017: Firefox 不支持 DOM 对象的 outerHTML、innerText、outerText 属性(参见http://w3help.org/zh-cn/causes/SD9017) SD9010: 仅 IE 中的 createElement 方法支持传入 HTML String 做参数 SD9006: IE 混淆了 DOM 对象属性（property）及 HTML 标签属性（attribute），造成了对 setAttribute、getAttribute 的不正确实现 2017.08.15更新 parseInt()parseInt() 函数解析一个字符串参数，并返回一个指定基数的整数 (数学系统的基础)。 语法1parseInt(string, radix); 参数string要被解析的值。如果参数不是一个字符串，则将其转换为字符串(使用ToString抽象操作)。字符串开头的空白符将会被忽略。radix一个介于2和36之间的整数(数学系统的基础)，表示上述字符串的基数。比如参数”10”表示使用我们通常使用的十进制数值系统。始终指定此参数可以消除阅读该代码时的困惑并且保证转换结果可预测。当未指定基数时，不同的实现会产生不同的结果，通常将值默认为10。 返回值返回解析后的整数值。 如果被解析参数的第一个字符无法被转化成数值类型，则返回NaN。 描述parseInt函数将其第一个参数转换为字符串，解析它，并返回一个整数或NaN。如果不是NaN，返回的值将是作为指定基数（基数）中的数字的第一个参数的整数。例如：radix参数为10将会把第一个参数看作是一个数的十进制表示，8对应八进制，16对应十六进制，等等。基数大于10时，用字母表中的字母来表示大于9的数字。例如十六进制中，使用A到F。如果parseInt遇到了不属于radix参数所指定的基数中的字符那么该字符和其后的字符都将被忽略。接着返回已经解析的整数部分。parseInt将截取整数部分。开头和结尾的空白符允许存在，会被忽略。在没有指定基数，或者基数为0的情况下，JavaScript作如下处理： 如果字符串string以”0x”或者”0X”开头,则基数是16(16进制). 如果字符串string以”0”开头,基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript5规定使用10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出radix参数的值。 如果字符串string以其它任何值开头，则基数是10(十进制)。 如果第一个字符不能被转换成数字，parseInt返回NaN。 算术上，NaN不是任何一个进制下的数。你可以调用isNaN来判断parseInt是否返回NaN。NaN参与的数学运算其结果总是NaN。将整型数值以特定基数转换成它的字符串值可以使用intValue.toString(radix). null与undefined值null是一个 JavaScript 字面量，表示空值（null or an “empty” value），即没有对象被呈现（no object value is present）。它是JavaScript原始数据类型之一。 全局属性undefined表示原始值undefined。它是一个JavaScript的原始数据类型 。JavaScript的原始数据类型：String,Number,Bollean,null,undefined,symbol(ES2015新增) null与undefined的不同点：123456789typeof null // object (因为一些以前的原因而不是&apos;null&apos;)typeof undefined // undefinednull === undefined // falsenull == undefined // truenull === null // truenull == null // true!null //trueisNaN(1 + null) // falseisNaN(1 + undefined) // true js精度丢失计算机的二进制实现和位数限制有些数无法有限表示。就像一些无理数不能有限表示，如 圆周率 3.1415926…，1.3333… 等。JS 遵循 IEEE 754 规范，采用双精度存储（double precision），占用 64 bit。解决方案： 对于整数，前端出现问题的几率可能比较低，毕竟很少有业务需要需要用到超大整数，只要运算结果不超过 Math.pow(2, 53) 就不会丢失精度。 对于小数，前端出现问题的几率还是很多的，尤其在一些电商网站涉及到金额等数据。解决方式：把小数放到位整数（乘倍数），再缩小回原来倍数（除倍数） switchswitch()使用===判断相等]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript函数和作用域总结]]></title>
    <url>%2F2017%2F08%2F05%2Fjs-scope%2F</url>
    <content type="text"><![CDATA[一、执行环境和作用域执行环境(execution context)定义了函数或变量有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象(variable object)，环境中定义的所有变量和函数都保存在这个对象中。全局执行环境是最外围的一个执行环境。某个执行环境的所有代码执行完毕后，该环境销毁，保存在其中的所有变量和函数定义也随之销毁。（全局执行环境直到应用程序退出才会销毁）每个函数都有自己的执行环境。当执行流程进入一个函数时，函数的环境就会被推入一个环境栈中，在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。 当代码在一个环境中执行时，会创建变量对象的一个作用域链(scope chain)。作用域的用途是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端始终是当前执行的代码所在的环境的变量对象。如果这个环境是函数，则将其活动对象(activation object)作为变量对象。活动对象最开始只包含一个变量，即arguments对象(这个对象在全局环境中不存在的)，作用域链中的下一个对象来自包含(外部)环境，一直延续到全局执行环境。全局执行环境的变量对象始终都是作用域链的最后一个对象。 标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程中始终从作用域链的前端开始。搜索过程始终从作用域链的前端开始然后逐级地向后回溯，知道找到标识符为止（若找不到，通常会导致错误发生） js没有块级作用域，但是在es6中新增let关键字可定义块级变量。 二、函数定义 函数声明 123function sum(num1,num2)&#123; return num1 + num2;&#125; 函数表达式 123var sum = function(num1,num2)&#123; return num1 + num2;&#125; 解析器会率先读取函数声明，并使其在执行任何代码之前可用(可以访问)； 函数表达式则必须等到解析器执行到它所在的代码行，才会真正被解析执行。 在代码开始之前，解析器就已通过一个名为函数声明提升(function declaration hoisting)的过程，将函数声明添加到执行环境中。对代码求值时，Javascript引擎在第一遍会声明函数并将他们放到源代码树的顶部。所以，即使声明函数的代码在调用它的代码后面，Javascript引擎也能把函数声明提升到顶部。 Function构造函数 12//接收任意数量参数，最后一个参数始终被看做函数体var sum = new Function(&apos;num1&apos;,&apos;num2&apos;,&apos;return num1 + num2&apos;);//不推荐 函数是对象，函数名是指针 没有重载同名函数后一个函数会覆盖前一个函数，不会发生函数重载 三、参数传递 基本类型按值传递 1234567function setNum(num)&#123; num += 10; return num;&#125;var a = 10;var result = setNum(a);console.log(result);//20 引用类型按指针的值传递，并非按引用传递 1234567891011121314151617181920 function setObj(obj)&#123; obj.name = &apos;zxlg&apos;; return obj; &#125; var person = new Object(); setObj(person); console.log(person.name);// &apos;zxlg&apos;//使用对象，看似按引用传递，//其实不然，参数传递的是指针的值，//指针的值是不会变的，指针指向的内容有可能会被改变 function setObj(obj)&#123; obj.name = &apos;zxlg&apos;; obj = new Object(); obj.name = &apos;fool&apos;; return obj; &#125; var person = new Object(); setObj(person); console.log(person.name);//&apos;zxlg&apos; 四、arguments对象和this对象arguments对象类数组对象，包含着传入函数中的所有参数，可以用方括号访问它的每一个元素，使用length来确定传进多少个元素。函数命名的参数只提供便利，但不是必需的。1234function doAdd(num1,num2)&#123; arguments[1] = 10; console.log(arguments[0] + num2);&#125; arguments的值永远与对应命名参数的值保持同步。在非严格模式下，重写arguments[1]，也就修改了num2,结果均变为10(严格模式下重写arguments的值会导致语法错误)。但它们的内存空间是独立的，而arguments的值会与参数的值同步。 若只传入一个参数，那么arguments[1]设置的值不会反应到命名参数中，因为arguments对象的长度是由传入参数的个数决定的，不是由定义函数的参数的个数决定的。 没有传递值的命名参数自动被赋予undefined值，类似于定义变量但没有初始化。 arguments的主要用途是保存函数参数，但这个对象还有一个名叫callee的属性，该属性是一个指针，指向这个拥有arguments对象的函数。12345678//阶乘函数function factorial(num)&#123; if(num &lt; 1)&#123; return 1; &#125;else&#123; return num * factorial(num - 1); &#125;&#125; 函数有名字，函数的执行与函数名factorial紧紧耦合在一起，使用arguments.callee可消除这种耦合。1234567function factorial(num)&#123; if(num &lt; 1)&#123; return 1; &#125;else&#123; return num * arguments.callee(num - 1); &#125;&#125; this对象this引用的是函数执行的环境对象，即调用函数的那个对象。参考阮老师的文章 纯粹的函数调用 这是函数的最通常用法，属于全局性调用，因此this就代表全局对象Global。 123456var x = 1; function test()&#123; this.x = 0; &#125; test(); alert(x); //0 作为对象方法的调用 函数还可以作为某个对象的方法调用，这时this就指这个上级对象。 1234567function test()&#123; alert(this.x); &#125; var o = &#123;&#125;; o.x = 1; o.m = test; o.m(); // 1 作为构造函数调用 所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象。 123456var x = 2; function test()&#123; this.x = 1; &#125; var o = new test(); alert(x); //2 apply调用 apply()是函数对象的一个方法，它的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。因此，this指的就是这第一个参数。 123456789var x = 0; function test()&#123; alert(this.x); &#125; var o=&#123;&#125;; o.x = 1; o.m = test; o.m.apply(); //0 o.m.apply(o); //1 五、prototype属性六、变量提升变量提升(Hoisting)被认为是思考执行上下文（特别是创建和执行阶段）在JavaScript中如何工作的一般方式。但变量提升(Hoisting)可能会导致误解。例如，提升教导变量和函数声明被物理移动到编码的顶部，这不算什么。真正发生的什么是在编译阶段将变量和函数声明放入内存中，但仍然保留在编码中键入的位置。1234567891011121314151617181920212223242526/*** 不推荐的方式：先调用函数，再声明函数 */catName(&quot;Chloe&quot;);function catName(name) &#123; console.log(&quot;My cat&apos;s name is &quot; + name);&#125;/*The result of the code above is: &quot;My cat&apos;s name is Chloe&quot;*/// 等价于/*函数声明提升*/function catName(name) &#123; console.log(&quot;My cat&apos;s name is &quot; + name);&#125;catName(&quot;Tigger&quot;);/*The result of the code above is: &quot;My cat&apos;s name is Chloe&quot;*/ 即使我们先在代码中调用函数，在写该函数之前，代码仍然可以工作。 Hoisting 也适用于其他数据类型和变量。变量可以在声明之前进行初始化和使用。但是如果没有初始化，就不能使用。JavaScript 仅提升声明，而不是初始化。如果你使用的是在使用后声明和初始化的一个变量，那么该值将是 undefined。以下两个示例演示了相同的行为。12345678910111213141516var x = 1; // 声明 + 初始化 xconsole.log(x + &quot; &quot; + y); // y 是未定义的var y = 2;// 声明 + 初始化 y//上面的代码和下面的代码是一样的 var x = 1; // 声明 + 初始化 xvar y; //声明 yconsole.log(x + &quot; &quot; + y); //y 是未定义的y = 2; // 初始化 y ES6 : let 不存在 Hoisting 七、检测类型 检测基本数据类型：typeof 123456var str = &apos;zxlg&apos;; console.log(typeof str); // stringvar num = 9; console.log(typeof num);// numbervar bool = true; console.log(typeof bool);// booleanvar u; console.log(typeof u);// undefinedvar nul = null; console.log(typeof nul);// objectvar obj = new Object(); console.log(typeof obj);// object 检测引用类型：instanceoftypeof检测所有引用类型均为object，想得到何种引用类型可使用instanceof (2017.8.7新增)检测一个引用类型值和Object构造函数时，instanceof操作符始终会返回true。如果使用instanceof操作符检测基本类型的值，则该操作符始终会返回false,因为基本类型都不是对象。 123456var arr = [1,2,3];console.log(arr instanceof Object); // trueconsole.log(arr instanceof Array); // truevar reg = /\d+/;console.log(arr instanceof Array); // falseconsole.log(arr instanceof RegExp); // true 参考文献 MDN变量提升 Javascript高级程序设计(第3版) Javascript的this用法]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议总结]]></title>
    <url>%2F2017%2F08%2F05%2Fhttp%2F</url>
    <content type="text"><![CDATA[HTTPHTTPS参考文献：1.阮一峰的网络网络日志]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP/IP协议总结]]></title>
    <url>%2F2017%2F08%2F05%2Ftcp-ip%2F</url>
    <content type="text"><![CDATA[暂封]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>ip</tag>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript异步总结]]></title>
    <url>%2F2017%2F08%2F05%2Fjs-async%2F</url>
    <content type="text"><![CDATA[暂封]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>async</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端Ajax操作总结]]></title>
    <url>%2F2017%2F08%2F05%2Fajax%2F</url>
    <content type="text"><![CDATA[暂封]]></content>
      <categories>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《影响力》读书笔记]]></title>
    <url>%2F2017%2F08%2F05%2Feffect%2F</url>
    <content type="text"><![CDATA[于2017.7.1读完，于2017.8.5建立读书笔记暂封]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《自控力》读书笔记]]></title>
    <url>%2F2017%2F08%2F05%2Fself-control%2F</url>
    <content type="text"><![CDATA[于2017.7.22读完，于2017.8.5建读书笔记暂封 更新]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown技巧]]></title>
    <url>%2F2017%2F08%2F04%2Fmarkdown%2F</url>
    <content type="text"><![CDATA[一、代码代码区块 第一种，只要简单地缩进 4 个空格或是 1 个制表符就可以 第二种，在代码段落的头部和尾部用```包围起来 行内代码块用` `包围 二、链接 文字链接 1[链接名称](http://链接网址) 网址链接 1&lt;http://链接网址&gt; 三、图片 行内式 1![alt图片名称](http://图片网址) 参考式 1![alt图片名称][本地图片地址] 目前为止Markdown 还没有办法指定图片的宽高，如果需要，可以使用普通的&lt;img&gt;标签。 四、表格单元格和表头使用|来分隔不同的单元格，使用-来分隔表头和其他行：1234name | age---- | ---LearnShare | 12Mike | 32 name age LearnShare 12 Mike 32 对齐在表头下方的分隔线标记中加入:，即可标记下方单元格内容的对齐方式： :---代表左对齐:--:代表居中对齐---:代表右对齐1234| left | center | right || :--- | :----: | ----: || aaaa | bbbbbb | ccccc || a | b | c | left center right aaaa bbbbbb ccccc a b c 五、内嵌HTML不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown，只要直接加标签就可以了。 注意 HTML 区块元素，比如 &lt;div&gt;、&lt;table&gt;、&lt;pre&gt;、&lt;p&gt; 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 &lt;p&gt;标签。 六、公式如果想要在Markdown文档中显示一个公式就需要先插入下面一句话，这实际上是插入了一个图片。1![公式名](http://latex.codecogs.com/png.latex?这里输入您的公式) 上面这句话是插入一个png图片格式的公式，而下面这句话则是插入gif图片格式的公式。1![公式名](http://latex.codecogs.com/png.latex?这里输入您的公式) 七、转义Markdown符号用反斜杠\转义 2017.08.15更新 八、横线在一行中用三个以上的星号(*)、减号(-)、下划线(_)来建立一个分隔线；除空格外行内不能有其他字符；（除第一个符号的左侧最多添加三个空格外）三个相同符号两侧可以添加任意多个空格。 参考文献 Markdown教程 Markdown 编辑器语法指南]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript相等性比较]]></title>
    <url>%2F2017%2F08%2F04%2Fjs-equal%2F</url>
    <content type="text"><![CDATA[JavaScript有两种比较方式：严格比较运算符和转换类型比较运算符。对于严格比较运算符（===）来说，仅当两个操作数的类型相同且值相等为true，而对于被广泛使用的比较运算符（==）来说，会在进行比较之前，将两个操作数转换成相同的类型。对于关系运算符（比如 &lt;=）来说，会先将操作数转为原始值，使它们类型相同，再进行比较运算。 字符串比较则是使用基于标准字典的Unicode值来进行比较的。 一、宽松相等(==)比较操作符会为两个不同类型的操作数转换类型，然后进行严格比较。当两个操作数都是对象时，JavaScript会比较其内部引用，当且仅当他们的引用指向内存中的相同对象（区域）时才相等，即他们在栈内存中的引用地址相同。 当比较数字和字符串时，字符串会转换成数字值。 JavaScript 尝试将数字字面量转换为数字类型的值。 首先, 一个数学上的值会从数字字面量中衍生出来，然后得到被四舍五入后的数字类型的值。 如果其中一个操作数为布尔类型，那么布尔操作数如果为true，那么会转换为1，如果为false，会转换为整数0，即0。 如果是一个对象与数字或字符串向比较，JavaScript会尝试返回对象的默认值。操作符会尝试将对象转换为其原始值（一个字符串或数字值）通过方法valueOf和toString。如果尝试转换失败，会产生一个运行时错误。 注意：当且仅当与原始值比较时，对象会被转换为原始值。当两个操作数均为对象时，它们作为对象进行比较，仅当它们引用相同对象时返回true。 在上面的表格中，ToNumber(A) 尝试在比较前将参数A转换为数字，这与+A（单目运算符+）的效果相同。通过尝试依次调用A的A.toString和A.valueOf方法，将参数A转换为原始值（Primitive）。一般而言，根据 ECMAScript 规范，所有的对象都与undefined和null不相等。但是大部分浏览器允许非常窄的一类对象（即，所有页面中的document.all对象），在某些情况下，充当效仿undefined的角色。相等操作符就是在这样的一个背景下。因此，IsFalsy(A)方法的值为true，当且仅当A效仿undefined。在其他所有情况下，一个对象都不会等于undefined或null。 二、一致/严格相等(===)一致运算符不会进行类型转换，仅当操作数严格相等时返回true123456789101112131415var num = 0;var obj = new String(&quot;0&quot;);var str = &quot;0&quot;;var b = false;console.log(num === num); // trueconsole.log(obj === obj); // trueconsole.log(str === str); // trueconsole.log(num === obj); // falseconsole.log(num === str); // falseconsole.log(obj === str); // falseconsole.log(null === undefined); // falseconsole.log(obj === null); // falseconsole.log(obj === undefined); // false 对于除了数值之外的值，全等操作符使用明确的语义进行比较：一个值只与自身全等。对于数值，全等操作符使用略加修改的语义来处理两个特殊情况：第一个情况是，浮点数0是不分正负的。区分+0和-0在解决一些特定的数学问题时是必要的，但是大部分境况下我们并不用关心。全等操作符认为这两个值是全等的。第二个情况是，浮点数包含了NaN值，用来表示某些定义不明确的数学问题的解，例如：正无穷加负无穷。全等操作符认为NaN与其他任何值都不全等，包括它自己。（等式 (x !== x) 成立的唯一情况是 x 的值为NaN） 三、Object.is （ECMAScript 2015/ ES6 新特性）Object.is的行为方式与三等式相同，但是对于NaN和-0和+0进行特殊处理，所以最后两个不相同，而Object.is（NaN，NaN）将为true。(通常使用双等号或三等于将NaN与NaN进行比较结果为false，因为IEEE 754如是说。)除了+0和-0,其他时候避免使用Object.is,包括NaN。 四、判等表 x y == === Object.is undefined undefined true true true null null true true true true true true true true false false true true true “foo” “foo” true true true { foo: “bar” } x true true true 0 0 true true true +0 -0 true true false 0 false true false false “” false true false false “” 0 true false false “0” 0 true false false “17” 17 true false false [1,2] “1,2” true false false new String(“foo”) “foo” true false false null undefined true false false null false false false false undefined false false false false { foo: “bar” } { foo: “bar” } false false false new String(“foo”) new String(“foo”) false false false 0 null false false false 0 NaN false false false “foo” NaN false false false NaN NaN false false true 1234567891011121314// true 两个操作数均为String&apos;foo&apos; === &apos;foo&apos;var a = new String(&apos;foo&apos;);var b = new String(&apos;foo&apos;);// false a,b对象引用不同a == b // false a,b均为对象，但是引用不同a === b // true 操作数类型不同，对象a转换为String类型a == &apos;foo&apos; 五、参见==比较表 if()比较表(2017.8.6新增) Javascript比较表 参考文献 MDN比较运算符 MDN相等性比较 ECMAScript官方文件 js比较表]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript中的Array对象总结]]></title>
    <url>%2F2017%2F08%2F03%2Fjs-Array%2F</url>
    <content type="text"><![CDATA[一、属性Array.lengthlength属性的值是一个 0 到 2^32-1的整数。 你可以通过减小length属性的值来截短一个数组，但不能通过增大length属性的值来延长这个数组 Array.prototypeArray.prototype属性表示Array构造函数的原型;Array.prototype本身也是一个Array 二、方法Array.prototype.concat()不改变数组 语法var new_array = old_array.concat(value1[, value2[, ...[, valueN]]]) 参数valueN需要与原数组合并的数组或非数组值。详见下文。 返回值新的Array实例。 描述concat方法将创建一个新的数组，然后将调用它的对象(this指向的对象)中的元素以及所有参数中的数组类型的参数中的元素以及非数组类型的参数本身按照顺序放入这个新数组,并返回该数组. concat方法并不修改调用它的对象(this指向的对象) 和参数中的各个数组本身的值,而是将他们的每个元素拷贝一份放在组合成的新数组中.原数组中的元素有两种被拷贝的方式: 对象引用(非对象直接量):concat方法会复制对象引用放到组合的新数组里,原数组和新数组中的对象引用都指向同一个实际的对象,所以,当实际的对象被修改时,两个数组也同时会被修改. 字符串和数字(是原始值,而不是包装原始值的String和Number对象):concat方法会复制字符串和数字的值放到新数组里 Array.prototype.filter()语法var new_array = arr.filter(callback[, thisArg]) 参数callback用来测试数组的每个元素的函数。调用时使用参数(element, index, array)。返回true表示保留该元素（通过测试），false则不保留。thisArg可选。执行callback时的用于this的值。 返回值一个新的通过测试的元素的集合的数组 描述filter为数组中的每个元素调用一次callback函数，并利用所有使得callback返回true或等价于true的值的元素创建一个新数组。callback只会在已经赋值的索引上被调用，对于那些已经被删除或者从未被赋值的索引不会被调用。那些没有通过callback测试的元素会被跳过，不会被包含在新数组中。callback被调用时传入三个参数： 元素的值 元素的索引 被遍历的数组 如果为filter提供一个thisArg参数，则它会被作为callback被调用时的this值。否则，callback的this值在非严格模式下将是全局对象，严格模式下为undefined。 filter不会改变原数组。filter遍历的元素范围在第一次调用callback之前就已经确定了。在调用filter之后被添加到数组中的元素不会被filter遍历到。如果已经存在的元素被改变了，则他们传入callback的值是filter遍历到它们那一刻的值。被删除或从来未被赋值的元素不会被遍历到。 Array.prototype.find()Array.prototype.forEach()语法1234array.forEach(callback(currentValue, index, array)&#123; //do something&#125;, this)array.forEach(callback[, thisArg]) 参数callback为数组中每个元素执行的函数，该函数接收三个参数： currentValue(当前值)数组中正在处理的当前元素。 index(索引)数组中正在处理的当前元素的索引。 array``forEach()方法正在操作的数组。 thisArg可选参数。当执行回调 函数时用作this的值(参考对象)。 返回值undefined 描述forEach方法按升序为数组中含有效值的每一项执行一次callback函数，那些已删除（使用delete方法等情况）或者未初始化的项将被跳过（但不包括那些值为undefined的项）（例如在稀疏数组上）。callback函数会被依次传入三个参数： 数组当前项的值 数组当前项的索引 数组对象本身 如果给forEach传递了thisArg参数，当调用时，它将被传给callback函数，作为它的this值。否则，将会传入undefined作为它的this值。callback函数最终可观察到this值，这取决于函数观察到this的常用规则。forEach遍历的范围在第一次调用callback前就会确定。调用forEach后添加到数组中的项不会被callback访问到。如果已经存在的值被改变，则传递给callback的值是forEach遍历到他们那一刻的值。已删除的项不会被遍历到。如果已访问的元素在迭代时被删除了(例如使用shift()) ，之后的元素将被跳过.forEach()为每个数组元素执行callback函数；不像map()或者reduce() ，它总是返回undefined值，并且不可链式调用。典型用例是在一个链的最后执行副作用。 Array.prototype.indexOf()indexOf()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。 语法12arr.indexOf(searchElement)arr.indexOf(searchElement[, fromIndex = 0]) 参数searchElement要查找的元素。fromIndex开始查找的位置。如果该索引值大于或等于数组长度，意味着不会在数组里查找，返回-1。如果参数中提供的索引值是一个负值，则将其作为数组末尾的一个抵消，即-1表示从最后一个元素开始查找，-2表示从倒数第二个元素开始查找，以此类推。注意：如果参数中提供的索引值是一个负值，仍然从前向后查询数组。如果抵消后的索引值仍小于0，则整个数组都将会被查询。其默认值为0. 返回值首个被找到的元素在数组中的索引位置;若没有找到则返回-1 Array.prototype.join()不改变数组 Array.prototype.keys()Array.prototype.values()Array.prototype.entries()Array.prototype.pop()Array.prototype.push()Array.prototype.shift()Array.prototype.unshift()Array.prototype.map()语法123let array = arr.map(function callback(currentValue, index, array) &#123; // Return element for new_array &#125;[, thisArg]) 参数callback生成新数组元素的函数，使用三个参数：currentValue``callback的第一个参数，数组中正在处理的当前元素。index``callback的第二个参数，数组中正在处理的当前元素的索引。array``callback的第三个参数，map方法被调用的数组。thisArg可选的。执行callback函数时,使用的this值。 返回值一个新数组，每个元素都是回调函数的结果。 描述map方法会给原数组中的每个元素都按顺序调用一次callback函数。callback每次执行后的返回值（包括undefined）组合起来形成一个新数组。callback函数只会在有值的索引上被调用；那些从来没被赋过值或者使用delete删除的索引则不会被调用。callback函数会被自动传入三个参数：数组元素，元素索引，原数组本身。如果thisArg参数有值，则每次callback函数被调用的时候，this都会指向thisArg参数上的这个对象。如果省略了thisArg参数,或者赋值为null或undefined，则this指向全局对象。map不修改调用它的原数组本身（当然可以在callback执行时改变原数组）。使用map方法处理数组时，数组元素的范围是在callback方法第一次调用之前就已经确定了。在map方法执行的过程中：原数组中新增加的元素将不会被callback访问到；若已经存在的元素被改变或删除了，则它们的传递到callback的值是map方法遍历到它们的那一时刻的值；而被删除的元素将不会被访问到。 Array.prototype.reduce()语法array.reduce(function(accumulator, currentValue, currentIndex, array), initialValue) 参数callback执行数组中每个值的函数，包含四个参数accumulator上一次调用回调返回的值，或者是提供的初始值initialValuecurrentValue数组中正在处理的元素currentIndex数据中正在处理的元素索引,如果提供了initialValue,从0开始;否则从1开始array调用reduce的数组initialValue可选项，其值用于第一次调用callback的第一个参数。如果没有设置初始值，则将数组中的第一个元素作为初始值。空数组调用reduce时没有设置初始值将会报错。 返回值函数累计处理的结果 描述reduce为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，接受四个参数：accumulator初始值（或者上一次回调函数的返回值）currentValue当前元素值currentIndex当前索引array调用reduce的数组。回调函数第一次执行时，accumulator和currentValue的取值有两种情况：调用reduce时提供initialValue，accumulator取值为initialValue，currentValue取数组中的第一个值；没有提供initialValue，accumulator取数组中的第一个值，currentValue取数组中的第二个值。注意: 不提供initialValue，reduce会从索引1的地方开始执行callback方法，跳过第一个索引。提供initialValue，从索引0开始。 如果数组为空并且没有提供initialValue，会抛出TypeError。如果数组仅有一个元素（无论位置如何）并且没有提供initialValue，或者有提供initialValue但是数组为空，那么此唯一值将被返回并且callback不会被执行。 Array.prototype.reduceRight()Array.prototype.sort()改变数组 Array.prototype.reverse()改变数组 Array.prototype.slice()注意:’slice()’为浅拷贝,不改变数组 语法arr.slice(begin,end) 参数begin可选，从索引处开始提取，默认为0。如果参数为负数-a，从倒数第a个元素开始提取。slice(-2)表示从倒数第二提取到倒数第一(包含最后一个元素)。end可选，从索引处结束提取。slice(begin,end)包含begin但不包含end。如果为负数表示在倒数第几个结束提取，slice(-2,-1),不包含最后一个。end省略或大于数组长度，一直提取到原数组末尾 返回值一个含有提取元素的新数组 描述slice()不会修改数组，只会浅拷贝，规则如下： 对象引用(非对象直接量):concat方法会复制对象引用放到组合的新数组里,原数组和新数组中的对象引用都指向同一个实际的对象,所以,当实际的对象被修改时,两个数组也同时会被修改. 对于字符串、数字及布尔值来说（不是String、Number或者Boolean对象），slice会拷贝这些值到新的数组里。在别的数组里修改这些字符串或数字或是布尔值，将不会影响另一个数组。 如果向两个数组任一中添加了新元素，则另一个不会受到影响。 Array.prototype.splice()改变数组，返回被删除元素组成的数组 参考文献 MDN]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript中String对象总结]]></title>
    <url>%2F2017%2F08%2F03%2Fjs-String%2F</url>
    <content type="text"></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript定时器总结]]></title>
    <url>%2F2017%2F08%2F03%2Fjs-timing%2F</url>
    <content type="text"></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IP地址学习总结]]></title>
    <url>%2F2017%2F02%2F22%2FIP%2F</url>
    <content type="text"><![CDATA[IP地址A级：1.0.0.0 - 126.255.255.255B级：128.0.0.0 - 191.255.255.255C级：192.0.0.0 - 223.255.255.255。 保留地址保留地址是有特殊用途的A类：127.X.X.X 用做循环测试B类：169.254.X.X 如果你的IP地址是自动获取IP地址，而你在网络上又没有找到可用的DHCP服务器，就会得到其中一个IP 私有地址私有地址就是在互联网上不使用，而被用在局域网络中的地址A类：10.X.X.X是私有地址B类：172.16.0.0 - 172.31.255.255c类：192.168.X.X是私有地址。（192.168.0.0 - 192.168.255.255)]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>ip</tag>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chmod命令用法]]></title>
    <url>%2F2016%2F12%2F20%2Fchmod%2F</url>
    <content type="text"><![CDATA[chmod命令用于改变linux系统文件或目录的访问权限。用它控制文件或目录的访问权限。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。Linux系统中的每个文件和目录都有访问许可权限，用它来确定谁可以通过何种方式对文件和目录进行访问和操作。 文件或目录的访问权限分为只读，只写和可执行三种。以文件为例，只读权限表示只允许读其内容，而禁止对其做任何的更改操作。可执行权限表示允许将该文件作为一个程序执行。文件被创建时，文件所有者自动拥有对该文件的读、写和可执行权限，以便于对文件的阅读和修改。用户也可根据需要把访问权限设置为需要的任何组合。 有三种不同类型的用户可对文件或目录进行访问：文件所有者，同组用户、其他用户。所有者一般是文件的创建者。所有者可以允许同组用户有权访问文件，还可以将文件的访问权限赋予系统中的其他用户。在这种情况下，系统中每一位用户都能访问该用户拥有的文件或目录。 每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件属主的读、写和执行权限；与属主同组的用户的读、写和执行权限；系统中其他用户的读、写和执行权限。当用ls-l命令显示文件或目录的详细信息时，最左边的一列为文件的访问权限。 例如：命令：ls -al输出：12345678[root@localhost test]# ll -al总计 316lrwxrwxrwx 1 root root 11 11-22 06:58 linklog.log -&gt; log2012.log-rw-r--r-- 1 root root 302108 11-13 06:03 log2012.log-rw-r--r-- 1 root root 61 11-13 06:03 log2013.log-rw-r--r-- 1 root root 0 11-13 06:03 log2014.log-rw-r--r-- 1 root root 0 11-13 06:06 log2015.log-rw-r--r-- 1 root root 0 11-16 14:41 log2016.log-rw-r--r-- 1 root root 0 11-16 14:43 log2017.log 我们以log2012.log为例：-rw-r--r-- 1 root root 296K 11-13 06:03 log2012.log第一列共有10个位置，第一个字符指定了文件类型。在通常意义上，一个目录也是一个文件。如果第一个字符是横线，表示是一个非目录的文件。如果是d，表示是一个目录。从第二个字符开始到第十个共9个字符，3个字符一组，分别表示了3组用户对文件或者目录的权限。权限字符用横线代表空许可，r代表只读，w代表写，x代表可执行。例如：- rw- r-- r-- 表示log2012.log是一个普通文件；log2012.log的属主有读写权限；与log2012.log属主同组的用户只有读权限；其他用户也只有读权限。 确定了一个文件的访问权限后，用户可以利用Linux系统提供的chmod命令来重新设定不同的访问权限。也可以利用chown命令来更改某个文件或目录的所有者。利用chgrp命令来更改某个文件或目录的用户组。 chmod命令是非常重要的，用于改变文件或目录的访问权限。用户用它控制文件或目录的访问权限。chmod命令详细情况如下: 1. 命令格式chmod [-cfvR] [--help] [--version] mode file 2. 命令功能用于改变文件或目录的访问权限，用它控制文件或目录的访问权限。 3. 命令参数必要参数：-c 当发生改变时，报告处理信息-f 错误信息不输出-R 处理指定目录以及其子目录下的所有文件-v 运行时显示详细处理信息 选择参数：–reference=&lt;目录或者文件&gt; 设置成具有指定目录或者文件具有相同的权限–version 显示版本信息&lt;权限范围&gt;+&lt;权限设置&gt; 使权限范围内的目录或者文件具有指定的权限&lt;权限范围&gt;-&lt;权限设置&gt; 删除权限范围的目录或者文件的指定权限&lt;权限范围&gt;=&lt;权限设置&gt; 设置权限范围内的目录或者文件的权限为指定的值权限范围：u ：目录或者文件的当前的用户g ：目录或者文件的当前的群组o ：除了目录或者文件的当前用户或群组之外的用户或者群组a ：所有的用户及群组 权限代号：r ：读权限，用数字4表示w ：写权限，用数字2表示x ：执行权限，用数字1表示– ：删除权限，用数字0表示s ：特殊权限该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。 1）. 文字设定法：chmod ［who］ ［+ | - | =］ ［mode］ 文件名 2）. 数字设定法 我们必须首先了解用数字表示的属性的含义：0表示没有权限，1表示可执行权限，2表示可写权限，4表示可读权限，然后将其相加。所以数字属性的格式应为3个从0到7的八进制数，其顺序是（u）（g）（o）。 例如，如果想让某个文件的属主有“读/写”二种权限，需要把4（可读）+2（可写）＝6（读/写）。 数字设定法的一般形式为：chmod ［mode］ 文件名数字与字符对应关系如下：r=4，w=2，x=1若要rwx属性则4+2+1=7若要rw-属性则4+2=6；若要r-x属性则4+1=7。 4. 使用实例实例1：增加文件所有用户组可执行权限命令：chmod a+x log2012.log输出：123456[root@localhost test]# ls -al log2012.log -rw-r--r-- 1 root root 302108 11-13 06:03 log2012.log[root@localhost test]# chmod a+x log2012.log [root@localhost test]# ls -al log2012.log -rwxr-xr-x 1 root root 302108 11-13 06:03 log2012.log[root@localhost test]# 说明：即设定文件log2012.log的属性为：文件属主（u） 增加执行权限；与文件属主同组用户（g） 增加执行权限；其他用户（o） 增加执行权限。 实例2：同时修改不同用户权限命令：chmod ug+w,o-x log2012.log输出：12345[root@localhost test]# ls -al log2012.log -rwxr-xr-x 1 root root 302108 11-13 06:03 log2012.log[root@localhost test]# chmod ug+w,o-x log2012.log [root@localhost test]# ls -al log2012.log -rwxrwxr-- 1 root root 302108 11-13 06:03 log2012.log 说明：即设定文件text的属性为：文件属主（u） 增加写权限;与文件属主同组用户（g） 增加写权限;其他用户（o） 删除执行权限 实例3：删除文件权限命令：chmod a-x log2012.log输出：12345[root@localhost test]# ls -al log2012.log -rwxrwxr-- 1 root root 302108 11-13 06:03 log2012.log[root@localhost test]# chmod a-x log2012.log [root@localhost test]# ls -al log2012.log -rw-rw-r-- 1 root root 302108 11-13 06:03 log2012.log 说明：删除所有用户的可执行权限 实例4：使用“=”设置权限命令：chmod u=x log2012.log输出：12345[root@localhost test]# ls -al log2012.log -rw-rw-r-- 1 root root 302108 11-13 06:03 log2012.log[root@localhost test]# chmod u=x log2012.log [root@localhost test]# ls -al log2012.log ---xrw-r-- 1 root root 302108 11-13 06:03 log2012.log 说明：撤销原来所有的权限，然后使拥有者具有可读权限 实例5：对一个目录及其子目录所有文件添加权限命令：chmod -R u+x test4输出：1234567891011121314151617[root@localhost test]# cd test4[root@localhost test4]# ls -al总计 312drwxrwxr-x 2 root root 4096 11-13 05:50 .drwxr-xr-x 5 root root 4096 11-22 06:58 ..-rw-r--r-- 1 root root 302108 11-12 22:54 log2012.log-rw-r--r-- 1 root root 61 11-12 22:54 log2013.log-rw-r--r-- 1 root root 0 11-12 22:54 log2014.log[root@localhost test4]# cd ..[root@localhost test]# chmod -R u+x test4[root@localhost test]# cd test4[root@localhost test4]# ls -al总计 312drwxrwxr-x 2 root root 4096 11-13 05:50 .drwxr-xr-x 5 root root 4096 11-22 06:58 ..-rwxr--r-- 1 root root 302108 11-12 22:54 log2012.log-rwxr--r-- 1 root root 61 11-12 22:54 log2013.log-rwxr--r-- 1 root root 0 11-12 22:54 log2014.log` 说明：递归地给test4目录下所有文件和子目录的属主分配权限 其他一些实例1）. 命令：chmod 751 file说明：给file的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限2）. 命令：chmod u=rwx,g=rx,o=x file说明：上例的另一种形式3）. 命令: chmod =r file说明：为所有用户分配读权限3）. 命令：chmod 444 file说明：同上例4）. 命令：chmod a-wx,a+r file说明：同上例]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学易悟道]]></title>
    <url>%2F2016%2F11%2F05%2Fyixue%2F</url>
    <content type="text"><![CDATA[一、学易最近研究易学、命理学，对老祖宗的文化更加敬仰、自豪和欣慰，也难怪四大文明古国，只有中国还一直传承了下来，并且传承了几千年了。老祖宗的智慧请不要随意否定和抨击。知乎上看到一段话觉得很有道理，在这里来引用： 我两年前看《佛兰西斯·培根传》的读书笔记，那个是印象深刻的感悟:实践出真知，一件事如果你不清楚或者没有接触过，最好不要对它做出评论评价。一个问题如果真的有兴趣，那么就应该实践一下，别人的答案可以收录参考，如果自己用心去感受的东西还没出来，那么对这个问题就应该说“不清楚”或者不说。学了过才知道原来不是八个字就可以把人生都算完的，要大运流年共十二个字。学过才知道八字是算人生大体走势的，不是万能的，很少人能精准到日或者时辰的。学过了才知道，专注做好一件事的重要性。学过了才知道，性格对人生的影响真的很大，可以告诉各位，改变性格也是改变命运的一个手段，至于性格那种好那种坏，请君斟酌。学过了才深深明白“积善之家，必有余庆。积不善之家，必余秧。”的道理。也是学了才让我继续坚持“塞翁失马焉知非福”的心态。《易经》象数理，我们学易术是为了跳过表象，用术数去明理。佛教说人有八万四千烦恼，也有八万四千法门可以成佛。各种术数也是其中明理的方法。关于改命：相信各位都很有兴趣，我的答案没什么特别。无非就是大家提倡的“诸恶莫作，众善奉行”。改变自己（性格，体质），多读书，多做善事，改风水等。若是明此理者，可以不算命，若是不明此理者，去算命也是得到这个回复。 作者：noiplee链接：https://www.zhihu.com/question/20773399/answer/16171663来源：知乎著作权归作者所有，转载请联系作者获得授权。 二、增益去害，趋吉避凶总结了自己的优缺点，和借鉴noiplee的各个方面要求自己，并希望引为自省！ 1. 保养身体 规律饮食，起居 锻炼身体 2. 弥补缺陷 提高格局，增强气量。做事前三思，做事时稳重！ 严以律己，宽以待人。积口德，增气量，非原则问题让一让又如何？做人留一线，日后好相见！ 细心，耐心，恒心。 细心，忌眼高手低；耐心，忌心浮气躁；恒心，忌半途而废！ 尊师重道，孝敬父母。 父母是生我养我之人，我是他们生命的延续，所以我也是另一个层次的他们，即爱父母也是爱自己；尊重师长，护持正道，发扬中国优秀传统文化！ 谦虚谨慎，敬畏自然。 切莫恃才傲物，记住聪明反被聪明误！ 我比别人知道得多的，不过是我知道自己无知。—–苏格拉底 3. 行善积德行善积德的10个方法： 助人为乐，与人为善。 敬爱存心。 成人之美。 劝人为善。 救人危急。 兴建大利。 舍财作福。 护持正法。 敬重尊长。 爱惜物命。 4. 多读书好读书，读好书，读书好！]]></content>
      <categories>
        <category>随笔生活</category>
      </categories>
      <tags>
        <tag>易学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拖延症再见「转」]]></title>
    <url>%2F2016%2F10%2F23%2Fdalay-bye%2F</url>
    <content type="text"><![CDATA[拖延症你好严格来说，拖延症甚至算不上一种「症」。无论从国际通用的精神疾病诊断与统计手册（ DSM-V ）还是中国的精神疾病诊断手册中都没有拖延症的名字。如果说拖延症是「病」，它可能由很多种不同的疾病引起。如抑郁症、焦虑症、成瘾症等等。拖延症只是表象，并不是问题的本质。 最常见的导致拖延症的原因： 一、诱惑米歇尔教授（做棉花糖实验的心理学家），认为人的大脑存在两个系统：「冷系统」和「热系统」。这两个系统就是长远利益与当前诱惑在我们大脑中交战的战场。「冷系统」的区域在我们的前额，它是理性的、自我控制的，它更高瞻远瞩，能为更长远的利益考虑，它在不停提醒我们「想想未来想想未来」。而「热系统」的区域在海马回和边缘系统附近，它是人脑最先进化出来的部分，和我们的冲动情绪有关。一旦诱惑出现，这个系统就会被激活，它会不停喊「及时行乐及时行乐」，让人变得急躁而短视，按冲动行事。认知神经学有一个「神经营销学」的领域，翻检大脑的每一个薄弱环节，设计制造出更多的、更有效的诱惑。我们身处一个擅长制造诱惑的时代。 二、压力「诱惑」和「压力」都会激发热系统。「诱惑」会让热系统产生趋近的冲动，让我们打开网页，远离工作，而「压力」则会让热系统产生逃避的冲动，让我们直接逃离带来压力的工作。更多时候，压力并不带来动力，反而带来拖延。压力会带来严重的逃避反应，让人没有勇气去面对和解决问题。面对任务时的时间压力有时候会让人产生这样的习得性无助，那种「我再努力也无法赶上时间进度」的感觉。这时候，压力除了制造焦虑，再也不会激起人战斗的欲望了。甚至连焦虑着急的情绪，也会逐渐转入抑郁，并破坏人的社会功能。拖延症的问题，某种意义上，也就是压力管理问题。 三、完美主义完美主义并不是以工作结果或者工作过程来评判的，而是以你对自己的期待来评判的。心理学将完美主义者分为适应良好的完美主义者和适应不良的完美主义者。 1、关于自我的区别①适应良好的完美主义不仅有对自己的高标准、严要求，而且相信自己有与这种要求相匹配的能力。他们的高标准与高的自我意向是相适应的。②适应不良的完美主义在高标准之外，却常有与之不匹配的低自我意向，他们并不相信自己真的能符合完美标准：「如果能做这么好就好了，可惜我肯定做不到」。所以高标准只会增加他们的挫败感，提醒他们自己的不完美，而他们偏偏又很难忍受自己的这种不完美。（不适应的完美主义者背后，常常有一个严厉得不近人情的父母。这些父母经常以批评代替鼓励，不断提醒他们各种缺陷和不足而非表扬他们有了进步。这种苛刻的态度会逐渐内化为他们的自我要求。） 2、关于失败的区别①适应良好的完美主义虽然同样讨厌失败，但他们会把失败看作成功路上必然的经历，看作成长和学习的机会。②适应不良的完美主义者却把一个人的能力看作固定的东西，而他们所面对的每个任务，都是对自己能力的证明和考验。把每个任务当作威胁而不是成长的机会。而失败也总会给他们带来很大的挫折感。 适应不良的完美主义者更容易拖延，原因：①在完美的标准下，他们会一直纠结每个不完美的开端，并把它们视作失败。②会把失败的意义无限扩大，并因此更害怕失败。所以有时候，他们宁愿在自我批评中拖延，也不愿去面对费力挣扎却仍然失败的风险。 四、控制和反抗控制感是人的基本需要。人都希望自己能为自己做主。可是在社会分工和组织序列中，深处底层的人们不得不听从老板或客户的指挥。因此拖延成了组织中的弱者表达不满的反抗工具。 五、对未来的错估拖延症患者经常面对着这样一个问题：该把工作放到现在还是留给未来。如心理距离理论所说，人们会用更抽象的视角来看待未来的任务和他们自己。人们会低估未来任务的难度。人们会忽略未来任务中很多恼人的细节，因此，未来的任务会比现在看起来更简单纯粹。人们还会高估未来自己的能力和专注度，同时高估未来可用的时间资源。这些对未来的系统性看法并不是拖延症患者才有，普通人也有，只是拖延症患者会更严重。 六、缺爱拖延症的患者经常陷入巨大的空虚当中。他们经常怀疑自己所做的事情的意义，甚至怀疑自己的整个人生的意义。所以他们需要到网游、酒精、当下肤浅的感官刺激中去寻找存在感。意义的本质是联结。它既可能是我们与他人的联结，也可能是我们与未来的联结。拖延症患者常常缺少这种因爱产生的意义感。他们是孤立的，并不觉得自己有人在乎，也不真的在乎别人。因此，当面临一个任务时，他们对拖延可能造成的对未来自己、对他人的影响漠不关心。但这种孤立和冷漠的感觉让人很难忍受，需要通过做其他刺激感官的事情来确认自己的存在感，于是，他们很容易变成其他方面的成瘾患者。 拖延症再见原则一：发挥梦想的力量要在拖延症中重拾梦想，我们应该仔细审视以下问题： 从长远看，我的目标是什么？为什么这个目标对我有特别的意义？如果实现了这个目标，我能得到什么？ 如果不拖延了，我能得到什么？它对实现这个目标会有什么样的帮助？ 如果不拖延了，我的生活会有什么样的改变？这种变化是我喜欢的吗？ 我在乎和在乎我的人都有哪些？如果我不拖延了，会给他们带来什么样的好处？我希望他们得到这个好处吗？ 试着想象自己实现目标以后的画面和场景，想得越细致越好。经常提醒自己，我为什么要克服拖延症。强化你要拖延的事与你梦想的联系。 警惕两种错误：①用立志代替行动。澄清梦想和列目标当然也是努力的一种，但它只是起点，不能代替现实的努力。②跟自己死磕。真正适应性的思维，既有对梦想的执著，也有灵活的态度。根本目标不变的情况下换一条路。 原则二：觉察而非控制大脑运行的规律之一，是不能用意志去控制自己的想法。当人们控制自己的思维不去想某件事时，反而会比不控制自己思维时要想得更多。这种效应称为「讽刺性反弹」（ ironic rebound ）。想通过抑制想法来抵御诱惑，实在是南辕北辙。因此在思维中给诱惑留下弹性的空间，温柔地觉察自己的欲望但不付诸行动。用觉察代替控制，提醒自己我们的目标和梦想，反而能让诱惑的吸引力降低。 原则三：自我激励而非自我谴责内疚和自责能用于抵抗拖延症是一种错觉。通常的情况是，我们在上一次拖延中对自己态度越严厉，下次越拖延就越严重。内疚和自责会让我们陷入「放纵 — 自责 — 更严重地放纵」的恶性循环。内疚和自责会降低我们的自尊，让我们觉得自己懒惰、一事无成，进而破罐子破摔。内疚和自责也会带来更多的压力，而压力会让我们更容易屈从诱惑。相比于内疚，自我谅解反而更能增强责任感。这是因为一旦摆脱了内疚和自责，我们反而能够思考为什么会失败，而不是简单地把原因归于自己的无能。告诉自己，我只是一个凡人，接纳自己的不足，爱自己。在拖延之后，用自我激励代替自我谴责，提醒自己能够做得更好。 原则四：和自己谈判拖延症的特点之一，就是很难从娱乐状态切换到工作状态，但一旦投入工作了，需要的意志力就没那么大。让自己从放松娱乐状态重新回到工作状态，与自己谈判：「不想工作啊？」「嗯。」「不玩行不行？」「憋不住啊。」「这样，你先到书桌边工作半小时行不行？就半小时。半小时后允许你玩。」（太难那就10分钟）「那 …… 行吧。」 原则五：目标和计划好计划的几个原则： 一、做计划之前，先要有两个目标。 一个目标是抽象的、长远的。它应该跟我们的梦想有关。它应该是积极目标而非消极目标。（如「快乐地生活」是积极目标，「减少抑郁」不是。） 具体的目标。具体目标应该跟抽象目标有直接的联系。具体的目标决定了计划是否可以执行。具体目标包含这两个问题的答案：怎么样算做成了？什么时候做成？ 重点：把大目标分解成小目标。小目标能够让我们的计划循序渐进。合理的小目标应该是对你来说不太难，又不太容易，是你踮着脚能够到的。（小目标的成功会让你相信改变是可能的，并进一步激发你改变的愿望。某部分规律的生活，能够让你获得一种掌控感。） 二、反馈。 一个是百分比。当开始计划一项任务时，用一个百分比来表示在这个任务上已经有了多少积累，大概进展到什么程度了。百分比不需要太精确，你心里的感觉就可以。每次完成一个任务，都调整一下这个百分比，这样会有进步的感觉。 打 √ 打 × 。把你所有要完成的事写下来，每次做完一件，给自己打一个 √ ，否则，打一个 × ，并注明为什么没完成。 三、把不可控的目标转为可控目标。拖延的问题，有时候是因为我们不愿意去面对不确定性。但这种不确定性总会存在，但这种不确定性的背后，都会有我们可以控制的部分。把事情背后可控的部分做成计划，这会让我们意识到，哪怕我们没法决定很多事，我们仍然有很多事可做。至于其他，就让我们交给天意了。 原则六： GTD （ Get Things Done ）有时候拖延，是因为事情太多太杂。多任务交错会导致火气与混乱。通常的任务管理方法，是列出所要做的事情，并按轻重缓急进行排序。GTD 提出的原则，是多做一步，不仅列出要做的事情，而且列出这件事下一步该怎么做：处理、搁置还是丢弃？（一旦做出计划潜意识就不会再反复提醒了） 原则七：积极拖延斯坦福大学约翰 · 佩里教授在《拖拉一点又何妨》中提出「结构化拖延」。把看起来最重要、最紧急的事排在清单最前头，把其他不紧急但也值得一做的事排在清单后面，为了避免去做清单最前面的任务，人就会努力做清单后面的任务。 原则八：和他人建立联系「宅」容易生出拖延症的原因： 我们内心里其实都有一个关于「空间功能」的假设。在这个假设里，图书馆、自习室或者写字间是和工作相联系的，而家或宿舍是和休息或娱乐相联系的。 人是社会的动物，总是以他人的行为为参照。学习或者工作氛围很容易相互感染，反之如果你一个人宅着，你能参照的就只有自己了。 如果你一直宅着，你很难跟别人建立起有效的情感联系。如前文所说的缺爱。 原则九：设想未来我们对未来自己的设想和对别人的设想在很多地方是类似的。对未来自己的善意和对他人的善意是类似，而对未来自己的痛苦也和对他人的痛苦是类似，而这种痛苦很难完全被感受到。自我管理其实也像管理团队。团队中，「现在的我」是嫡系和亲信，拖延的人太习惯把好处留给他，把脏活累活留给别人。「未来的我」就是那个干脏活累活背黑锅的「别人」。要管理好一个团队，你必须要公正处事，平衡各方面的关系。你需要拉近「现在的我」和「未来的我」的距离。（作者的方法是给未来的自己写信，想想他会怎么看待「现在的我」，会如何看待「现在的我」所做的选择，如何因为「现在的我」的辛勤努力而心怀感激。） 原则十：冥想、运动和睡眠每当烦躁抑郁的时候，坚持做一段时间的冥想。重要的不是冥想，还在于冥想背后传递的生活理念和态度 —— 专注于此时此刻，和自己在一起，觉察而非改变，接纳而非批判。最好是能在心平气和的时候养成每天做半小时冥想的习惯。（卡巴金《正念》，正念式冥想）和其他心理问题一样，拖延症只是我们整个生活图景的一部分。拖延症的背后，是我们的恐惧和期待、犹疑和奋斗、局限和潜力、现实和梦想，是我们的人生，和人生的意义。有时候我们会这样，迷茫、自我怀疑、焦虑，因看不清远方的目标而不知道该做什么，如果这时候你还有足够的精力和资源照亮你脚下的一点点路，那么就看脚下。走着走着，回过头，也许你发现自己已经走得很远了。 转载地址：http://blog.sina.com.cn/u/1708023907]]></content>
      <categories>
        <category>转载</category>
      </categories>
      <tags>
        <tag>拖延症</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《子平真诠》—— 沈孝瞻]]></title>
    <url>%2F2016%2F10%2F11%2Fziping%2F</url>
    <content type="text"><![CDATA[一、论十干十二支天地之间，一气而己。惟有动静，遂分阴阳。有老少，遂分四象。老者极动静之时，是为太阳太阴；少者初动初静之际，是为少阴少阳。有是四象，而五行具于其中矣。水者，太阴也；火者，太阳也；木者，少阳也；金者，少阴也；土者，阴阳老少、木火金水冲气所结也。 有是五行，何以又有十干十二支乎？盖有阴阳，因生五行，而五行之中，各有阴阳。即以木论，甲乙者，木之阴阳也。甲者，乙之气；乙者，甲之质。在天为生气，而流行于万物者，甲也；在地为万物，而承兹生气者，乙也。又细分之，生气之散布者，甲之甲，而生气之凝成者，甲之乙；万木之所以有枝叶者，乙之甲，而万木之枝枝叶叶者，乙之乙也。方其为甲，而乙之气已备；及其为乙，而甲之质乃坚。有是甲乙，而木之阴阳具矣。 何以复有寅卯者，又与甲乙分阴阳天地而言之者也。以甲乙而分阴阳，则甲为阳，乙为阴，木之行于天而为阴阳者也。以寅卯而阴阳，则寅为阳，卯为阴，木之存乎地而为阴阳者也。以甲乙寅卯而统分阴阳，则甲乙为阳寅卯为阴，木之在天成象而在地成形者也。甲乙行乎天，而寅卯受之；寅卯存乎也，而甲乙施焉。是故甲乙如官长，寅卯如该管地方。甲禄于寅，乙禄于卯，如府官之在郡，县官之在邑，而各司一月之令也。 甲乙在天，故动而不居。建寅之月，岂必当甲？建卯之月，岂必当乙？寅卯在地，故止而不迁。甲虽递易，月必建寅；乙虽递易，月必建卯。以气而论，甲旺于乙；以质而论，乙坚于甲。而俗书谬论，以甲为大林，盛而宜斩，乙为微苗，脆而莫伤，可为不知阴阳之理者矣。以木类推，余者可知，惟土为木火金水冲气，故寄旺于四时，而阴阳气质之理，亦同此论。欲学命者，必须先知干支之说，然后可以入门。 二、论阴阳生克四时之运，相生而成，故木生火，火生土，土生金，金生水，水复生木，即相生之序，循环迭运，而时行不匮。然而有生又必有克，生而不克，则四时亦不成矣。克者，所以节而止之，使之收敛，以为发泄之机，故曰“天地节而四时成”。即以木论，木盛于夏，杀于秋，杀者，使发泄于外者藏收内，是杀正所以为生，大易以收剑为性情之实，以兑为万物所说，至哉言乎！譬如人之养生，固以饮食为生，然使时时饮食，而不使稍饥以待将来，人寿其能久乎？是以四时之运，生与克同用，克与生同功。 然以五行而统论之，则水木相生，金木相克。以五行之阴阳而分配之，则生克之中，又有异同。此所以水同生木，而印有偏正；金同克木，而局有官煞也。印绶之中，偏正相似，生克之殊，可置勿论；而相克之内，一官一煞，淑慝判然，其理不可不细详也。 即以甲乙庚辛言之。甲者，阳木也，木之生气也；乙者，阴木也，木之形质也。庚者，阳金也，秋天肃杀之气也；辛者，阴金也，人间五金之质也。木之生气，寄于木而行于天，故逢秋天为官，而乙则反是，庚官而辛杀也。又以丙丁庚辛言之。丙者，阳火也，融和之气也；丁者，阴火也，薪传之火也。秋天肃杀之气，逢阳和而克去，而人间之金，不畏阳和，此庚以丙为杀，而辛以丙为官也。人间金铁之质，逢薪传之火而立化，而肃杀之气，不畏薪传之火。此所以辛以丁为杀，而庚以丁为官也。即此以推，而余者以相克可知矣。 三、论阴阳生死五行干支之说，已详论于干支篇。干动而不息，支静而有常。以每干流行于十二支之月，而生旺墓绝系焉。 阳主聚，以进为进，故主顺；阴主散，以退为退，故主逆。此生沐浴等项，所以有阳顺阴逆之殊也。四时之运，功成者去，等用者进，故每流行于十二支之月，而生旺墓绝，又有一定。阳之所生，即阴之所死，彼此互换，自然之运也。即以甲乙论，甲为木之阳，木之枝枝叶叶，受天生气，己收藏饱足，可以为来克发泄之机，此其所以生于亥也。木当午月，正枝叶繁盛之候，而甲何以死？却不是外虽繁盛，而内之生气发泄已尽，此其所以死于午也。乙木反是，午月枝叶繁盛，即为之生，亥月枝叶剥落，即为之死。以质而论，自与气殊也。以甲乙为例，余可知矣。 支有十二月，故每干长生至胎养，亦分十二位。气之由盛而衰，衰而复盛，逐节细分，遂成十二。而长生沐浴等名，则假借形容之词也。长生者，犹人之初生也。沐浴者，犹人既生之后，而沐浴以去垢；如果核既为苗，则前之青壳，洗而去之矣。冠带者，形气渐长，犹人之年长而冠带也。临官者，由长而壮，犹人之可以出仕也。帝旺者，壮盛之极，犹人之可以辅帝而大有为也。衰者，盛极而衰，物之初变也。病者，衰之甚也。死者，气之尽而无余也。墓者，造化收藏，犹人之埋于土者也。绝者，前之气已绝，后之气将续也。胎者，后之气续而结聚成胎也。养者，如人养母腹也。自是而后，长生循环无端矣。 人之日主，不必生逢禄旺，即月令休囚，而年日时中, 得长禄旺，便不为弱，就使逢库，亦为有根。时产谓投库而必冲者，俗书之谬也，但阳长生有力，而阴长生不甚有力，然亦不弱。若是逢库，则阳为有根，而阴为无用。盖阳大阴小，阳得兼阴，阴不能兼阳，自然之理也。 四、论十干配合性情合化之义，以十干阴阳相配而成。河图之数，以一二三四五配六七八九十，先天之道也。故始于太阴之水，而终于冲气之土，以气而语其生之序也。盖未有五行之先，必先有阴阳老少，而后冲气，故生以土。终之既有五行，则万物又生于土，而水火木金，亦寄质焉，故以土先之。是以甲己相合之始，则化为土；土则生金，故乙庚化金次之；金生水，故丙辛化水又次之；水生木，故丁壬化木又次之；木生火，故戊癸化火又次之，而五行遍焉。先之以土，相生之序，自然如此。此十干合化之义也。 其性情何也？盖既有配合，必有向背。如甲用辛官，透丙作合，而官非其官；甲用癸印，透戊作合，而印非其印；甲用己财，己与别位之甲作合，而财非其财。如年己月甲，年上之财，被月合去，而日主之甲乙无分；年甲月己，月上之财，被年合去，而日主之甲乙不与是也。甲用丙食与辛作合，而非其食，此四喜神因合而无用者也。 又如甲逢庚为煞，与乙作合，而煞不攻身；甲逢乙为劫财，甲逢丁为伤，与壬作合，而丁不为伤官；甲逢壬为枭，与丁作合，而壬不夺食。此四忌神因合化吉者也。 盖有所合则有所忌，逢吉不为吉，逢凶不为凶。即以六亲言之，如男以财为妻，而被别干合去，财妻岂能亲其夫乎？女以官为夫，而被他干合去，官夫岂能爱其妻乎？此谓配合之性情，因向背而殊也。 五、论十干合而不合十干化合之义，前篇既明之矣，然而亦有合而不合者，何也？ 盖隔于有所间也，譬如人彼此相好，而有人从中间之，则交必不能成。譬如甲与己合，而甲己中间，以庚间隔之，则甲岂能越克我之庚而合己？此制于势然也，合而不敢合也，有若无也。 又有隔位太远，如甲在年干，己在时上，心虽相契，地则相远，如人天南地北，不能相合一般。然于有所制而不敢合者，亦稍有差，合而不能合也，半合也，其为祸福得十之二三而已。 又有合而无伤于合者，何也？如甲生寅卯，月时两透辛官，以年丙合月辛，是为合一留一，官星反轻。甲逢月刃，庚辛并透，丙与辛合，是为合官留煞，而煞刃依然成格，皆无伤于合也。 又有合而不以合论者，何也？本身之合也。盖五阳逢财，五阴遇官，俱是作合，惟是本身十干合之，不为合去。假如乙用庚官，日干之乙，与庚作合，是我之官，是我合之。何为合去？若庚在年上，乙在月上，则月上之乙，先去合庚，而日干反不能合，是为合去也。又如女以官为夫，丁日逢壬，是我之夫，是我合之，正如夫妻相亲，其情愈密。惟壬在月上，而年丁合之，日干之丁，反不能合，是以己之夫星，被姊妹合去，夫星透而不透矣。 然又有争合妒合之说，何也？如两辛合丙，两丁合壬之类，一夫不娶二妻，一女不配二夫，所以有争合妒合之说。然到底终有合意，但情不专耳。若以两合一而隔位，则全无争妒。如庚午、乙酉、甲子、乙亥，两乙合庚，甲日隔之，此高太尉命，仍作合煞留官，无减福也。 六、论十干得时不旺失时不弱书云，得时俱为旺论，失时便作衰看，虽是至理，亦死法也。然亦可活看。夫五行之气，流行四时，虽日干各有专令，而其实专令之中，亦有并存者在。假若春木司令，甲乙虽旺，而此时休囚之戊己，亦尝艳于天地也。特时当退避，不能争先，而其实春土何尝不生万物，冬日何尝不照万国乎？ 况八字虽以月令为重，而旺相休囚，年月日时，亦有损益之权，故生月即不值令，而年时如值禄旺，岂便为衰？不可执一而论。犹如春木虽强，金太重而木亦危。干庚辛而支酉丑，无火制而晃富，逢土生而必夭，是以得时而不旺也。秋木虽弱，木根深而木亦强。干甲乙而支寅卯，遇官透而能受，逢水生而太过，是失时不弱也。 是故十干不论月令休囚，只要四柱有根，便能受财官食神而当伤官七煞。长生禄旺，根之重者也；墓库余气，根之轻者也。得一比肩，不如得支中一墓库，如甲逢未、丙逢戌之类。乙逢戌、丁逢丑、不作此论，以戌中无藏木，丑中无藏火也。得二比肩，不如得一余气，如乙逢辰、丁逢未之类。得三比肩，不如得一长生禄刃，如甲逢亥子寅卯之类。阴长生不作此论，如乙逢午、丁逢酉之类，然亦为明根，比得一余气。盖比劫如朋友之相扶，通根如室家之可住；干多不如根重，理固然也。 今人不知命理，见夏水冬火，不问有无通根，便为之弱。更有阳干逢库，如壬逢辰、丙坐戌之类，不以为水火通根身库，甚至求刑冲开之。此种谬论，必宜一切扫除也。 七、论刑冲会合解法刑者，三刑也，子卯巳申子类是也。冲者，六冲也，子午卯酉之类是也，会者，三会也，申子辰之类是也。合者，六合也，子与丑合之类是也。此皆以地支宫分而言，系对射之意也。三方为会，朋友之意也。并对为合，比邻之意也。至于三刑取庑，姑且阙疑，虽不知其所以然，于命理亦无害也。 八字支中，刑冲俱非美事，而三合六合，可以解之。假如甲生酉月，逢卯则冲，而或支中有戌，则卯与戌合而不冲；有辰，则酉与辰合而不冲；有亥与未，则卯与亥未会而不冲；有巳与丑，则酉与巳丑会而不冲。是会合可以解冲也。又如丙生子月，逢卯则刑，而或支中有戌，则与戌合而不刑；有丑，则子与丑合而不刑；有亥与未，则卯与亥未会而不刑；有申与辰，则子与申辰会而不刑。是会合可以解刑也。 又有因解而反得刑冲者，何也？假如甲生子月，支逢二卯相并，二卯不刑一子，而支又逢戌，戌与卯合，本为解刑，而合去其一，则一合而一刑，是因解而反得刑冲也。 又有刑冲而会合不能解者，何也？假如子年午月，日坐丑位，丑与子合，可以解冲，而时逢巳酉，则丑与巳酉会，而子复冲午；子年卯月，日坐戌位，戌与卯合，可以解刑，而或时逢寅午，则戌与寅午会，而卯复刑子。是会合而不能解刑冲也。 更有刑冲而可以解刑者，何也？盖四柱之中，刑冲俱不为美，而刑冲用神，尤为破格，不如以另位之刑冲，解月令之刑冲矣。假如丙生子月，卯以刑子，而支又逢酉，则又与酉冲不刑月令之官。甲生酉月，卯日冲之，而时逢子立，则卯与子刑，而月令官星，冲之无力，虽于别宫刑冲，六亲不无刑克，而月官犹在，其格不破。是所谓以刑冲而解刑冲也。 如此之类，在人之变化而己。 八、论用神八字用神，专求月令，以日干配月令地支，而生克不同，格局分焉。财官印食，此用神之善而顺用之者也；煞伤劫刃，用神之不善而逆用之者也。当顺而顺，当逆而逆，配合得宜，皆为贵格。 是以善而顺用之，则财喜食神以相生，生官以护财；官喜透财以相生，生印以护官；印喜官煞以相生，劫才以护印；食喜身旺以相生，生财以护食。不善而逆用之，则七煞喜食神以制伏，忌财印以资扶；伤官喜佩印以制伏，生财以化伤；阳刃喜官煞以制伏，忌官煞之俱无；月劫喜透官以制伏，利用财而透食以化劫。此顺逆之大路也。 今人不知专主提纲，然后将四柱干支，字字统归月令，以观喜忌，甚至见正官佩印，则以为官印双全，与印绶用官者同论；见财透食神，不以为财逢食生，而以为食神生财，与食神生财同论；见偏印透食，不以为泄身之秀，而以为枭神夺食，宜用财制，与食神逢枭同论；见煞逢食制而露印者，不为去食护煞，而以为煞印相生，与印绶逢煞者同论；更有煞格逢刃，不以为刃可帮身制煞，而以为七煞制刃，与阳刃露煞者同论。此皆由不知月令而妄论之故也。 然亦有月令无用神者，将若之何？如木生寅卯，日与月同，本身不可为用，必看四柱有无财官煞食透干会支，另取用神；然终以月令为主，然后寻用，是建禄月劫之格，非用而即用神也。 九、论用神成败救应用神专寻月令，以四柱配之，必有成败。何谓成？如官逢财印，又无刑冲破害，官格成也。财生官旺，或财逢食生而身强带比，或财格透印而位置妥贴，两不相克，财格成也。印轻逢煞，或官印双全，或身印两旺而用食伤泄气，或印多逢财而财透根轻，印格成也。食神生财，或食带煞而无财，弃食就煞而透印，食格成也。身强七煞逢制，煞格成也。伤官生财，或伤官佩印而伤官旺，印有根，或伤官旺、身主弱而透煞印，或伤官带煞而无财，伤官格成也。阳刃透官煞而露财印，不见伤官，阳刃格成也。建禄月劫，透官而逢财印，透财而逢食伤，透煞而遇制伏，建禄月劫之格成也。 何谓败？官逢伤克刑冲，官格败也；财轻比重，财透七煞，财格败也；印轻逢财，或身强印重而透煞，印格败也；食神逢枭，或生财露煞，食神格败也；七煞逢财无制，七煞格败也；伤官非金水而见官，或生财生带煞，或佩印而伤轻身旺，伤官格败也；阳刃无官煞，刃格败也；建禄月劫，无财官，透煞印，建禄月劫之格败也。 成中有败，必是带忌；败中有成，全凭救应。何谓带忌？如正官逢财而又逢伤；透官而又逢合；财旺生官而又逢伤逢合；印透食以泄气，而又遇财露；透煞以生印，而又透财，以去印存煞；食神带煞印而又逢财；七煞逢食制而又逢印；伤官生财而财又逢合；佩印而印又遭伤，透财而逢煞，是皆谓之带忌也。何谓救应？如官逢伤而透印以解之，杂煞而合煞以清之，刑冲而会合以解之；财逢劫而透食以化之，生官以制之，逢煞而食神制煞以生财，或存财而合煞；印逢财而劫财以解之，或合财而存印；食逢枭而就煞以成格，或生财以护食；煞逢食制，印来护煞，而逢财以去印存食；伤官生财透煞而煞逢合；阳刃用官煞带伤食，而重印以护之；建禄月劫用官，遇伤而伤被合，用财带煞而煞被合，是谓之救应也。 八字妙用，全在成败救应，其中权轻权重，甚是活泼。学者从此留心，能于万变中融以一理，则于命之一道，其庶几乎！ 十、论用神变化用神既主月令矣，然月令所藏不一，而用神遂有变化。如十二支中，除子午卯酉外，余皆有藏，不必四库也。即以寅论，甲为本主，如郡之有府，丙其长生，如郡之有同知，戊亦长生，如郡之有通判；假使寅月为提，不透甲而透丙，则如知府不临郡，而同知得以作主。此变化之由也。 故若丁生亥月，本为正官，支全卯未，则化为印。己生申月，本属伤官。藏庚透壬，则化为财。凡此之类皆用神之变化也。 变之而善，其格愈美；变之不善，其格遂坏，何谓变之而善？如辛生寅月，逢丙而化财为官；壬生戌月逢辛而化煞为印。癸生寅月，不专以煞论。此二者以透出而变化者也。癸生寅月，月令伤官秉令，藏甲透丙，会午会戌，则寅午戌三合，伤化为财；加以丙火透出，完全作为财论，即使不透丙而透戊土，亦作财旺生官论。盖寅午戌三合变化在前，不作伤官见官论也。乙生寅月，月劫秉令，会午会戌，则劫化为食伤，透戊则为食伤生财，不作比劫争财论。此二者因会合而变化者。因变化而忌化为喜，为变之善者。 何谓变之而不善？如丙生寅月，本为印绶，甲不透干而会午会戌，则化为劫。丙生申月，本属偏财，藏庚透壬，会子会辰，则化为煞。如此之类亦多，皆变之不善者也。 又有变之而不失本格者。如辛生寅月，透丙化官，而又透甲，格成正财，正官乃其兼格也。乙生申月，透壬化印，而又透戊，则财能生官，印逢财而退位，虽通月令，格成伤官，百戊官忌见。丙生寅月，午戌会劫，而又或透甲，或透壬，则仍为印而格不破。丙生申月，逢壬化煞，而又透戊，则食神能制煞生财，仍为财格，不失富贵。如此之类甚多，是皆变而不失本格者也。 是故八字非用神不立，用神非变化不灵，善观命者，必于此细详之。 十一、论用神纯杂用神既有变化，则变化之中，遂分纯、杂。纯者吉，杂者凶。 何谓纯？互用而两相得者是也。如辛生寅月，甲丙并透，财与官相生，两相得也。戊生申月，庚壬并透，财与食相生，两相得也。癸生未月，乙己并透，煞与食相克，相克而得其当，亦两相得也。如此之类，皆用神之纯者。 何谓杂？互用而两不相谋者是也。如壬生未月，乙己并透，官与伤相克，两不相谋也。甲也辰月，戊壬并透，印与财相克，亦两不相谋也。如此之类，皆用之杂者也。 纯杂之理，不出变化，分而疏之，其理愈明，学命者不可不知也。 十二、论用神格局高低八字既有用神，必有格局，有格局必有高低，财官印食煞伤劫刃，何格无贵？何格无贱？由极贵而至极贱，万有不齐，其变千状，岂可言传？然其理之大纲，亦在有情、有力无力之间而已。 如正官佩印，不如透财，而四柱带伤，反推佩印。故甲透酉官，透丁合壬，是谓合伤存官，遂成贵格，以其有情也。财忌比劫，而与煞作合，劫反为用。故甲生辰月，透戊成格，遇乙为劫，逢庚为煞，二者相合，皆得其用，遂成贵格，亦以其有情也。 身强煞露而食神又旺，如乙生酉月，辛金透，丁火刚，秋木盛，三者皆备，极等之贵，以其有力也。官强财透，身逢禄刃，如丙生子月，癸水透，庚金露，而坐寅午，三者皆均，遂成大贵，亦以其有力也。 又有有情而兼有力，有力而兼有情者。如甲用酉官，壬合丁以清官，而壬水根深，是有情而兼有力者也。乙用酉煞，辛逢丁制，而辛之禄即丁之长生，同根月令，是有力而兼有情者也。是皆格之最高者也。 如甲用酉官，透丁逢癸，癸克不如壬合，是有情而非情之至。乙逢酉逢煞，透丁以制，而或煞强而丁稍弱，丁旺而煞不昂，又或辛丁并旺而乙根不甚深，是有力而非力之全，格之高而次者也。 至如印用七煞，本为贵格，而身强印旺，透煞孤贫，盖身旺不劳印生，印旺何劳煞助？偏之又偏，以其无情也。伤官佩印，本秀而贵，而身主甚旺，伤官甚浅，印又太重，不贵不秀，盖欲助身则身强，制伤则伤浅，要此重印何用？是亦无情也。又如煞强食旺而身无根，身强比重而财无气，或夭或贫，以其无力也。是皆格之低而无用者也。 然其中高低之故，变化甚微，或一字而有千钧之力，或半字而败全局之美，随时观理，难以拟议，此特大略而已。 十三、论用神因成得败因败得成八字之中，变化不一，遂分成败；而成败之中，又变化不测，遂有因成得败，因败得成之奇。 是故化伤为财，格之成也，然辛生亥月，透丁为用，卯未会财，乃以党煞，因成得败矣。印用七煞，格之成也，然癸生申月，秋金重重，略带财以损太过，逢煞则煞印忌财，因成得败也。如此之类，不可胜数，皆因成得败之例也。 官印逢伤，格之败也，然辛生戊戌月，年丙时壬，壬不能越戊克丙，而反能泄身为秀，是因败得成矣。煞刃逢食，格之败也，然庚生酉月，年丙月丁，时上逢壬，则食神合官留煞，而官煞不杂，煞刃局清，是因败得成矣。如此之类，亦不可胜数，皆因败得成之例也。 其间奇奇怪怪，变幼无穷，惟以理权衡之，随在观理，因时运化，由他奇奇怪怪，自有一种至当不易不论。观命者毋眩而无主、执而不化也。 十四、论用神配气候得失论命惟以月令用神为主，然亦须配气候而互参之。譬如英雄豪杰，生得其时，自然事半功倍；遭时不顺，虽有奇才，成功不易。 是以印绶遇官，此谓官印双全，无人不贵。而冬木逢水，虽透官星，亦难必贵，盖金寒而水益冻，冻水不能生木，其理然也。身印两旺，透食则贵，凡印格皆然。而用之冬木，尤为秀气，以冬木逢火，不惟可以泄身，而即可以调候也。 伤官见官，为祸百端，而金水见之，反为秀气。非官之不畏夫伤，而调候为急，权而用之也。伤官带煞，随时可用，而用之冬金，其秀百倍。 伤官佩印，随时可用，而用之夏木，其秀百倍，火济水，水济火也。 伤官用财，本为贵格，而用之冬水，即使小富，亦多不贵，冻水不能生木也。 伤官用财，即为秀气，而用之夏木，贵而不甚秀，燥土不甚灵秀也。 春木逢火，则为木为通明，而夏木不作此论；秋金遇水，则为金水相涵，而冬金不作此论。气有衰旺，取用不同也。春木逢火，木火通明，不利见官；而秋金遇水，金水相涵，见官无碍。假如庚生申月，而支中或子或辰，会成水局，天干透丁，以为官星，只要壬癸不透露干头，便为贵格，与食神伤官喜见官之说同论，亦调候之道也。 食神虽逢正印，亦谓夺食，而夏木火盛，轻用之亦秀而贵，与木火伤官喜见水同论，亦调候之谓也。此类甚多，不能悉述，在学者引伸触类，神而明之而已。 十五、论相神紧要月令既得用神，则别位亦必有相，若君之有相，辅者是也。如官逢财生，则官为用，财为相；财旺生官，则财为用，官为相；煞逢食制，则煞为用，食为相。然此乃一定之法，非通变之妙。要而言之，凡全局之格，赖此一字而成者，均谓之相也。 伤用神甚于伤身，伤相甚于伤用。如甲用酉官，透丁逢壬，则合伤存官以成格者，全赖壬之相；戊用子财，透甲并己，则合煞存财以成格者，全赖己之相；乙用酉煞，年丁月癸，时上逢戊，则合去癸印以使丁得制煞者，全赖戊之相。 癸生亥月，透丙为财，财逢月劫，而卯未来会，则化水为木而转劫以生财者，全赖于卯未之相。庚生申月，透癸泄气，不通月令而金气不甚灵，子辰会局，则化金为水而成金水相涵者，全赖于子辰之相。如此之类，皆相神之紧要也。 相神无破，贵格已成；相神相伤，立败其格。如甲用酉官，透丁逢癸印，制伤以护官矣，而又逢戊，癸合戊而不制丁，癸水之相伤矣；丁用酉财，透癸逢己，食制煞以生财矣，而又透甲，己合甲而不制癸，己土之相伤矣。是皆有情而化无情，有用而成无用之格也。 凡八字排定，必有一种议论，一种作用，一种弃取，随地换形，难以虚拟，学命者其可忽诸？ 十六、论杂气如何取用四墓者，冲气也，何以谓之杂气？以其所藏者多，用神不一，故谓之杂气也。如辰本藏戊，而又为水库，为乙余气，三者俱有，于何取用？然而甚易也，透干会取其清者用之，杂而不杂也。 何谓透干？如甲生辰月，透戊则用偏财，透癸则用正印，透乙则用月劫是也。 何谓会支？如甲生辰月，逢申与子会局，则用水印是也。一透则一用，兼透则兼用，透而又会，则透与会并用。其合而有情者吉，其合而无情者则不吉。 何谓有情？顺而相成者是也。如甲生辰月，透癸为印，而又会子会申以成局，印绶之格，清而不杂，是透干与会支，合而有情也。又如丙生辰月，透癸为官，而又逢己以为印，官与印相生，而印又能去辰中暗土以清官，是两干并透，合而情也。又如甲生丑月，辛透为官，或巳酉会成金局，而又透己财以生官，是两干并透，与会支合而有情也。 何谓无情？逆而相背者是也。如壬生未月，透己为官，而地支会亥卯以成伤官之局，是透官与会支，合而无情者也。又如甲生辰月，透戊为财，又或透壬癸以为印，透癸则戊癸作合，财印两失，透壬则财印两伤，又以贪财坏印，是两干并透，合而无情也。又如甲生戌月，透辛为官，而又透丁以伤官，月支又会寅会午以成伤官之局，是两干并透，与会支合而无情也。 又有有情而卒成无情者，何也？如甲生辰月，逢壬为印，而又逢丙，印绶本喜泄身为秀，似成格矣，而火能生土，似又助辰中之戊，印格不清，是必壬干透而支又会申会子，则透丙亦无所碍。又有甲生辰月，透壬为印，虽不露丙而支逢戌位，戌与辰冲，二者为月冲而土动，干头之壬难通月令，印格不成，是皆有情而卒无情，富而不贵者也。 又有无情而终有情者，何也？如癸生辰月，透戊为官，又有会申会子以成水局，透干与会支相克矣。然所克者乃是劫财，譬如月劫用官，何伤之有？又如丙生辰月，透戊为食，而又透壬为煞，是两干并透，而相克也。然所克者乃是偏官，譬如食神带煞，煞逢食制，二者皆是美格，其局愈贵。是皆无情而终为有情也。 如此之类，不可胜数，即此为例，旁悟而已。 十七、论墓库刑冲之说辰戌丑未，最喜刑冲，财官入库不冲不发——此说虽俗书盛称之，然子平先生造命，无是说也。夫杂气透干会支，岂不甚美？又何劳刑冲乎？假如甲生辰月，戊土透岂非偏财？申子会岂非印绶？若戊土不透，即辰戌相冲，财格犹不甚清也。至于透壬为印，辰戌相冲，将以累印，谓之冲开印库可乎？ 况四库之中，虽五行俱有，而终以土为主。土冲则灵，金木水火，岂取胜以四库之冲而动乎？故财官属土，冲则库启，如甲用戊财而辰戌冲，壬用己官而丑未冲之类是也。然终以戊己干头为清用，干既透，即不冲而亦得也。至于财官为水，冲则反累，如己生辰月，壬透为财，戌冲则劫动，何益之有？丁生辰月，透壬为官，戌冲则伤官，岂能无害？其可谓之逢冲而壬水之财库官库开乎？ 今人不知此理，甚有以出库为投库。如丁生辰月，壬官透干，不以为库内之壬，干头透出，而反为干头之壬，逢辰入库，求戌以冲土，不顾其官之伤。更有可笑者，月令本非四墓，别有用神，年月日时中一带四墓，便求刑冲；日临四库不以为身坐库根，而以为身主入库，求冲以解。种种谬论，令人掩耳。 然亦有逢冲而发者，何也？如官最忌冲，而癸生辰月，透戊为官，与戌相冲，不见破格，四库喜冲，不为不足。却不知子午卯酉之类，二者相仇，乃冲克之冲，而四墓土自为冲，乃冲动之冲，非冲克之冲也。然既以土为官，何害于事乎？ 是故四墓不忌刑冲，刑冲未必成格。其理甚明，人自不察耳。 十八、论四吉神能破格财官印食，四吉神也，然用之不当，亦能破格。 如食神带煞，透财为害，财能破格也；春木火旺，见官则忌，官能破格也；煞逢食制，透印无功，印能破格也；财旺生官，露食则杂，食能破格也。 是故官用食破，印用财破。譬之用药，参苓芪术，本属良材，用之失宜，亦能害人。官忌食伤，财畏比劫，印惧财破，食畏印夺，参合错综，各极其妙。弱者以生扶为喜，强者因生扶而反害；衰者以裁抑为忌，太旺者反以裁抑而得益。吉凶喜忌，全在是否合于需要，不因名称而有分别也。 十九、论四凶神能成格煞伤枭刃，四凶神也，然施之得宜，亦能成格。如印绶根轻，透煞为助，煞能成格也。财逢比劫，伤官可解，伤能成格也。食神带煞，灵枭得用，枭能成格也。财逢七煞，刃可解厄，刃能成格也。 是故财不忌伤，官不忌枭，煞不忌刃，如治国长抢大戟，本非美具，而施之得宜，可以戡乱。 二十、论生克先后分吉凶月令用神，配以四柱，固有每字之生克以分吉凶，然有同此生克，而先后之间，遂分吉凶者，尤谈命之奥也。 如正官同是财伤并透，而先后有殊。假如甲用酉官，丁先戊后，后则以财为解伤，即不能贵，后运必有结局。若戊先而丁后时，则为官遇财生，而后因伤破，即使上运稍顺，终无结局，子嗣亦难矣。 印格同是贪格坏印，而先后有殊。如甲用子印，己先癸后，即使不富，稍顺晚境；若癸先而己在时，晚景亦悴矣。 食神同是财枭并透，而先后有殊。如壬用甲食，庚先丙后，晚运必亨，格亦富而望贵。若丙先而庚在时，晚运必淡，富贵两空矣。 七煞同是财食并透，而先后大殊。如己生卯月，癸先辛后，则为财以助用，而后煞用食制，不失大贵。若辛先而癸在时，则煞逢食制，而财转食党煞，非特不贵，后运萧索，兼难永寿矣。 他如此类，可以例推。然犹吉凶易者也，至丙生甲寅月，年癸时戊，官能生印，而不怕戊合；戊能泄身为秀，而不得越甲以合癸，大贵之格也。假使年月戊癸而时甲，或年甲而月癸时戊，则戊无所隔而合全癸，格大破矣。 丙生辛酉，年癸时己，伤因财间，伤之无力，间有小贵。假如癸己产并而中无辛隔，格尽破矣。 辛生申月，年壬月戊，时上丙官，不愁隔戊之壬，格亦许贵。假使年丙月壬而时戊，或年戊月丙而时壬，则壬能克丙，无望其贵矣。 如此之类，不可胜数，其中吉凶似难猝喻。然细思其故，理甚显然，特难为浅者道耳。 二十一、论星辰无关格局八字格局，专以月令配四柱，至于星辰好歹，既不能为生克之用，又何以操成败之权？况于局有碍，即财官美物，尚不能济，何论吉星？于局有用，即七煞伤官，何谓凶神乎？是以格局既成，即使满盘孤辰入煞，何损其贵？格局既破，即使満盘天德贵人，何以为功？今人不知轻重，见是吉星，遂致拋却用神，不管四柱，妄论贵贱，谬谈祸福，甚可笑也。 况书中所云禄贵，往往指正官而言，不是禄堂人贵人。如正财得伤贵为奇，伤贵也，伤官乃生财之具，正财得之，所以为奇，若指贵人，则伤贵为何物乎？又若因得禄而避位，得禄者，得官也，运得官乡，宜乎进爵，然如财用伤官食神，运透官则格条，正官运又遇官则重，凡此之类，只可避位也。若作禄堂，不独无是理，抑且得禄避位，文法上下相顾。古人作书，何至不通若是！ 又若女命，有云“贵众则舞裙歌扇”。贵众者，官众也，女以官为夫，正夫岂可叠出乎？一女众夫，舞裙歌扇，理固然也。若作贵人，乃是天星，并非夫主，何碍于众，而必为娼妓乎？ 然星辰命书，亦有谈及，不善看书者执之也。如“贵人头上带财官，门充驰马”，盖财官如人美貌，贵人如人衣服，貌之美者，衣服美则现。其实财官成格，即非贵人头上，怕不门充驰马！又局清贵，又带二德，必受荣封。若专主二德，则何不竟云带二德受两国之封，而秘先曰无煞乎？若云命逢险格，柱有二德，逢凶有救，右免于危，则亦有之，然终无关于格局之贵贱也。 二十二、论外格用舍八字用神既专主月令，何以又有外格乎？外格者，盖因月令无用，权而用之，故曰外格也。 如春木冬水、土生四季之类，日与月同，难以作用，类象、属象、冲财、会禄、刑合、遥迎、井栏、朝阳诸格，皆可用也。若月令自有用神，岂可另寻外格？又或春木冬水，干头已有财官七煞，而弃之以就外格，亦太谬矣。是故干头有财，何用冲财？干头有官，何用合禄？书云“提纲有用提纲重”，又曰“有官莫寻格局”，不易之论也。 然所谓月令无用者，原是月令本无用神，而今人不知，往往以财被劫官被伤之类。用神已破，皆以为月令无取，而弃之以就外格，则谬之又谬矣。 二十三、论宫分用神配六亲人有六亲，配之八字，亦存于命。 其由宫分配之者，则年月日时，自上而下，祖父妻子，亦自上而下。以地相配，适得其宜，不易之位也。 其由用神配之者，则正印也母，身所自出，取其生我也。若偏财受我克制，何反为父？偏财者，母之正夫也，正印为母，则偏才为父矣。正财为妻，受我克制，夫为妻纲，妻则从夫。若官煞则克制乎我，何以反为子女也？官煞者，财所生也，财为妻妾，则官煞为子女矣。至于比肩为兄弟，又理之显然者。 其间有无得力，或吉或凶，则以四柱所存或年月或日时财官伤刃，系是何物，然后以六亲配之用神。局中作何喜忌，参而配之，可以了然矣。 二十四、论妻子大凡命中吉凶，于人愈近，其验益灵。富贵贫贱，本身之事，无论矣，至于六亲，妻以配身，子为后嗣，亦是切身之事。故看命者，妻财子提纲得力，或年干有用，皆主父母身所自出，亦自有验。所以提纲得力，或年干有用，皆主父母双全得力。至于祖宗兄弟，不甚验矣。 以妻论之，坐下财官，妻当贤贵；然亦有坐财官而妻不利，逢伤刃而妻反吉者，何也？此盖月令用神，配成喜忌。如妻宫坐财，吉也，而印格逢之，反为不美。妻坐官，吉也，而伤官逢之，岂能顺意？妻坐伤官，凶也，而财格逢之，可以生堸，煞格逢之，可以制煞，反主妻能内助。妻坐阳刃，凶也，而或财官煞伤等格，四柱已成格局，而日主无气，全凭日刃帮身，则妻必能相关。其理不可执一。 既看妻宫，又看妻星。妻星者，干头之财也。妻透而成局，若官格透财、印多逢财、食伤透财为用之类，即坐下无用，亦主内助。妻透而破格，若印轻财露、食神伤官、透煞逢财之类，即坐下有用，亦防刑克。又有妻透成格，或妻宫有用而坐下刑冲，未免得美妻而难偕老。又若妻星两透，偏正杂出，何（可）一夫而多妻，亦防刑克之道也。 至于子息，其看宫分与星所透喜忌，理与论妻略同。但看子息，长生沐浴之歌，亦当熟读，如“长生四子中旬半，沐浴一双保吉祥，冠带临官三子位，旺中五子自成行，衰中二子病中一，死中至老没儿郞，除非养取他之子，入墓之时命夭亡，受气为绝一个子，胎中头产养姑娘，养中三子只留一，男子宫中子细详”是也。 然长生论法，用阳而不用阴。如甲乙日只用庚金长生，巳酉丑顺数之局，而不用辛金逆数之子申辰。虽书有官为女煞为男之说，然终不可以甲用庚男而用阳局，乙用辛男而阴局。盖木为日主，不问甲乙，总以庚为男辛为女，其理为然，拘于官煞，其能验乎？ 所以八字到手，要看子息，先看时支。如甲乙生日，其时果系庚金何宫？或生旺，或死绝，其多寡已有定数，然后以时干子星配之。如财格而时干透食，官格而时干透财之类，皆谓时干有用，即使时逢死绝，亦主子贵，但不甚繁耳。若又逢生旺，则麟儿绕膝，岂可量乎？若时干不好，子透破局，即逢生旺，难为子息。若又死绝，无所望矣。此论妻子之大略也。 二十五、论行运论运与看命无二法也。看命以四柱干支，配月令之喜忌，而取运则又以运之干，配八字之喜忌。故运中每运行一字，即必以此一字，配命中干支而统观之，为喜为忌，吉凶判然矣。 何为喜？命中所喜之神，我得而助之者是也。如官用印以制伤，而运助印；财生官而身轻，而运助身；印带财以为忌，而运劫财；食带煞以成格，身轻而运逢印，煞重而运助食；伤官佩印，而运行官煞；阳刃用官，而运助财乡；月劫用财，而运行伤食。如此之类，皆美运也。 何谓忌？命中所忌，我逆而施之者是也。如正官无印，而运行伤；财不透食，而运行煞；印绶用官，而运合官；食神带煞，而运行财；七煞食制，而运逢枭；伤官佩印，而运行财；阳刃用煞，而运逢食；建禄用官，而运逢伤。如此之类，皆败运也。 其有似喜而实忌者，何也？如官逢印运，而本命有合，印逢官运，而本命用煞之类是也。 有似忌而实喜者，何也？如官逢伤运，而命透印，财行煞运，而命透食之类是也。 又有行干而不行支者，何也？如丙生子月亥年，逢丙丁则帮身，逢巳午则相冲是也。 又有行支而不行干者，何也？如甲生酉月，辛金透而官犹弱，逢申酉则官植根，逢庚辛则混煞重官之类是也。 又有干同一类而不两行者，何也？如丁生亥月，而年透壬官，逢丙则帮身，逢丁则合官之类是也。 又有支同一类而不两行者，何也？如戊生卯月，丑年，逢申则自坐长生，逢酉则会丑以伤官之类是也。 又有同是相冲而分缓急者，何也？冲年月则急，冲日时则缓也。 又有同是相冲而分轻重者，何也？运本美而逢冲则轻，运既忌面又冲则重也。 又有逢冲而不冲，何也？如甲用酉官，行卯则冲，而本命巳酉相会，则冲无力；年支亥未，则卯逢年会而不冲月官之类是也。 又有一冲而得两冲者，何也？如乙用申官，两申并而不冲一寅，运又逢寅，则运与本命，合成二寅，以冲二申之类是也。 二十六、论行运成格变格命之格局，成于八字，然配之以运，亦有成格变格之要权。其成格变格，较之喜忌祸福尤重。 何为成格,本命用神，成而未全，从而就之者是也。如丁生辰月，透壬为宫，而运逢申子以会之；乙生辰月，或申或子会印成局，而运逢壬癸以透之。如此之类，皆成格也。 何为变格,如丁生辰月，透壬为官，而运逢戌，透出辰中伤官；壬生戌月，丁己并透，而支又会寅会午，作财旺生官矣，而运逢戊土，透出戌中七煞；壬生亥月，透己为用，作建禄用官矣，而运逢卯未，会亥成本，又化建禄为伤。如此之类，皆变格也。 然亦有逢成格而不喜者，何也？如壬生午月，运透己官，而本命有甲乙之类是也。 又有逢变格而不忌者，何也？如丁生辰月，透壬用官，逢戊而命有甲；壬生亥月，透己用官，运逢卯未，而命有庚辛之类是也。 成格变格，关系甚大，取运者其细详之。 二十七、论喜忌干支有别命中喜忌，虽支干俱有，而干主天，动而有为，支主地，静以待用，且干主一而支藏多，为福为祸，安不得殊？ 譬如甲用酉官，逢庚辛则官煞杂，而申酉不作此例。申亦辛之旺地，辛坐申酉，如府官又掌道印也。逢二辛则官犯重，而二酉不作此例。辛坐二酉，如一府而摄二郡也，透丁则伤官，而逢午不作此例。丁动而午静，且丁巳并藏，安知其为财也？ 然亦有支而能作祸福者，何也？如甲用酉官，逢午酉未能伤，而又遇寅遇戌，不隔二位，二者合而火动，亦能伤矣。即此反观，如甲生甲月，午不制煞，会寅会戌，二者清局而火动，亦能矣。然必会有动，是正与干有别也。即此一端，余者可知。 二十八、论支中喜忌逢运透清支中喜忌，固与干有别矣，而运逢透清，则静而待用者，正得其用，而喜忌之验，于此乃见。何谓透清？如甲用酉官，逢辰未即为财，而运透戊，逢午未即为伤，而运透丁之类是也。 若命与运二支会局，亦作清论。如甲用酉官，本命有午，而运逢寅戌之类。然在年则重，在日次之，至于时生于午，而运逢寅戌会局，则缓而不急矣。虽格之成败高低，八字已有定论，与命中原有者不同，而此五年中，亦能炒其祸福。若月令之物，而运中透清，则与命中原有者，不甚相悬，即前篇所谓行运成格变格是也。 故凡一八字到手，必须逐干逐支，上下统看。支为干之生地，干为支之发用。如命中有一甲字，则统观四支，有寅亥卯未等字否，有一字，皆甲木之根也。有一亥字，则统观四支，有壬甲二字否。有壬，则亥为壬禄，以壬水用；用甲，则亥为甲长生，以甲木用；用壬甲俱全，则一以禄为根，一以长生为根，二者并用。取运亦用此术，将本命八字，逐干支配之而已。 二十九、论时说拘泥格局 八字用神专凭月令，月无用神，台寻格局。月令，本也；外格，未也。今人不知轻重，拘泥格局，执假失真。 故戊生甲寅之月，时上庚甲，不以为明煞有制，而以为专食之格，逢甲减福。丙生子月，时逢巳禄，不以为正官之格，归禄帮身，而以为日禄归时，逢官破局。辛日透丙，时遇戊子，不以为辛日得官逢印，而以为朝阳之格，因丙无成。财逢时煞，不以为生煞攻身，而以为时上偏官。 癸生巳月，时遇甲寅，不以为暗官受破，而以为刑合成格。 癸生冬月，酉日亥时，透戊坐戌，不以为月劫建禄，用官通根，而以为拱戌之格，填实不利。辛日坐丑，寅年，亥月，卯时，不以为正财之格，而以为填实拱贵。 乙逢寅月，时遇丙子，不以为木火通明，而以为格成鼠贵。 如此谬论，百无一是，此皆由不知命理，妄为评断。 三十、论时说以讹传讹八字本有定理，理之不明，遂生导端，妄言妄听，牢不可破。如论干支，则不知阴阳之理，而以俗书体象歌诀为确论；论格局，则不知专寻月令，而以拘泥外格为活变；论生克，则不察喜忌，而以伤旺扶弱为定法；论行运，则不问同中有导，而以干支相类为一例。 究其缘由，一则书中用字轻重，不知其意，而谬生偏见；一则以鹆书无知妄作，误会其说，而深入迷途；一则论命取运，偶然湊合，而遂以己见为不易，一则以古人命式，亦有误收，即收之不误，又以己意入外格，尤为害人不浅。 如壬申、癸丑、己丑、甲戌，本杂气财旺生官也，而以为乙亥时，作时上偏官论，岂知旺财生煞，将救死之不暇，于何取贵？此类甚多，皆误收格局也。如己未、壬申、戊子、庚申，本食神生财也，而欲弃月令，以为戊日庚申合禄之格，岂知本身自有财食，岂不甚美？又何劳以庚合乙，求局外之官乎，此类甚多，皆硬入外格也。 人苟中无定见，察理不精，睹此谬论，岂能无惑？何况近日贵格不可解者，亦往往有之乎？岂知行术之人，必以贵命为指归，或将风闻为实据，或探其生日，而即以己意加之生时，谬造贵格，其人之八字，时多未确，即彼本身，亦不自知。若看命者不究其本，而徒以彼既富贵迁就其说以相从，无惑乎终身无解日矣！ 三十一、论正官官以克身，虽与七煞有别，终受彼制，何以切忌刑冲破害，尊之若是乎？岂知人生天地间，必无矫焉自尊之理，虽贵极天子，亦有天祖临之。正官者分所当尊，如在国有君，在家有亲，刑冲破害，以下犯上，乌乎可乎？ 以刑冲破害为忌，则以生之护之为喜矣。存其喜而去其忌则贵，而贵之中又有高低者，何也？以财印并透者论之，两不相碍，其贵也大。如薛相公命，甲申、壬申、乙巳，戊寅，壬印戊财，以乙隔之，水与土不相碍，故为大贵。若壬戌、丁未、戊甲、乙卯，杂气正官，透干会支，最为贵格，而壬财丁印，二者相合，仍以孤官无辅论，所以不上七品。 若财印不以两用，则单用印不若单用财，以印能护官，亦能泄官，而财生官也。若化官为印而透财，则又为甚秀，大贵之格也。如金状元命，乙卯、丁亥、丁未、庚戌，此并用财印，无伤官而不杂煞，所谓去其忌而存其喜者也。 然而遇伤在于佩印，混煞贵乎取清。如宣参国命，己卯、辛未、壬寅、辛亥，未中己官透干用清，支会水局，两辛解之，是遇伤而佩印也。李参政命，庚寅、乙酉、甲子、戊辰，甲用酉官，庚金混杂，乙以合之，合煞留官，是杂煞而取清也。 至于官格透伤用印者，又忌见财，以财能去印，未能生官，而适以护伤故也。然亦有逢财而反大贵者，如范太傅命，丁丑、壬寅、己巳、丙寅，支具巳丑，会金伤官，丙丁解之，透壬岂非破格？却不知丙丁并透，用一而足，以丁合壬而财去，以丙制伤而官清，无情而愈有情。此正造化之妙，变幻无穷，焉得不贵？至若地支刑冲，会合可解，已见前篇，不必再述，而以后诸格，亦不谈及矣。 三十二、论正官取运取运之道，一八字则有一八字这论，其理甚精，其法甚活，只可大略言之。变化在人，不可泥也。 如正官取运，即以正官所统之格分而配之。正官而用财印，身稍轻则取助身，官稍轻则助官。若官露而不可逢合，不可杂煞，不可重官。与地支刑冲，不问所就何局，皆不利也。 正官用财，运喜印受身旺之地，切忌食伤。若身旺而财轻官弱，即仍取财官运可也。 正官佩印，运喜财乡，伤食反吉。若官重身轻而佩印，则身旺为宜，不必财运也。 正官带伤食而用印制，运喜官旺印旺之乡，财运切忌。若印绶叠出，财运亦无害矣。 正官而带煞，伤食反为不碍。其命中用劫合煞，则财运可行，伤食可行，身旺，印绶亦可行，只不过复露七煞。若命用伤官合煞，则伤食与财俱可行，而不宜逢印矣。 三十三、论财财为我克，使用之物也，以能生官，所以为美。为财帛，为妻妾，为才能，为驿马，皆财类也。 财喜根深，不宜太露，然透一位以清用，格所最喜，不为之露。即非月令用神，若寅透乙、卯透甲之类，一亦不为过，太多则露矣。然而财旺生官，露亦不忌，盖露不忌，盖露以防劫，生官则劫退，譬如府库钱粮，有官守护，即使露白，谁敢劫之？如葛参政命，壬申、壬子、戊午、乙卯，岂非财露？唯其生官，所以不忌也。 财格之贵局不一，有财旺生官者，身强而不透伤官，不混七煞，贵格也。 有财用食生者，身强而不露官，略带一位比劫，益觉有情，如壬寅、壬寅、庚辰、辛巳，杨待郎之命是也。透官身弱，则格坏矣。 有财格佩印者，盖孤财不贵，佩印帮身，即印取贵。如乙未、甲申、丙申、庚寅，曾参政之命是也，然财印宜相并，如乙未、己卯、庚寅、辛巳，乙与己两不相能，即有好处，小富而已。 有用食而兼用印者，食与印两不相碍，或有暗官而去食护官，皆贵格也。如吴榜眼命，庚戌、戊子、戊子、丙辰，庚与丙隔两戊而不相克，是食与印不相碍也。如平江伯命，壬辰、乙巳、癸巳、辛酉，虽食印相克，而欲存巳戊官，是去食护官也。反是则减福矣。 有财用伤官者，财不甚旺而比强，辂露一位伤官以化之，如甲子、辛未、辛酉、壬辰，甲透未库，逢辛为劫，壬以化劫生财，汪学士命是也，财旺无劫而透伤，反为不利，盖伤官本非美物，财轻透劫，不得己而用之。旺而露伤，何苦用彼？徒使财遇伤而死生官之具，安望富贵乎？ 有财带七煞者，或合煞存财，或制煞生财，皆贵格也，如毛状元命，乙酉、庚辰、甲午、戊辰，合煞存财也；李御史命，庚辰、戊子、戊寅、甲寅，制煞生财也。 有财用煞印者，党煞为忌，印以化之，格成富局，若冬土逢之亦贵格。如赵待郎命，乙丑、丁亥、己亥、乙亥，化煞而即以解冻，又不露财以杂其印，所以贵也。若财用煞印，而财并透，非特不贵，亦不富也。 至于壬生午月，癸生巳月，单透财而亦贵，又月令有暗官也。如丙寅、癸巳、癸未、壬戌，林尚书命是也。又壬生巳月，单透财而亦贵，以其透丙藏戊，弃煞就财，美者存在赠者弃也。如丙辰、癸巳、壬戌、壬寅，王太仆命是也。至于劫刃太重，弃财就煞，如一尚书命，丙辰、丙申、丙午、壬辰，此变之又变者也。 三十四、论财取运财格取运，即以财格所就之局，分而配之。其财旺生官者，运喜身旺印缓，不利七煞伤官；若生官而后透印，伤官之地，不甚有害。至于生官而带食破局，则运喜印绶，而逢煞反吉矣。 财用食生，财食重而身轻，则喜助身；财食轻而身重，则仍行财食。煞运不忌，官印反晦矣。 财格佩印，运喜官乡，身弱逢之，最喜印旺。 财用食印，财轻则喜财食，身轻则喜比印，官运有碍，煞反不忌也。 财带伤官，财运则亨，煞运不利，运行官印，未见其美矣。 财带七煞。不论合煞制煞，运喜食伤身旺之方。 财用煞印，印旺最宜，逢财必忌。伤食之方，亦任意矣。 三十五、论印绶印绶喜其生身，正偏同为美格，故财与印不分偏正，同为一格而论之。印绶之格局亦不一，有印而透官者，正官不独取其生印，而即可以为用，与用煞者不同。故身旺印强，不愁太过，只要官星清纯，如丙寅、戊戌、辛酉、戊子，张参政之命是也。 然亦有带伤食而贵者，则如朱尚书命，丙戌、戊戌、辛未、壬辰，壬为戊制，不伤官也。又如临淮侯命，乙亥、己卯、丁酉、壬寅，己为乙制，己不碍官也。 有印而用伤食者，身强印旺，恐其太过，泄身以为秀气。如戊戌、乙卯、丙午、乙亥，李状元命也，若印浅身轻，而用层层伤食，则寒贫之局矣。 有用偏官者，偏官本非美物，藉其生印，不得已而用之。故必身重印轻，或身轻印重，有所不足，始为有性。如茅状元命，己巳、癸酉、癸未、庚申，此身轻印重也。马参政命，壬寅、戊申、壬辰、壬寅，此身重印轻也。若身印并重而用七煞，非孤则贫矣。 有用煞而兼带伤食者，则用煞而有制，生身而有泄，不论身旺印重，皆为贵格。 有印多而用财者，印重身强，透财以抑太过，权而用之，只要根深，无防财破。如辛酉、丙申、壬申、辛亥，汪侍郎命是也。若印轻财重，又无劫财以救，则为贪财破印，贫贱之局也。 即或印重财轻而兼露伤食，财与食相生，轻而不轻，即可就富，亦不贵矣。然亦有带食而贵者，何也？如庚寅、乙酉、癸亥、丙辰，此牛监薄命，乙合庚而不生癸，所以为贵，若合财存食，又可类推矣。如己未、甲戌、辛未、癸已，此合财存食之贵也。 又有印而兼透官煞者，或合煞，或有制，皆为贵格。如辛亥、庚子、甲辰、乙亥，此合煞留官也；壬子、癸卯、丙子、己亥、此官煞有制也。 至于化印为劫；弃之以就财官，如赵知府命，丙午、庚寅、丙午、癸已，则变之又变者矣。 更有印透七煞，而劫财以存煞印，亦有贵格，如庚戌、戊子、甲戌、乙亥是也。然此格毕竟难看，宜细详之。 三十六、论印绶取运印格取运，即以印格所成之局，分而配之。其印绶用官者，官露印重，财运反吉，伤食之方，亦为最利。 若用官而带伤食，运喜官旺印绶之乡，伤食为害，逢煞不忌矣。 印绶而用伤食，财运反吉，伤食亦利，若行官运，反见其灾，煞运则反能为福矣。 印用七煞，运喜伤食，身旺之方，亦为美地，一见财乡，其凶立至。 若用煞而兼带伤食，运喜身旺印绶之方，伤食亦美，逢官遇财，皆不吉。 印绶遇财，运喜劫地，官印亦亨，财乡则忌。 印格而官煞竞透，运喜食神伤官，印旺身旺，行之亦利。若再透官煞，行财运，立见其灾矣。 印用食伤，印轻者亦不利见财也。 三十七、论食神食神本属泄气，以其能生正财，所以喜之。故食神生财，美格也。财要有根，不必偏正叠出，如身强食旺而财透，大贵之格。若丁未、癸卯、癸亥、癸丑，梁丞相之命是也；己未、壬申、戊子、庚申，谢阁老之命是也。藏食露伤，主人性刚,如丁亥、癸卯、癸卯、甲寅，沈路分命是也。偏正叠出，富贵不巨，职甲午、丁卯、癸丑、丙辰，龚知县命是也。 夏木用财，火炎土燥，贵多就武。如己未、已巳、甲寅、丙寅，黄都督之命是也。若不用财而就煞印，最为威权显赫。如辛卯、辛卯、癸酉、己未，常国公命是也。若无印绶而单露偏官，只要无财，亦为贵格，如戊戌、壬戌、丙子、戊戌，胡会元命是也。 若金水食神而用煞，贵而且秀，职丁亥、壬子、辛巳、丁酉，舒尚书命是也。至于食神忌印，夏火太炎而木焦，透印不碍，如丙午、癸巳、甲子、丙寅，钱参政命是也。食神忌官，金水不忌，即金水伤官可见官之谓。至若单用食神，作食神有气，有财运则富，无财运则贫。 更有印来夺食，透财以解，亦有富贵，须就其全局之势而断之。至于食神而官煞竞出，亦可成局，但不甚贵耳。更有食神合煞存财，最为贵格。 至若食神透煞。本忌见财，而财先煞后，食以间之，而财不能党煞，亦可就贵。如刘提台命，癸酉、辛酉、己卯、乙亥是也。其余变化，不能尽述，类而推之可也。 三十八、论食神取运食神取运，即以食神所成之局，分而配之。食神生财，财重食轻，则行财食，财食重则喜帮身。官煞之方，俱为不美。 食用煞印，运喜印旺，切忌财乡。身旺，食伤亦为福运，行官行煞，亦为吉也。 食伤带煞，喜行印绶，身旺，食伤亦为美运，财则最忌。若食太重而煞轻，印运最利，逢财反吉矣。 食神太旺而带印，运最利财，食伤亦吉，印则最忌，官煞皆不吉也。 若食神带印，透财以解，运喜财旺，食伤亦吉，印与官煞皆忌也。 三十九、论偏官煞以攻身，似非美物，百大贵之格，多存七煞。盖控制得宜，煞为我用，如大英雄大豪杰，似难驾驭，而处之有方，则惊天动地之功，忽焉而就。此王侯将相所以多存七煞也。 七煞之格局亦不一：煞用食制者，上也，煞旺食强而身健，极为贵格。如乙亥、乙酉、乙卯、丁丑，极等之贵也。 煞用食制，不要露财透印，以财能转食生煞，而印能去食护煞也。然而财先食后，财生煞而食以制之，或印先食后，食太旺而印制，则格成大贵。如脱脱丞相命，壬辰、甲胡、丙戌、戊戌，辰中暗煞，壬以透之，戊坐四支，食太重而透甲印，以损太过，岂非贵格？若煞强食泄而印露，则破局矣。 有七煞用印者，印能护煞，本非所宜，而印有情，便为贵格。如何参政命，丙寅、戊戌、壬戌、辛丑，戊与辛同通月令，是煞印有情也。 亦有煞重身轻，用食则身不能当，不若转而就印，虽不通根月令，亦为无情而有情。格亦许贵，但不大耳。 有煞而用财者，财以党煞，本非所喜，而或食被制，不能伏煞，而财以去印存食，便为贵格。如周丞相命，戊戌、甲子，丁未、庚戌，戊被制不能伏煞，时透庚财，即以清食者，生不足之煞。生煞即以制煞，两得其用，尤为大贵。 又有身重煞轻，煞又化印，用神不清，而借财以清格，亦为贵格。如甲申、乙亥、丙戌、庚寅，刘运使命是也。 更有杂气七煞，干头不透财以清用，亦可取贵。 有煞而杂官者，或去官，或去煞，取清则贵。如岳统制命，癸卯、丁巳、庚寅、庚辰，去官留煞也。夫官为贵气，去官何如去煞？岂知月令偏官，煞为用而官非用，各从其重。若官格杂煞而去官留煞，不能如是之清矣。如沈郎中命，丙子、甲午、辛亥、辛卯，子冲午而克煞，是去煞留官也。 有煞无食制而用印当者，如戊辰、甲寅、戊寅、戊午、赵员外命是也。 至书有制煞不可太过之说，虽亦有理，然运行财印，亦能发福，不可执一也，乃若弃命从煞，则于外格详之。 四十、论偏官取运偏官取运，即以偏官所成之局分而配之。煞用食制，煞重食轻则助食，煞轻食重则助煞，煞食均而日主根轻则助身。忌正官之混杂，畏印绶之夺食。 煞用印绶，不利财乡，伤官为美，印绶身旺，俱为福地。 七煞用财，其以财而去印存食者，不利劫财，伤食皆吉，喜财怕印，透煞亦顺。 其以财而助煞不及者，财已足，则喜食印与帮身；财未足，则喜财旺而露煞。 煞带正官，不论去官留煞，去煞留官，身轻则喜助身，食轻则喜助食。莫去取清之物，无伤制煞之神。 煞无食制而用刃当煞，煞轻刃重则喜助煞，刃轻煞重，则宜制伏，无食可夺，印运何伤？七煞既纯，杂官不利。 四十一、论伤官伤官虽非吉神，实为秀气，故文人学士，多于伤官格内得之。而夏木见水，冬金见火，则又为秀之尤秀者也。其中格局比他格多，变化尤多，在查其气候，量其强弱，审其喜忌，观其纯杂，微之又微，不可执也。 故有伤官用财者，盖伤不利于民，所以为凶，伤官生财，则以伤官为生官之具，转凶为吉，故最利。只要身强而有根，便为贵格，如壬午、己酉、戊午、庚申，史春芳命也。 至于化伤为财，大为秀气，如罗状元命，甲子、乙亥、辛未、戊子，干头之甲，通根于亥，然又会未成局，化水为木，化之生财，尤为有情，所以伤官生财，冬金不贵，以冻水不能生木。若乃化木，不待于生，安得不为殿元乎？至于财伤有情，与化伤为财者，其秀气不相上下，如秦龙图命，己卯、丁丑、丙寅、庚寅，已与庚同根月令是也。 有伤官佩印者，印能制伤，所以为贵，反要伤官旺，身稍弱，始为秀气。如孛罗平章命，壬申、丙午、申午、壬申、伤官旺，印根深，身又弱，又是夏木逢润，其秀百倍，所以一品之贵。然印旺极深，不必多见，偏正叠出，反为不秀，故伤轻身重而印绶多见，贫穷之格也。 有伤官兼用财印者，财印相克，本不并用，只要干头两清而不相碍；又必生财者，财太旺而带印，佩印者印太重而带财，调停中和，遂为贵格。如丁酉、己酉、戊子、壬子，财太重而带印，而丁与壬隔以戊已，两不碍，且金水多而觉寒，得火融和，都统制命也。又如壬戌、己酉、戊午、丁巳，印太重而隔戊已，而丁与壬不相碍，一丞相命也。反是则财印不并用而不秀矣。 有伤官用煞印者，伤多身弱，赖煞生印以邦身而制伤，如己未、丙子、庚子、丙子，蔡贵妃也。煞因伤而有制，两得其宜，只要无财，便为贵格，如壬寅、丁未、丙寅、壬辰，夏阁老命是也。 有伤官用官者，他格不用，金水独宜，然要财印为辅，不可伤官并透。如戊申、甲子、庚午、丁丑，藏癸露丁，戊甲为辅，官又得禄，所以为丞相之格。若孤官无辅，或官伤并透，则发福不大矣。 若冬金用官，而又化伤为财，则尤为极秀极贵。如丙申、己亥、辛未、己亥，郑丞相命是也。 然亦有非金水而见官，何也？化伤为财，伤非其伤，作财旺生官而不作伤官见官，如甲子、壬申、己亥、辛未，章丞相命也。 至于伤官而官煞并透，只要干头取清，金水得之亦清，不然则空结构而已。 四十二、论伤官取运伤官取运，即以伤官所成之局，分而配之。伤官用财，财旺身轻，则利印比；身强财浅，则喜财运，伤官亦宜。 伤官佩印，运行官煞为宜，印运亦吉，伤食不碍，财地则凶。 伤官而兼用财印，其财多而带印者，运喜助印，印多而带财者，运喜助财。 伤官而用煞印，印运最利，伤食亦亨，杂官非吉，逢财即危。 伤官带煞，喜印忌财，然伤重煞轻，运喜印而财亦吉。惟七根重，则运喜伤食，印绶身旺亦吉，而逢财为凶矣。 伤官用官，运喜财印，不利食伤，若局中官露而财印两旺，则比劫伤官，未绐非吉矣。 四十三、论阳刃阳刃者，劫我正财之神，乃正财之七煞也。禄前一位，惟五阳有之，故为旭刃。不曰劫而曰刃，劫之甚也。刃宜伏制，官煞皆宜，财印相随，尤为贵显。夫正官而财印相随美矣，七煞得之，夫乃甚乎？岂知他格以煞能伤身，故喜制伏，忌财印；阳刃用之，则赖以制刃，不怕伤身，故反喜财印，忌制伏也。 阳刃用官，透刃不虑；阳刃露煞，透刃无成。盖官能制刃，透而不为害；刃能合煞，则有何功？如丙生午月，透壬制刃，而又露丁，丁与壬合，则七煞有贪合忘克之意，如何制刃？故无功也。 然同是官煞制刃，而格亦有高低，如官煞露而根深，其贵也大；官煞藏而不露，或露而根浅，其贵也小。若己酉、丙子、壬寅、丙午，官透有力，旺财生之，丞相命也。又辛酉、甲午、丙申、壬辰，透煞根浅，财印助之，亦丞相命也。 然亦有官煞制刃带伤食而贵者，何也？或是印护，或是煞太重而裁损之，官煞轻而取清之，如穆同知命，甲午、癸酉、庚寅、戊寅，癸水伤寅午之官，而戊以合之，所谓印护也，如贾平章命，甲寅、庚午、戊申、甲寅，煞两透而根太重，食以制之，所谓裁损也。如丙戌、丁酉、庚申、壬午，官煞竞出，而壬合丁官，煞纯而不杂。况阳刃之格，利于留煞，所谓取清也。 其于丙生午月，内藏己土，可以克水，尤宜带财佩印，若戊生午月，干透丙火，支会火乙，则化刃为印，或官或煞，透则去刃存印其格愈清。倘或财煞并透露，则犯去印存煞之忌，不作生煞制煞之例，富贵两空矣。 更若阳刃用财，格所不喜，然财根深而用伤食，以转刃生财，虽不比建禄月劫，可以取贵，亦可就富。不然，则刃与财相搏，不成局矣。 四十四、论阳刃取运阳刃用官，则运喜助官，然命中官星根深，则印绶比劫之方，反为美运，但不喜伤食合官耳。 阳刃用煞，煞不甚旺，则运喜助煞；煞若太重，则运喜身旺印绶，伤食亦不为忌。 阳刃而官煞并出，不论去官去煞，运喜制伏，身旺亦利，财地官乡反为不吉也。 四十五、论建禄月劫建禄者，月建逢禄堂也，禄即是劫。或以禄堂透出，即可依以用者，非也。故建禄与月劫，可同一格，不必加分，皆以透干支，别取财官煞食为用。 禄格用官，干头透出为奇，又要财印相随，不可孤官无辅。有用官而印护者，如庚戌、戊子、癸酉、癸亥，金丞相命是也。有用官而财助者，如丁酉、丙午、丁巳、壬寅，李知府命是也。 有官而兼带财印者，所谓身强值三奇，尤为贵气。三奇者，财官印也，只要以官隔之，使财印两不相伤，其格便大，如庚午、戊子、癸卯、丁巳，王少师命是也。 禄劫用财，须带食伤，盖月令为劫而以财作用，二财相克，必以伤食化之，始可转劫生财，如甲子、丙子、癸丑、壬辰，张都统命是也。 至于化劫为财，与化劫为生，尤为秀气。如己未、已巳、丁未、辛丑，丑与巳会，即以劫财之火为金局之财，安得不为大贵？所谓化劫为财也。如高尚书命，庚子、甲申、庚子、甲申，即以劫财之金，化为生财之水，所谓化劫为生也。 禄劫用煞，必须制伏台，如娄参政命，丁巳、壬子、癸卯、己未，壬合丁财以去其党煞，卯未会局以制伏是也。 至用煞而又财，本为不美，然能去煞存财，又成贵格。戊辰、癸亥、壬午、丙午，合煞存财，袁内阁命是也。 其禄劫之格，无财官而用伤食，泄其太过，亦为秀气。唯春木秋金，用之则贵，盖木逢火则明，金生水则灵。如张状元命，甲子、丙寅、甲子、丙寅，木火通明也；又癸卯、庚申、庚子、庚辰，金水相涵也。 更有禄劫而官煞竞出，必取清方为贵格。如一平章命，辛丑、庚寅、甲辰、乙亥、合煞留这也；如辛亥、庚写、甲申、丙寅，制煞留官也。 倘或两官竞出，亦须制伏，所谓争正官不可无伤也。 若夫用官而孤官无辅，格局更小，难于取贵，若透伤食便不破格。然亦有官伤并透而贵者，何也？如己酉、乙亥、壬戌、庚子，庚合乙而去伤存官，王总兵命也。 用财而不透伤食，便难于发端，然干头透一位而不杂，地支根多，亦可取富，但不贵耳。 用官煞重而无制伏，运行制伏，亦可发财，但不可官煞太重，致令身危也。 四十六、论建禄月劫取运禄劫取运，即以禄劫所成之局，分而配之。禄劫用官，印护者喜财，怕官星之逢合，畏七煞之相乘。伤食不能为害，劫比未即为凶。 财生喜印，宜官星之植根，畏伤食之相侮，逢财愈见其功，杂煞岂能无碍？禄劫用财而带伤食，财食重则喜印绶，而不忌比肩；财食轻则宜助财，而不喜印比。逢煞无伤，遇官非福。 禄劫用煞食制，食重煞轻，则运宜助煞；食轻煞重，则运喜助食。 若用煞而带财，命中合煞存财，则伤食为宜，财运不忌，透官无虑，身旺亦亨。若命中合财存煞，而用食制，煞轻则助煞，食轻则助食则已。 禄劫而用伤食，财运最宜，煞亦不忌，行印非吉，透官不美。若命中伤食太重，则财运固利，而印亦不忌矣。 禄劫而官煞并出，不论合煞留官，存官制煞，运喜伤食，比肩亦宜，印绶未为良图，财官亦非福运。 四十七、论杂格杂格者，月令无用，以外格而用之，其格甚多，故谓之杂。大约要干头无官无煞，方成格，如有官煞，则自有官煞为用，列外格矣。若透财尚可取格，然财根深，或财透两位，则亦以财为重，不取外格也。 试以诸格论之，有取五行一方秀气者，取甲乙全亥卯未、寅卯辰，又生春月之类，本是一派劫财，以五行各得其全体，所以成格，喜印露而体纯。如癸亥、乙卯、乙未、壬午，吴相公命是也。运亦喜印绶比劫之乡，财食亦吉，官煞则忌矣。 有从化取格者，要化出之物，得时乘令，四支局全。如丁壬化木，地支全亥卯未、寅卯辰，而又生于春月，方为大贵。否则，亥未之月亦是木地，次等之贵，如甲戌、丁卯、壬寅、甲辰，一品贵格命也。运喜所化之物，与所化之印绶，财伤亦可，不利官煞。 倒冲成格者，以四柱列财官而对面以冲之，要支中字多，方冲得动。譬如以弱主邀强官，主不众则宾不从。如戊午、戊午、戊午、戊午，是冲子财也；甲寅、庚午、丙午、甲午，是冲子官也。运忌填实，余俱可行。 有朝阳成格者，戊去朝丙，辛日得官，以丙戊同禄于巳，即以引汲之意。要干头无木火，方成其格，盖有火则无待于朝，有木财触戊之怒，而不为我朝。如戊辰、辛酉、辛酉、戊子，张知县命是也。运喜土金水，木运平平，火则忌矣。 有合禄成格者，命无官星，借干支以合之。戊日庚申，以庚合乙，因其主而得其偶。如己未、戊辰、戊辰、庚申，蜀王命是也。癸日庚申，以申合巳，因其主而得其朋，如己酉、癸未、癸未、庚申，起丞相命是也。运亦忌填实，不利官煞，理会不宜以火克金，使彼受制而不能合，余则吉矣。 有弃命保财者，四柱皆财而身无气，舍而从之，格成大贵。若透印则身赖印生而不从，有官煞则亦无从财兼从煞之理，其格不成。如庚申、乙酉、丙申、乙丑，王十万命造也。运喜伤食财乡，不宜身旺。有弃命从煞者，四柱皆煞，而日主无根，舍而从之，格成大贵。若有伤食，则煞受制而不从，有印则印以化煞而不从。如乙酉、乙酉、乙酉、甲申，李侍郎命是也。运喜财官，不宜身旺，食伤则尤忌矣。 有井栏成格者，庚金生三七月，方用此格。以申子辰冲寅午戌，财官印绶，合而冲之，若透丙丁，有巳午，以现有财官，而无待于冲，乃非井栏之格矣。如戊子、庚申、庚申、庚申，郭统制命也。运喜财，不利填实，余亦吉也。 有刑合成格者，癸日甲寅时，寅刑巳而得财官，格与合禄相似，但合禄则喜以合之，而刑合则硬以致之也。命有庚申，则木被冲克而不能刑；有戊已字，则现透官煞而无待于刑，非此格矣。如乙未、癸卯、癸卯、甲寅，十二节度使命是也。运忌填实，不利金乡，余则吉矣。 有遥合成格者，巳与丑会，本同一局，丑多则会巳而辛丑处官，亦合禄之意也。如辛丑、辛丑、辛丑、庚寅，章统制命是也。若命是有子字，则丑与子合而不遥，有丙丁戊已，则辛癸之官煞已透，而无待于遥，另有取用，非此格矣。至于甲子遥已，转辗求俣，似觉无情，此格可废，因罗御史命，聊复存之。为甲申、甲戌、甲子、甲子，罗御史命是也。 若夫拱禄、拱贵、趋乾、归禄、夹戌、鼠贵、骑龙、日贵、日德、富禄、魁罡、食神时墓、两干不杂、干支一气、五行具足之类，一切无理之格，既置勿取。即古人格内，亦有成式，总之意为牵就，硬填人格，百无一是，徒误后学而已。乃若天地双飞，虽富贵亦有自有格，不全赖此。而亦能增重基格，即用神不甚有用，偶有依以为用，亦成美格。然而有用神不吉，即以为凶，不可执也。 其于伤官伤尽，谓是伤尽，不宜一见官，必尽力以伤之，使之无地容身，现行伤运，便能富贵，不知官有何罪，而恶之如此？况见官而伤，则以官非美物，而伤以制之，又何伤官之谓凶神，而见官之为祸百端乎？予用是术以历试，但有贫贱，并无富贵，未轻信也，近亦见有大贵者，不知何故。然要之极贱者多，不得不观其人物以衡之。]]></content>
      <categories>
        <category>书籍</category>
      </categories>
      <tags>
        <tag>易学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《白夜行》]]></title>
    <url>%2F2016%2F10%2F07%2Fbaiyexing%2F</url>
    <content type="text"><![CDATA[总评趁着国庆快要结束前，抓紧时间把《白夜行》看完了，这类侦探小说我算是看透了，啥都不说，先给你铺垫个500页，你要是没兴趣看了（确实不看也罢），那就看不到最后5秒甚至2秒的高潮，哦……不对，是5页甚至2页的高潮结局？但是，人嘛就是为了寻求这种刺激带来的快感啊，所以，为了这5页的高潮，怎么也得看完啊！说实在的，这本书值得一看！这个豆瓣的书评写得很不错！ 说人性先讲讲这个人性吧，毕竟是侦探小说，肯定少不了很多的犯罪情节。但是作者也应该想到了单纯的恶和善其实也是很难存在的，写出来的小说也必定是没人看的，所以想点花套路，所以说嘛对于雪穗和亮司他们的做法肯定是罪恶的，我们作为充满正能量的好青年肯定是不赞成的。但是基于他们童年遭受的苦难，我想这也是一般人无法体会的，不正常的环境导致了他们不正常的发展。 说雪穗和亮司的爱说起来，我是不认为他们的爱是单纯的男女之爱，偏向于刑警笹垣的枪虾和虾虎鱼的互利共生关系，类似于这样的爱是什么爱？我也不清楚如何定义？对于亮司来说，他短短一生都是在为雪穗而活，亮司的小男孩和小女孩牵手的剪纸，希望他们能在白天里阳光下自由快乐的牵手行走。而雪穗应该也是深爱着亮司的，雪穗说：“我的天空里没有太阳，总是黑夜，但并不暗，因为有东西代替了太阳。虽然没有太阳那么明亮，但对我来说已经足够。凭借着这份光，我便能把黑夜当成白天。我从来就没有太阳，所以不怕失去。”结尾是这样写的：“雪穗像人偶般面无表情。她冰冷地回答：‘我不知道。’”“只见雪穗正沿扶梯上楼，背影犹如白色的幽灵。”“她一次都没有回头。”为什么呢？因为她人生中的太阳没有了，所以她的灵魂没了，她成了幽灵！这是无奈又凄美的爱情！太阳没了，灵魂没了，爱没了，所以故事也就结束了！ 小男孩对于“手牵手在太阳下散步”的念想，是那段素净却因此注定无法实现的爱情。就是因为这段爱情，东野圭吾才保留了日本文学一向迷恋的永恒悲伤。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客测试]]></title>
    <url>%2F2016%2F09%2F25%2Ftest%2F</url>
    <content type="text"><![CDATA[Why因为无聊实在是感觉wordpress过于臃肿，而且没有好看简洁的主题，说干就干，立马就把wordpress博客内容迁移，其实wordpress也才弄了几天那就折腾一下 Test试试看我写的md格式是否正确看看next主题效果 Note首先，使用hexo-migrator-wordpress插件将wordpress文件迁移,对markdown的不足和常用的CSS样式进行扩展，比如图片居中，查了hexo标签插件的image插件，先是没注意那个[class name]后来才想到这是CSS样式，并且可以自己添加自定义样式，我使用的next主题，next主题中/source/_custom/custom.styl可以添加自定义CSS，但是我添加的图片居中没实现，我不服啊……F12检查发现CSS样式加了下划线，往前找，发现原来的CSS加了!important,于是我也给自己的样式加了!important,呵呵……之后，为了绑定github pages的域名,需要在/source文件夹中新建CNAME文件，然后填上自己要绑定的域名；绑定coding page可以直接在page服务中绑定；写文章要想有首页文章折叠，阅读全文的按钮，可以自己在md文章中加入&lt;!--more--&gt;,API里也没看到啊，也是醉了 PS：chrome清楚缓存快捷键：ctrl+shift+del 接下来，就是对评论，搜索，图标的一些优化的，相信也没什么大问题了，目前看来hexo还是很简洁，用markdown格式写文章也是我想要的，所以继续加油！ 2016.9.29更新今天添加了swiftype搜索，并且更改了搜索框的样式；swifteype在我之前没添加sitemap时一直显示在crawling中，很是让人蛋疼，后来搜索之后才发现有hexo-generator-sitemap这个插件，生成了网站sitemap，至此告一段落^_^]]></content>
      <categories>
        <category>随笔生活</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《我的零点时刻》]]></title>
    <url>%2F2016%2F09%2F25%2Fmy-zero-time%2F</url>
    <content type="text"><![CDATA[以前是不喜欢看这些书的，看到这种书名和封面就已经没有翻开的欲望。今天，论文有点看不下去了，就去实验室翻了翻书，都是些小宝的非主流书，《我的零点时刻》毕竟是朱军签过名的，那就拿来看看吧。 看了之后，总体感觉朱军很有文化，他是一个偏重传统文化的爱国之人，整本书是充满正能量的，那一辈人的踏实、努力、执着确实值得我们去学习。对于我们这一辈人来说，浮躁多了一些，负能量多了一些，急功近利多了一些。娱乐化的节目充斥了整个视野，但是除了娱乐大多却没有什么价值，没法引起思考和共鸣。所以以后，看一个节目，我也会思考和判断这个节目到底有没有价值？ 对于我这个把不住口的执、犟性格来说，得时刻谨记舌头地下压死人啊……有句话让我印象深刻，书里说是季羡林总结的，叫：“假话全不说，真话说不全”。恩，有道理，别傻乎乎的给你说得一点面子都没有，毕竟，人啊，都还是希望体面得活着。另外一句玩笑话说得也很有意思，“这年头，说真话得罪朋友，说假话得罪自己，那就让我们说笑话吧。说假话迟早完蛋，说真话立马完蛋，说笑话顶多被骂扯淡”，哈哈……得好好说话啊。老舍也说过，语言的有力无力，决定于思想是否精辟，感情是否浓厚，字句对安排是否得当，而并不靠一些土话甚至脏话给打气撑腰。所以，做一个会说话的有用好人！ 此外，做一件事不要去抱怨，没用，要不你就不干，要不你承担不了不干的后果，你就开开心心去干，不要觉得委屈，每天苦哈哈的伤己伤人。所以说没事弄点鸡汤喝喝也是有必要的嘛，鸡汤鸡汤，他毕竟还是有营养的嘛…所以，即使我知道了很多真相，我还是要努力前行，因为我们承载了中国带来的荣耀，我们也应该为它承担苦难，贡献自己的力量，而不是一味的批评而不是去解决问题，我还是我，那个充满正能量的阳光少年！]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《平凡的世界》]]></title>
    <url>%2F2016%2F09%2F20%2Fordinary-world%2F</url>
    <content type="text"><![CDATA[这次我看的是《平凡的世界》普及本，删除了关于官场及人事变动的一些事，非常好看，四百多页的书，加起来一天不到的时间就看完了，因为刻画的十分生动，印象深刻的有那么一句话是说，哪敢借一万，借人八九十块手都抖，哎呀，笑死我了，很真实也很有意思，重要的是很能带入情景的书最后还能让你有所思考，也难怪拿了茅盾文学奖。 这个小说是围绕孙家两兄弟来写的，大哥孙少安因为出身不好，家庭环境差就不敢娶和他亲梅竹马但是比他家境好的田润叶，造就了田润叶的悲剧，对孙少安来说可能也是一种遗憾。兄弟孙少平喜爱读书，有一定文化，但是没当成教师去了煤矿，坚持读书和学习，这是很不容易的，田晓霞也是因为这样才欣赏和喜欢他的，最后两人相恋，而田晓霞出身也很好，但是最后却因为记者去灾区报道救人牺牲，这对于孙少平是很大的打击，心酸啊。。。两兄弟都勤奋刻苦但又是那种自尊心极强的人，环境的压力，生活的压力造就了他们的一生…… 对于我来说，金凤凰是对现在很多农村大学生或者农村出来的优秀青年的称呼，而我也是其中之一，不可置否我们得去思考这个问题，自尊或者是过度的自尊对别人会不会有伤害？你的品位是不是low到与别人无法交流但是你却不以为然？所以经济基础决定上层建筑这句话始终是没有问题的，别想太多，多挣钱才是硬道理啊，别让你的下一代重蹈覆辙，别让自己后悔！ 摘抄一句：刹那间我真想令时光停驻，好让我回顾自己，回顾失去的年华，缅怀那一个穿连衣裙和瘦窄的短衫的小女孩…让我追悔少年时代我心灵的愚昧无知，它轻易地错过了我一生中未来可以获得的欢乐和幸福！]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[9月20日以前学习笔记]]></title>
    <url>%2F2016%2F09%2F20%2Fstudylist%2F</url>
    <content type="text"><![CDATA[学习笔记7.10 sass和compass:Sass是一个CSS3的扩展语言，它提供了丰富的特性使得编写样式更加容易：嵌套样式，变量定义，扩展，mixin等等;Compass是一个使用了Sass的库，它将很多常用样式打包成了一些模块，我们可以在自己的项目中使用这些模块，比如模块reset可以用来将不同浏览器的差异抹平,css3则用来生成CSS3相关的属性等$ gem install compass$ compass create projectNamesublime插件:emmet,html-css-js7.11ubuntu16.04安装网易云音乐 源可换成阿里源；安装shadowsocks客户端时，linux使其自启动可在/etc/rc.local中 exit0 前加入命令 sudo ssolocal -c /etc/shadowsock.json 不需要在后面加-d start7.12mongodb需要安装mongdb-server和mongodb-clients才可以不用一直输入./mongod –dbpath ../blog/打开mongodb等待连接mongodb删除数据库：db.dropDatabase()；删除集合：db.collection.drop()7.26今天复习了下bootstrap，这几天都有点颓废，把亮剑小说看完了，瞬间热血沸腾，其实电视里拍的只是小说的一部分啊，我想我应该学习老李的是勇敢顽强，为了真理永远不能屈服，那么才能培养出一生正气至于文革，我想说的是很同意知乎上一个知友的说法，对于日本篡改教科书，不承认南京大屠杀，当局强烈谴责；那么对于自己的wg,64,为什么不能正确面对；我希望未来的中国是民主的正气的自由的积极向上的，我想中华民主几千年文明的底蕴传承，中国未来是有希望的。而我也要在其中做出自己的一份贡献，最近看了很多不是那么美好的事实，无知是幸福的，但是真理是我们应该追求的，即使痛苦。但是庆幸的是，我还是个积极向上的阳光青年值得注意的是别那么傲娇了，嘴下积德，好好的读好书，好好学习本领（听着 《再见 小时候》好听）&amp;nbsp 表示Non-breaking spacebootstrap加element不要直接在元素里加row class8.02JS对象的属性用.（点）叠加，数组用 [下标] 来访问。8.04JS中str是不变的，str.toLowerCase()/str.toUpperCase()不能改变原字符串8.14JS中break continue可以加标签，break ：label跳转到该标签位置8.17debian开机自启动，网上查看开机自启动脚本位于/etc/local，但是假如脚本无法启动，也没有/etc/rc.d/rc.local这个文件，通过vim /etc/inittab查看需要启动服务的script的放置路径，我的vps位于/etc/init.d/rc.local，直接在这个里添加脚本可以开机自启动8.28ll命令：打开.bashrc文件修改ll，并使其生效 source .bashrc8.31rtl8188eus无线网卡内核驱动，(来自：https://github.com/lwfinger/)rtl8188eu通过此处代码编译，编译流程：configure,make all,make install双系统linux系统时间要比windows快8小时，Windows/Ubuntu 双系统用户会发现在 Ubuntu 里面的时间正常的情况下Windows的系统时间被改到8小时前。 原来 Linux 操作系统是以 CMOS 时间做为格林威治标准时间，再根据系统设置的时区来确定目前系统时间。但是Windows 会直接修改CMOS 时间。而中国的时区是+8区，所以才会造成时间被调整了-8个小时。所以您可以让 Windows 去使用时区或者让 Ubuntu 使用本地时间。修改 Windows 使用时区的方法是在注册表： HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\TimeZoneInformation\ 下面增加一个名为 RealTimeIsUniversal 的REG_DWORD 键，并赋值为 1。而让Ubuntu 使用本地时间的方法是： sudo gedit /etc/default/rcS 把里面的 UTC=yes 改为 UTC=no (来自：http://blog.chinaunix.net/uid-8305736-id-2033022.html)互联网网络协议： 实体层：把电脑连接起来的物理手段。它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。 链接层：确定了0和1的分组方式。以太网协议：一帧(frame)：Head+Data;Head包含发送和接受者的信息，即网卡地址（MAC地址），每个网卡的地址是独一无二的；广播：(arp协议识别接收方网卡地址)以太网它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让同一子网每台计算机自己判断MAC地址与标头中接受方的MAC地址，是否为接收方。（数据包的定义、网卡的MAC地址、广播的发送方式） 网络层： 必须找到一种方法，能够区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用”路由”方式发送。（”路由”的意思，就是指如何向不同的子网络分发数据包，这是一个很大的主题）；这就导致了”网络层”的诞生，它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”，简称”网址”。”网络层”出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。 规定网络地址的协议叫IP协议，IP4为32地址，前24位为网络部分，后8位为主机部分，处于同一子网络的计算机的网络部分应相同。所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。判断方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。IP数据包直接放进以太网中的数据部分。不在同一个子网络中需要通过网关转发，而使用ARP协议可以得到同一个子网络内的主机MAC地址。 传输层：我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”端口”（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。。”传输层”的功能，就是建立”端口到端口”的通信。相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把主机+端口，叫做”套接字”（socket）。UDP协议：UDP数据包，也是由”标头”和”数据”两部分组成。”标头”部分主要定义了发出端口和接收端口，”数据”部分就是具体的内容。然后，把整个UDP数据包放入IP数据包的”数据”部分，而前面说过，IP数据包又是放在以太网数据包之中的。特点是简单，但可靠性差。TCP协议：可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。TCP数据包和UDP数据包一样，都是内嵌在IP数据包的”数据”部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。（以太网数据包的数据部分，最大长度为1500字节，超出需分割） 应用层：”应用层”的作用，就是规定应用程序的数据格式。举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了”应用层”。这是最高的一层，直接面对用户。它的数据就放在TCP数据包的”数据”部分。因此，现在的以太网的数据包就变成下面这样。 上网设置： 本机的IP地址 子网掩码 网关的IP地址 DNS的IP地址（把网址转换为IP地址） 9.5 shadowsocks,500 internal privoxy error.怎么解决？（https://www.zhihu.com/question/40771057）以管理员身份运行命令提示符（cmd），执行： netsh interface ipv4 reset netsh interface ipv6 reset netsh winsock reset 重启电脑，解决。9.10 Vim 编辑文件报：Swap file “Hello.java.swp” already exists!问题原因： Vim 编辑 Hello.java 文件的时候，非正常退出，然后又重新再 Vim 这个文件一般都会提示这个。解决办法： 进入被编辑的文件目录，比如：Hello.java 我放在 /opt 目录下，那就先：cd /opt， 然后：ls -A，会发现有一个：.Hello.java.swp，把这个文件删除掉：rm -rf .Hello.java.swp，然后重新 Vim 文件即可。9.20 wordpress安装：LAMP；数据库建立；5分钟安装；插件授权录后，执行sudo chown -R www-data /var/www/wordpress sudo chmod -R 775 /var/www/wordpress这样就完全解决问题了.注意了,不需要把/var/www/目录的所有者也设置为www-data,而只需要设置wordpress文件夹的所有者.wp-config.php里加入下面代码:define(&quot;FS_METHOD&quot;,&quot;direct&quot;); define(&quot;FS_CHMOD_DIR&quot;,0777); define(&quot;FS_CHMOD_FILE&quot;,0777);&nbsp;]]></content>
      <categories>
        <category>IT</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
</search>